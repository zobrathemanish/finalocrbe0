"use strict";

var logger = require('../logging').getLogger({ "name": "react-server.core.util.ClientCssHelper", "color": { "server": 147, "client": "rgb(127,127,212)" } });

var _require = require('../constants'),
    PAGE_CSS_NODE_ID = _require.PAGE_CSS_NODE_ID;

var Q = require('q');
var PageUtil = require('./PageUtil');

var loadedCss = {};

module.exports = {

	registerPageLoad: function registerPageLoad() {
		if (false) {
			throw new Error("ClientCssHelper.registerPageLoad can't be called server-side");
		}

		// for each css node in the head that the react-server server wrote to the response, note it down in the cache, so that
		// we can remove it on a page to page transition.
		var serverWrittenLinkNodes = document.head.querySelectorAll("link[" + PAGE_CSS_NODE_ID + "],style[" + PAGE_CSS_NODE_ID + "]");
		for (var i = 0; i < serverWrittenLinkNodes.length; i++) {
			var key,
			    styleNode = serverWrittenLinkNodes[i];
			if (styleNode.href) {
				key = normalizeLocalUrl(styleNode.href);
			} else {
				key = styleNode.innerHTML;
			}
			loadedCss[key] = styleNode;
		}
	},

	ensureCss: function ensureCss(routeName, pageObject) {
		var _this = this;

		if (false) {
			throw new Error("ClientCssHelper.registerPageLoad can't be called server-side");
		}

		return Q.all(PageUtil.standardizeStyles(pageObject.getHeadStylesheets())).then(function (newCss) {
			var newCssByKey = {};
			newCss.filter(function (style) {
				return !!style;
			}).forEach(function (style) {
				newCssByKey[_this._keyFromStyleSheet(style)] = style;
			});

			// first, remove the unneeded CSS link elements.
			Object.keys(loadedCss).forEach(function (loadedCssKey) {

				if (!newCssByKey[loadedCssKey]) {
					// remove the corresponding node from the DOM.
					logger.debug("Removing stylesheet: " + loadedCssKey);
					var node = loadedCss[loadedCssKey];
					node.parentNode.removeChild(node);
					delete loadedCss[loadedCssKey];
				}
			});

			// next add the style URLs that weren't already loaded.
			return Q.all(Object.keys(newCssByKey).map(function (newCssKey) {
				var retval;
				if (!loadedCss[newCssKey]) {
					// this means that the CSS is not currently present in the
					// document, so we need to add it.
					logger.debug("Adding stylesheet: " + newCssKey);

					var style = newCssByKey[newCssKey];
					var styleTag;

					if (style.href) {
						styleTag = document.createElement('link');
						styleTag.rel = 'stylesheet';
						styleTag.href = style.href;

						// If we _can_ wait for the CSS to be loaded before
						// proceeding, let's do so.
						if ('onload' in styleTag) {
							var dfd = Q.defer();
							styleTag.onload = dfd.resolve;
							retval = dfd.promise;
						}
					} else {
						styleTag = document.createElement('style');
						styleTag.innerHTML = style.text;
					}
					styleTag.type = style.type;
					styleTag.media = style.media;

					loadedCss[newCssKey] = styleTag;
					document.head.appendChild(styleTag);
				} else {
					logger.debug("Stylesheet already loaded (no-op): " + newCssKey);
				}
				return retval;
			}));
		});
	},

	_keyFromStyleSheet: function _keyFromStyleSheet(style) {
		return normalizeLocalUrl(style.href) || style.text;
	}
};

function normalizeLocalUrl(url) {
	// Step 1: make the url protocol less first.  This helps recognizing http://0.0.0.0:3001/common.css
	// and //0.0.0.0:3001/common.css as the same file.
	// Step 2: The browser will give us a full URL even if we only put a
	// path in on the server.  So, if we're comparing against just
	// a path here we need to strip the base off to avoid a flash
	// of unstyled content.
	if (typeof url === 'string') {
		url = url.replace(/^http[s]?:/, '').replace(new RegExp("^\/\/" + location.host), '');
	}

	return url;
}
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInV0aWwvQ2xpZW50Q3NzSGVscGVyLmpzIl0sIm5hbWVzIjpbImxvZ2dlciIsInJlcXVpcmUiLCJnZXRMb2dnZXIiLCJQQUdFX0NTU19OT0RFX0lEIiwiUSIsIlBhZ2VVdGlsIiwibG9hZGVkQ3NzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlZ2lzdGVyUGFnZUxvYWQiLCJFcnJvciIsInNlcnZlcldyaXR0ZW5MaW5rTm9kZXMiLCJkb2N1bWVudCIsImhlYWQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaSIsImxlbmd0aCIsImtleSIsInN0eWxlTm9kZSIsImhyZWYiLCJub3JtYWxpemVMb2NhbFVybCIsImlubmVySFRNTCIsImVuc3VyZUNzcyIsInJvdXRlTmFtZSIsInBhZ2VPYmplY3QiLCJhbGwiLCJzdGFuZGFyZGl6ZVN0eWxlcyIsImdldEhlYWRTdHlsZXNoZWV0cyIsInRoZW4iLCJuZXdDc3NCeUtleSIsIm5ld0NzcyIsImZpbHRlciIsInN0eWxlIiwiZm9yRWFjaCIsIl9rZXlGcm9tU3R5bGVTaGVldCIsIk9iamVjdCIsImtleXMiLCJsb2FkZWRDc3NLZXkiLCJkZWJ1ZyIsIm5vZGUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJtYXAiLCJyZXR2YWwiLCJuZXdDc3NLZXkiLCJzdHlsZVRhZyIsImNyZWF0ZUVsZW1lbnQiLCJyZWwiLCJkZmQiLCJkZWZlciIsIm9ubG9hZCIsInJlc29sdmUiLCJwcm9taXNlIiwidGV4dCIsInR5cGUiLCJtZWRpYSIsImFwcGVuZENoaWxkIiwidXJsIiwicmVwbGFjZSIsIlJlZ0V4cCIsImxvY2F0aW9uIiwiaG9zdCJdLCJtYXBwaW5ncyI6Ijs7QUFDQSxJQUFJQSxTQUFTQyxRQUFRLFlBQVIsRUFBc0JDLFNBQXRCLENBQWdDLEVBQUMsUUFBTyx3Q0FBUixFQUFpRCxTQUFRLEVBQUMsVUFBUyxHQUFWLEVBQWMsVUFBUyxrQkFBdkIsRUFBekQsRUFBaEMsQ0FBYjs7ZUFDeUJELFFBQVEsY0FBUixDO0lBQXBCRSxnQixZ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a0MsYUFBVCxDQUF1QixPQUF2QixDQUFYO0FBQ0FELGVBQVN4QixTQUFULEdBQXFCVyxNQUFNcUIsSUFBM0I7QUFDQTtBQUNEUixjQUFTUyxJQUFULEdBQWdCdEIsTUFBTXNCLElBQXRCO0FBQ0FULGNBQVNVLEtBQVQsR0FBaUJ2QixNQUFNdUIsS0FBdkI7O0FBRUFqRCxlQUFVc0MsU0FBVixJQUF1QkMsUUFBdkI7QUFDQWpDLGNBQVNDLElBQVQsQ0FBYzJDLFdBQWQsQ0FBMEJYLFFBQTFCO0FBQ0EsS0E3QkQsTUE2Qk87QUFDTjdDLFlBQU9zQyxLQUFQLHlDQUFtRE0sU0FBbkQ7QUFDQTtBQUNELFdBQU9ELE1BQVA7QUFDQSxJQW5DWSxDQUFOLENBQVA7QUFvQ0EsR0F2RE0sQ0FBUDtBQXdEQSxFQWxGZTs7QUFvRmhCVCxxQkFBb0IsNEJBQVNGLEtBQVQsRUFBZ0I7QUFDbkMsU0FBT1osa0JBQWtCWSxNQUFNYixJQUF4QixLQUFpQ2EsTUFBTXFCLElBQTlDO0FBQ0E7QUF0RmUsQ0FBakI7O0FBeUZBLFNBQVNqQyxpQkFBVCxDQUEyQnFDLEdBQTNCLEVBQWdDO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUksT0FBT0EsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzVCQSxRQUFNQSxJQUNKQyxPQURJLENBQ0ksWUFESixFQUNrQixFQURsQixFQUVKQSxPQUZJLENBRUksSUFBSUMsTUFBSixDQUFXLFVBQVVDLFNBQVNDLElBQTlCLENBRkosRUFFeUMsRUFGekMsQ0FBTjtBQUdBOztBQUVELFFBQU9KLEdBQVA7QUFDQSIsImZpbGUiOiJ1dGlsL0NsaWVudENzc0hlbHBlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGxvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dpbmcnKS5nZXRMb2dnZXIoe1wibmFtZVwiOlwicmVhY3Qtc2VydmVyLmNvcmUudXRpbC5DbGllbnRDc3NIZWxwZXJcIixcImNvbG9yXCI6e1wic2VydmVyXCI6MTQ3LFwiY2xpZW50XCI6XCJyZ2IoMTI3LDEyNywyMTIpXCJ9fSk7XG52YXIge1BBR0VfQ1NTX05PREVfSUR9ID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG52YXIgUSA9IHJlcXVpcmUoJ3EnKTtcbnZhciBQYWdlVXRpbCA9IHJlcXVpcmUoJy4vUGFnZVV0aWwnKVxuXG52YXIgbG9hZGVkQ3NzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdHJlZ2lzdGVyUGFnZUxvYWQ6IGZ1bmN0aW9uIHJlZ2lzdGVyUGFnZUxvYWQoKSB7XG5cdFx0aWYgKGZhbHNlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDbGllbnRDc3NIZWxwZXIucmVnaXN0ZXJQYWdlTG9hZCBjYW4ndCBiZSBjYWxsZWQgc2VydmVyLXNpZGVcIik7XG5cdFx0fVxuXG5cdFx0Ly8gZm9yIGVhY2ggY3NzIG5vZGUgaW4gdGhlIGhlYWQgdGhhdCB0aGUgcmVhY3Qtc2VydmVyIHNlcnZlciB3cm90ZSB0byB0aGUgcmVzcG9uc2UsIG5vdGUgaXQgZG93biBpbiB0aGUgY2FjaGUsIHNvIHRoYXRcblx0XHQvLyB3ZSBjYW4gcmVtb3ZlIGl0IG9uIGEgcGFnZSB0byBwYWdlIHRyYW5zaXRpb24uXG5cdFx0dmFyIHNlcnZlcldyaXR0ZW5MaW5rTm9kZXMgPSBkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3JBbGwoYGxpbmtbJHtQQUdFX0NTU19OT0RFX0lEfV0sc3R5bGVbJHtQQUdFX0NTU19OT0RFX0lEfV1gKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNlcnZlcldyaXR0ZW5MaW5rTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXksIHN0eWxlTm9kZSA9IHNlcnZlcldyaXR0ZW5MaW5rTm9kZXNbaV07XG5cdFx0XHRpZiAoc3R5bGVOb2RlLmhyZWYpIHtcblx0XHRcdFx0a2V5ID0gbm9ybWFsaXplTG9jYWxVcmwoc3R5bGVOb2RlLmhyZWYpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gc3R5bGVOb2RlLmlubmVySFRNTDtcblx0XHRcdH1cblx0XHRcdGxvYWRlZENzc1trZXldID0gc3R5bGVOb2RlO1xuXHRcdH1cblx0fSxcblxuXHRlbnN1cmVDc3M6IGZ1bmN0aW9uIGVuc3VyZUNzcyhyb3V0ZU5hbWUsIHBhZ2VPYmplY3QpIHtcblx0XHRpZiAoZmFsc2UpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNsaWVudENzc0hlbHBlci5yZWdpc3RlclBhZ2VMb2FkIGNhbid0IGJlIGNhbGxlZCBzZXJ2ZXItc2lkZVwiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gUS5hbGwoUGFnZVV0aWwuc3RhbmRhcmRpemVTdHlsZXMocGFnZU9iamVjdC5nZXRIZWFkU3R5bGVzaGVldHMoKSkpLnRoZW4obmV3Q3NzID0+IHtcblx0XHRcdHZhciBuZXdDc3NCeUtleSA9IHt9O1xuXHRcdFx0bmV3Q3NzXG5cdFx0XHRcdC5maWx0ZXIoc3R5bGUgPT4gISFzdHlsZSlcblx0XHRcdFx0LmZvckVhY2goc3R5bGUgPT4ge25ld0Nzc0J5S2V5W3RoaXMuX2tleUZyb21TdHlsZVNoZWV0KHN0eWxlKV0gPSBzdHlsZX0pO1xuXG5cdFx0XHQvLyBmaXJzdCwgcmVtb3ZlIHRoZSB1bm5lZWRlZCBDU1MgbGluayBlbGVtZW50cy5cblx0XHRcdE9iamVjdC5rZXlzKGxvYWRlZENzcykuZm9yRWFjaChsb2FkZWRDc3NLZXkgPT4ge1xuXG5cdFx0XHRcdGlmICghbmV3Q3NzQnlLZXlbbG9hZGVkQ3NzS2V5XSkge1xuXHRcdFx0XHRcdC8vIHJlbW92ZSB0aGUgY29ycmVzcG9uZGluZyBub2RlIGZyb20gdGhlIERPTS5cblx0XHRcdFx0XHRsb2dnZXIuZGVidWcoXCJSZW1vdmluZyBzdHlsZXNoZWV0OiBcIiArIGxvYWRlZENzc0tleSk7XG5cdFx0XHRcdFx0dmFyIG5vZGUgPSBsb2FkZWRDc3NbbG9hZGVkQ3NzS2V5XTtcblx0XHRcdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG5cdFx0XHRcdFx0ZGVsZXRlIGxvYWRlZENzc1tsb2FkZWRDc3NLZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gbmV4dCBhZGQgdGhlIHN0eWxlIFVSTHMgdGhhdCB3ZXJlbid0IGFscmVhZHkgbG9hZGVkLlxuXHRcdFx0cmV0dXJuIFEuYWxsKE9iamVjdC5rZXlzKG5ld0Nzc0J5S2V5KS5tYXAobmV3Q3NzS2V5ID0+IHtcblx0XHRcdFx0dmFyIHJldHZhbDtcblx0XHRcdFx0aWYgKCFsb2FkZWRDc3NbbmV3Q3NzS2V5XSkge1xuXHRcdFx0XHRcdC8vIHRoaXMgbWVhbnMgdGhhdCB0aGUgQ1NTIGlzIG5vdCBjdXJyZW50bHkgcHJlc2VudCBpbiB0aGVcblx0XHRcdFx0XHQvLyBkb2N1bWVudCwgc28gd2UgbmVlZCB0byBhZGQgaXQuXG5cdFx0XHRcdFx0bG9nZ2VyLmRlYnVnKFwiQWRkaW5nIHN0eWxlc2hlZXQ6IFwiICsgbmV3Q3NzS2V5KTtcblxuXHRcdFx0XHRcdHZhciBzdHlsZSA9IG5ld0Nzc0J5S2V5W25ld0Nzc0tleV07XG5cdFx0XHRcdFx0dmFyIHN0eWxlVGFnO1xuXG5cdFx0XHRcdFx0aWYgKHN0eWxlLmhyZWYpIHtcblx0XHRcdFx0XHRcdHN0eWxlVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuXHRcdFx0XHRcdFx0c3R5bGVUYWcucmVsID0gJ3N0eWxlc2hlZXQnO1xuXHRcdFx0XHRcdFx0c3R5bGVUYWcuaHJlZiA9IHN0eWxlLmhyZWY7XG5cblx0XHRcdFx0XHRcdC8vIElmIHdlIF9jYW5fIHdhaXQgZm9yIHRoZSBDU1MgdG8gYmUgbG9hZGVkIGJlZm9yZVxuXHRcdFx0XHRcdFx0Ly8gcHJvY2VlZGluZywgbGV0J3MgZG8gc28uXG5cdFx0XHRcdFx0XHRpZiAoJ29ubG9hZCcgaW4gc3R5bGVUYWcpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRmZCA9IFEuZGVmZXIoKTtcblx0XHRcdFx0XHRcdFx0c3R5bGVUYWcub25sb2FkID0gZGZkLnJlc29sdmU7XG5cdFx0XHRcdFx0XHRcdHJldHZhbCA9IGRmZC5wcm9taXNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdFx0XHRcdFx0XHRzdHlsZVRhZy5pbm5lckhUTUwgPSBzdHlsZS50ZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdHlsZVRhZy50eXBlID0gc3R5bGUudHlwZTtcblx0XHRcdFx0XHRzdHlsZVRhZy5tZWRpYSA9IHN0eWxlLm1lZGlhO1xuXG5cdFx0XHRcdFx0bG9hZGVkQ3NzW25ld0Nzc0tleV0gPSBzdHlsZVRhZztcblx0XHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsb2dnZXIuZGVidWcoYFN0eWxlc2hlZXQgYWxyZWFkeSBsb2FkZWQgKG5vLW9wKTogJHtuZXdDc3NLZXl9YCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJldHZhbDtcblx0XHRcdH0pKTtcblx0XHR9KTtcblx0fSxcblxuXHRfa2V5RnJvbVN0eWxlU2hlZXQ6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0cmV0dXJuIG5vcm1hbGl6ZUxvY2FsVXJsKHN0eWxlLmhyZWYpIHx8IHN0eWxlLnRleHQ7XG5cdH0sXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsVXJsKHVybCkge1xuXHQvLyBTdGVwIDE6IG1ha2UgdGhlIHVybCBwcm90b2NvbCBsZXNzIGZpcnN0LiAgVGhpcyBoZWxwcyByZWNvZ25pemluZyBodHRwOi8vMC4wLjAuMDozMDAxL2NvbW1vbi5jc3Ncblx0Ly8gYW5kIC8vMC4wLjAuMDozMDAxL2NvbW1vbi5jc3MgYXMgdGhlIHNhbWUgZmlsZS5cblx0Ly8gU3RlcCAyOiBUaGUgYnJvd3NlciB3aWxsIGdpdmUgdXMgYSBmdWxsIFVSTCBldmVuIGlmIHdlIG9ubHkgcHV0IGFcblx0Ly8gcGF0aCBpbiBvbiB0aGUgc2VydmVyLiAgU28sIGlmIHdlJ3JlIGNvbXBhcmluZyBhZ2FpbnN0IGp1c3Rcblx0Ly8gYSBwYXRoIGhlcmUgd2UgbmVlZCB0byBzdHJpcCB0aGUgYmFzZSBvZmYgdG8gYXZvaWQgYSBmbGFzaFxuXHQvLyBvZiB1bnN0eWxlZCBjb250ZW50LlxuXHRpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcblx0XHR1cmwgPSB1cmxcblx0XHRcdC5yZXBsYWNlKC9eaHR0cFtzXT86LywgJycpXG5cdFx0XHQucmVwbGFjZShuZXcgUmVnRXhwKFwiXlxcL1xcL1wiICsgbG9jYXRpb24uaG9zdCksICcnKTtcblx0fVxuXG5cdHJldHVybiB1cmw7XG59XG4iXX0=
