"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var Q = require("q"),
    React = require('react'),
    logger = require("../logging").getLogger({ "name": "react-server.core.util.PageUtil", "color": { "server": 143, "client": "rgb(127,127,42)" } }),
    RLS = require("./RequestLocalStorage").getNamespace();

var _require = require('../components/RootContainer'),
    isRootContainer = _require.isRootContainer,
    flattenForRender = _require.flattenForRender;

var _require2 = require('../components/RootElement'),
    ensureRootElement = _require2.ensureRootElement,
    scheduleRender = _require2.scheduleRender;

var _require3 = require('../components/TheFold'),
    isTheFold = _require3.isTheFold,
    markTheFold = _require3.markTheFold;

var PageConfig = function () {
	var logger = require("../logging").getLogger({ "label": "PageConfig", "name": "react-server.core.util.PageUtil.PageConfig", "color": { "server": 147, "client": "rgb(127,127,212)" } });

	// Below here are helpers. They are hidden from outside callers.
	var _getCurrentConfigObject = function _getCurrentConfigObject() {

		// Return the current mutable config.
		return RLS().pageConfig || (RLS().pageConfig = {});
	};

	var _set = function _set(isDefault, obj) {
		var config = _getCurrentConfigObject();

		// Copy input values into it.
		Object.keys(obj || {}).forEach(function (key) {
			var keyExists = config.hasOwnProperty(key);
			if (isDefault && keyExists) {
				// Can't make this fatal, because request
				// forwarding uses a dirty RLS() context.
				logger.warning("Duplicate PageConfig default: \"" + key + "\"");
			} else if (!isDefault && !keyExists) {
				throw new Error("Missing PageConfig default: \"" + key + "\"");
			}

			logger.debug((isDefault ? "Default" : "Set") + " \"" + key + "\" => \"" + obj[key] + "\"");

			config[key] = obj[key];
		});
	};

	var _setDefaults = _set.bind({}, true);
	var _setValues = _set.bind({}, false);

	// This gets bound to the outer `PageConfig`.
	//
	// Only `PageConfig.get(key)` is generally useful.
	//
	var PageConfig = {
		get: function get(key) {

			// No access until all `Page.addConfigValues()` and
			// `Page.setConfigValues()` methods are complete.
			if (!RLS().pageConfigFinalized) {
				throw new Error("Premature access: \"" + key + "\"");
			}

			// The key _must_ exist.
			if (!_getCurrentConfigObject().hasOwnProperty(key)) {
				throw new Error("Invalid key: \"" + key + "\"");
			}

			return _getCurrentConfigObject()[key];
		},


		// Don't call this.  It's called for you.
		// The `page` here is a page chain.
		// It's called `page` in `Navigator` and `renderMiddleware`.
		initFromPageWithDefaults: function initFromPageWithDefaults(page, defaults) {

			// First set the framework level defaults.
			_setDefaults(defaults);

			// Then let page/middleware define new config defaults,
			// and finally let page/middleware alter existing
			// config values.
			page.addConfigValues().forEach(_setDefaults);
			page.setConfigValues().forEach(_setValues);

			logger.debug('Final', _getCurrentConfigObject());

			RLS().pageConfigFinalized = true;
		}
	};

	return PageConfig;
}();

// There are three data structures defined here that are relevant for page and
// middleware authors:
//
//   - PAGE_MIXIN   : Methods that will be automatically defined on your class.
//   - PAGE_METHODS : Chained methods that may be overridden in your class.
//   - PAGE_HOOKS   : Non-chained methods that may be defined in your class.
//
// These three data structure define the page interface.

// These methods will be available on your page/middleware object.
//
// Accidental definition of a method with a conflicting name directly on your
// class will generate an error.
//
var PAGE_MIXIN = {
	getExpressRequest: makeGetter('expressRequest'), // Only available with `isRawResponse`.
	getExpressResponse: makeGetter('expressResponse'), // Only available with `isRawResponse`.
	getRequest: makeGetter('request'),
	getConfig: function getConfig(key) {
		return PageConfig.get(key);
	}
};

// Each item here represents a method that page/middleware objects may override.
//
// The keys here are method names.
//
// The values are tuples containing:
//   - Default implementation of the method.
//   - Normalization function applied to method output.
//
// Note that each of these methods receives an argument, which is the next
// implementation of the method in the call chain.
//     - Middleware implementations _should_ call this in most cases.*
//     - Page implementations _may_ call this (it will be the default implementation).
//
// * Consider carefully before deciding not to call `next()` in middleware.
// Other middleware (and the page itself) may exhibit undefined behavior if a
// given method is not called.  Generally, only skip calling `next()` for
// short-circuit responses (e.g. a redirect from `handleRoute`).
//
var PAGE_METHODS = {
	handleRoute: [function () {
		return { code: 200 };
	}, Q],
	getContentType: [function () {
		return "text/html; charset=utf-8";
	}, function (_) {
		return _;
	}],
	getHeaders: [function () {
		return [];
	}, Q],
	getTitle: [function () {
		return "";
	}, Q],
	getScripts: [function () {
		return [];
	}, standardizeScripts],
	getSystemScripts: [function () {
		return [];
	}, standardizeScripts],
	getBodyStartContent: [function () {
		return [];
	}, Q],
	getHeadStylesheets: [function () {
		return [];
	}, standardizeStyles],
	getDebugComments: [function () {
		return [];
	}, standardizeDebugComments],
	getMetaTags: [function () {
		return [];
	}, standardizeMetaTags],
	getLinkTags: [function () {
		return [];
	}, standardizeLinkTags],
	getBase: [function () {
		return null;
	}, Q],
	getBodyClasses: [function () {
		return [];
	}, Q],
	getElements: [function () {
		return [];
	}, standardizeElements],
	getResponseData: [function () {
		return "";
	}, Q]
};

// These are similar to `PAGE_METHODS`, but differ as follows:
//
//   - They are not chained.
//   - They do not have default implementations.
//
// Each page and middleware that implements a page hook will have its hook
// called in turn.  Hooks do not receive a `next()` method, and are not
// responsible for merging return values.
//
// The keys here are method names.
//
// The values are empty placeholder tuples.
//
var PAGE_HOOKS = {
	addConfigValues: [], // Define new configuration values.
	setConfigValues: [], // Alter existing configuration values.
	handleComplete: [] // Do stuff after the response has been sent.
};

// These methods are only defined on the page _chain_ which is used internally
// within react-server.  Page/middleware authers can ignore this.
var PAGE_CHAIN_PROTOTYPE = {
	setExpressRequest: makeSetter('expressRequest'),
	setExpressResponse: makeSetter('expressResponse'),
	setRequest: makeSetter('request'),
	getRequest: makeGetter('request'),

	// TODO: Kill these?  They're only used to patch values
	// through from navigator to renderMiddleware within react-server itself.
	// They don't need to be exposed publicly.
	//
	// The way to set a response code for your page is to return it from
	// `handleRoute()` as e.g. `{code: 200}`.
	//
	// The way to opt-in to rendering a document for a non-2xx response
	// code is to include `hasDocument: true` in your `handleRoute()`
	// response object.
	//
	getStatus: makeGetter('status'),
	setStatus: makeSetter('status'),
	getHasDocument: makeGetter('hasDocument'),
	setHasDocument: makeSetter('hasDocument'),
	getJsBelowTheFold: makeGetter('jsBelowTheFold'),
	setJsBelowTheFold: makeSetter('jsBelowTheFold'),
	getSplitJsLoad: makeGetter('splitJsLoad'),
	setSplitJsLoad: makeSetter('splitJsLoad')
};

// We log all method calls on the page chain for debugging purposes.
Object.keys(PAGE_CHAIN_PROTOTYPE).forEach(function (method) {
	PAGE_CHAIN_PROTOTYPE[method] = logInvocation(method, PAGE_CHAIN_PROTOTYPE[method]);
});

// These are helpers for `PAGE_MIXIN` and `PAGE_CHAIN_PROTOTYPE` methods.
//
// Note that getters and setters don't actually modify the page/middleware
// object directly, but rather stash values in request local storage.  Values
// are therefore shared between the page and all middleware.
//
function makeGetter(key) {
	return function () {
		return (RLS().mixinValues || {})[key];
	};
}

function makeSetter(key) {
	return function (val) {
		(RLS().mixinValues || (RLS().mixinValues = {}))[key] = val;
	};
}

// This attaches `PAGE_MIXIN` methods to page/middleware classes.
//
// It does this only _once_, and thereafter short-circuits.
//
function lazyMixinPageUtilMethods(page) {
	var proto = Object.getPrototypeOf(page);
	if (proto._haveMixedInPageUtilMethods) return;

	proto._haveMixedInPageUtilMethods = true;

	Object.keys(PAGE_MIXIN).forEach(function (method) {
		if (proto[method]) {
			throw new Error("PAGE_MIXINS method override: " + (proto.constructor || {}).name + "." + method);
		}
		proto[method] = PAGE_MIXIN[method];
	});
}

// These `standardize*` functions show what will happen to the output of your
// page methods.
//
// For middleware authors: Be aware that these standardization functions will
// have been applied to the output of `next()` before you get access to it.
//
// These functions are also exposed via `PageUtil.standardize*`.

/**
 * This method takes in anything returned from a Page.getElements call and
 * returns the elements in a standardized format: an array of EarlyPromises of
 * ReactElements.
 */
function standardizeElements(elements) {

	// The return value could be a single element or an array.
	// First, let's make sure that it's an array.
	// Then, ensure that all elements are wrapped in promises.
	return makeArray(elements).map(function (e) {
		return isRootContainer(e) ? flattenForRender(e) : e;
	}).reduce(function (m, e) {
		return m.concat(Array.isArray(e) ? e : [e]);
	}, []).map(function (e) {
		return isTheFold(e) ? markTheFold() : e;
	}).map(ensureRootElement).map(scheduleRender);
}

function standardizeDebugComments(debugComments) {
	return makeArray(debugComments);
}

function standardizeMetaTags(metaTags) {
	return makeArray(metaTags).map(function (metaTag) {
		return Q(metaTag);
	});
}

function standardizeLinkTags(linkTags) {
	return makeArray(linkTags).map(function (linkTag) {
		return Q(linkTag);
	});
}

function standardizeScripts(scripts) {
	return makeArray(scripts).map(function (script) {
		if (!(script.href || script.text)) {
			script = { href: script };
		}

		if (!script.type) script.type = "text/javascript";

		// Default is strict mode unless otherwise specified.
		if (!script.hasOwnProperty('strict')) script.strict = true;

		// if the answer was a string, let's make a script object
		return script;
	});
}

function standardizeStyles(styles) {
	return makeArray(styles).map(function (styleOrP) {
		return Q(styleOrP).then(function (style) {
			if (!style) {
				return null;
			}
			if (style.href || style.text) {
				if (!style.type) style.type = "text/css";
				if (!style.media) style.media = "";

				return style;
			}

			// if the answer was a string, let's make a script object
			return { href: style, type: "text/css", media: "" };
		});
	});
}

// This is used to log method calls on the page _chain_.  Method calls on
// individual page/middleware objects are not automatically logged.
function logInvocation(name, func) {
	return function () {
		logger.debug("Call " + name);
		return func.apply(this, [].slice.call(arguments));
	};
}

// Return `fn` with a wrapper that puts its return value through `standardize`
// on the way out.
function makeStandard(standardize, fn) {
	return function () {
		return standardize(fn.apply(null, [].slice.call(arguments)));
	};
}

function makeArray(valueOrArray) {
	if (!Array.isArray(valueOrArray)) {
		return [valueOrArray];
	}
	return valueOrArray;
}

var PageUtil = {
	PAGE_METHODS: PAGE_METHODS,

	standardizeElements: standardizeElements,
	standardizeMetaTags: standardizeMetaTags,
	standardizeScripts: standardizeScripts,
	standardizeStyles: standardizeStyles,

	PageConfig: PageConfig,

	// Given an array of page/middleware instances, return an object that
	// implements the interface defined by the union of:
	//
	//   - PAGE_CHAIN_PROTOTYPE
	//   - PAGE_METHODS
	//   - PAGE_HOOKS
	//
	createPageChain: function createPageChain(pages) {
		/* eslint-disable no-loop-func */

		// This will be our return value.
		//
		// This `Object.create()` call creates a new empty object
		// (`{}`) with `PAGE_CHAIN_PROTOTYPE` as its prototype.
		//
		var pageChain = Object.create(PAGE_CHAIN_PROTOTYPE);

		// Make sure all page classes have been augmented with the
		// methods provided by `PAGE_MIXIN`.
		pages.forEach(lazyMixinPageUtilMethods);

		// Wire up the chained methods.
		for (var method in PAGE_METHODS) {

			if (!PAGE_METHODS.hasOwnProperty(method)) continue;

			var _PAGE_METHODS$method = _slicedToArray(PAGE_METHODS[method], 2),
			    defaultImpl = _PAGE_METHODS$method[0],
			    standardize = _PAGE_METHODS$method[1];

			// Take bound methods for each page/middleware that
			// implements (plus the default implementation), and
			// chain them together so that each receives as an
			// argument the rest of the chain in the form of an
			// arity-zero function.
			//
			// The `next` argument in the reduction here is the
			// accumulated chain.  It is what each implementation
			// will receive as _its_ `next` argument.
			//


			pageChain[method] = logInvocation(method, pages.filter(function (page) {
				return page[method];
			}).map(function (page) {
				return page[method].bind(page);
			}).concat([defaultImpl]).map(makeStandard.bind(null, standardize)).reduceRight(function (next, cur) {
				return cur.bind(null, next);
			}));
		}

		// Wire up the un-chained methods.
		Object.keys(PAGE_HOOKS).forEach(function (method) {

			// Grab a list of pages that implement this method.
			var implementors = pages.filter(function (page) {
				return page[method];
			});

			// The resulting function calls each implementor's
			// method in turn and returns an array containing in
			// their return values.
			pageChain[method] = logInvocation(method, function () {

				// The `arguments` object isn't a real array.
				// Pre-es5 `Function.apply()` required a real
				// array.  This `[].slice.call(arguments)`
				// idiom creates a real array with the elements
				// of the `arguments` object.
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
				//
				var args = [].slice.call(arguments);

				return implementors.map(function (page) {
					return page[method].apply(page, args);
				});
			});
		});

		return pageChain;
		/* eslint-enable no-loop-func */
	},


	makeArray: makeArray,

	getElementDisplayName: function getElementDisplayName(element) {

		// Gotta be a react element.
		if (!(element && element.type && element.props)) return 'None';

		var name = element.type.displayName;

		if (!name) {

			// If the element doesn't have a `displayName`, but it
			// has only a single child, we'll look at the child to
			// see if it has a nice name.  This helps bypass
			// anonymous wrapper elements.
			if (React.Children.count(element.props.children) === 1) {

				// Sigh.  `React.Children.count` will happily
				// return 1 if the node contains only text, and
				// then `React.Children.only` will happily
				// _blow up_ if it receives that text saying it
				// expects a single child... which
				// `React.Children.count` just told us we
				// have... :goberzerk:
				try {
					name = PageUtil.getElementDisplayName(React.Children.only(element.props.children));
				} catch (e) {/* Pass. */}
			}
		}

		// Some of our names are namespaced with dot-separation.  We
		// just want the most significant part at the end.
		return (name || 'Unknown').split('.').pop();
	}
};

module.exports = PageUtil;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInV0aWwvUGFnZVV0aWwuanMiXSwibmFtZXMiOlsiUSIsInJlcXVpcmUiLCJSZWFjdCIsImxvZ2dlciIsImdldExvZ2dlciIsIlJMUyIsImdldE5hbWVzcGFjZSIsImlzUm9vdENvbnRhaW5lciIsImZsYXR0ZW5Gb3JSZW5kZXIiLCJlbnN1cmVSb290RWxlbWVudCIsInNjaGVkdWxlUmVuZGVyIiwiaXNUaGVGb2xkIiwibWFya1RoZUZvbGQiLCJQYWdlQ29uZmlnIiwiX2dldEN1cnJlbnRDb25maWdPYmplY3QiLCJwYWdlQ29uZmlnIiwiX3NldCIsImlzRGVmYXVsdCIsIm9iaiIsImNvbmZpZyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5RXhpc3RzIiwiaGFzT3duUHJvcGVydHkiLCJrZXkiLCJ3YXJuaW5nIiwiRXJyb3IiLCJkZWJ1ZyIsIl9zZXREZWZhdWx0cyIsImJpbmQiLCJfc2V0VmFsdWVzIiwiZ2V0IiwicGFnZUNvbmZpZ0ZpbmFsaXplZCIsImluaXRGcm9tUGFnZVdpdGhEZWZhdWx0cyIsInBhZ2UiLCJkZWZhdWx0cyIsImFkZENvbmZpZ1ZhbHVlcyIsInNldENvbmZpZ1ZhbHVlcyIsIlBBR0VfTUlYSU4iLCJnZXRFeHByZXNzUmVxdWVzdCIsIm1ha2VHZXR0ZXIiLCJnZXRFeHByZXNzUmVzcG9uc2UiLCJnZXRSZXF1ZXN0IiwiZ2V0Q29uZmlnIiwiUEFHRV9NRVRIT0RTIiwiaGFuZGxlUm91dGUiLCJjb2RlIiwiZ2V0Q29udGVudFR5cGUiLCJfIiwiZ2V0SGVhZGVycyIsImdldFRpdGxlIiwiZ2V0U2NyaXB0cyIsInN0YW5kYXJkaXplU2NyaXB0cyIsImdldFN5c3RlbVNjcmlwdHMiLCJnZXRCb2R5U3RhcnRDb250ZW50IiwiZ2V0SGVhZFN0eWxlc2hlZXRzIiwic3RhbmRhcmRpemVTdHlsZXMiLCJnZXREZWJ1Z0NvbW1lbnRzIiwic3RhbmRhcmRpemVEZWJ1Z0NvbW1lbnRzIiwiZ2V0TWV0YVRhZ3MiLCJzdGFuZGFyZGl6ZU1ldGFUYWdzIiwiZ2V0TGlua1RhZ3MiLCJzdGFuZGFyZGl6ZUxpbmtUYWdzIiwiZ2V0QmFzZSIsImdldEJvZHlDbGFzc2VzIiwiZ2V0RWxlbWVudHMiLCJzdGFuZGFyZGl6ZUVsZW1lbnRzIiwiZ2V0UmVzcG9uc2VEYXRhIiwiUEFHRV9IT09LUyIsImhhbmRsZUNvbXBsZXRlIiwiUEFHRV9DSEFJTl9QUk9UT1RZUEUiLCJzZXRFeHByZXNzUmVxdWVzdCIsIm1ha2VTZXR0ZXIiLCJzZXRFeHByZXNzUmVzcG9uc2UiLCJzZXRSZXF1ZXN0IiwiZ2V0U3RhdHVzIiwic2V0U3RhdHVzIiwiZ2V0SGFzRG9jdW1lbnQiLCJzZXRIYXNEb2N1bWVudCIsImdldEpzQmVsb3dUaGVGb2xkIiwic2V0SnNCZWxvd1RoZUZvbGQiLCJnZXRTcGxpdEpzTG9hZCIsInNldFNwbGl0SnNMb2FkIiwibWV0aG9kIiwibG9nSW52b2NhdGlvbiIsIm1peGluVmFsdWVzIiwidmFsIiwibGF6eU1peGluUGFnZVV0aWxNZXRob2RzIiwicHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIl9oYXZlTWl4ZWRJblBhZ2VVdGlsTWV0aG9kcyIsImNvbnN0cnVjdG9yIiwibmFtZSIsImVsZW1lbnRzIiwibWFrZUFycmF5IiwibWFwIiwiZSIsInJlZHVjZSIsIm0iLCJjb25jYXQiLCJBcnJheSIsImlzQXJyYXkiLCJkZWJ1Z0NvbW1lbnRzIiwibWV0YVRhZ3MiLCJtZXRhVGFnIiwibGlua1RhZ3MiLCJsaW5rVGFnIiwic2NyaXB0cyIsInNjcmlwdCIsImhyZWYiLCJ0ZXh0IiwidHlwZSIsInN0cmljdCIsInN0eWxlcyIsInN0eWxlT3JQIiwidGhlbiIsInN0eWxlIiwibWVkaWEiLCJmdW5jIiwiYXBwbHkiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJtYWtlU3RhbmRhcmQiLCJzdGFuZGFyZGl6ZSIsImZuIiwidmFsdWVPckFycmF5IiwiUGFnZVV0aWwiLCJjcmVhdGVQYWdlQ2hhaW4iLCJwYWdlcyIsInBhZ2VDaGFpbiIsImNyZWF0ZSIsImRlZmF1bHRJbXBsIiwiZmlsdGVyIiwicmVkdWNlUmlnaHQiLCJuZXh0IiwiY3VyIiwiaW1wbGVtZW50b3JzIiwiYXJncyIsImdldEVsZW1lbnREaXNwbGF5TmFtZSIsImVsZW1lbnQiLCJwcm9wcyIsImRpc3BsYXlOYW1lIiwiQ2hpbGRyZW4iLCJjb3VudCIsImNoaWxkcmVuIiwib25seSIsInNwbGl0IiwicG9wIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLElBQUlBLElBQUlDLFFBQVEsR0FBUixDQUFSO0FBQUEsSUFDQ0MsUUFBUUQsUUFBUSxPQUFSLENBRFQ7QUFBQSxJQUVDRSxTQUFTRixRQUFRLFlBQVIsRUFBc0JHLFNBQXRCLENBQWdDLEVBQUMsUUFBTyxpQ0FBUixFQUEwQyxTQUFRLEVBQUMsVUFBUyxHQUFWLEVBQWMsVUFBUyxpQkFBdkIsRUFBbEQsRUFBaEMsQ0FGVjtBQUFBLElBR0NDLE1BQU1KLFFBQVEsdUJBQVIsRUFBaUNLLFlBQWpDLEVBSFA7O2VBSzBDTCxRQUFRLDZCQUFSLEM7SUFBckNNLGUsWUFBQUEsZTtJQUFpQkMsZ0IsWUFBQUEsZ0I7O2dCQUNvQlAsUUFBUSwyQkFBUixDO0lBQXJDUSxpQixhQUFBQSxpQjtJQUFtQkMsYyxhQUFBQSxjOztnQkFDT1QsUUFBUSx1QkFBUixDO0lBQTFCVSxTLGFBQUFBLFM7SUFBV0MsVyxhQUFBQSxXOztBQUdoQixJQUFJQyxhQUFjLFlBQVU7QUFDM0IsS0FBSVYsU0FBU0YsUUFBUSxZQUFSLEVBQXNCRyxTQUF0QixDQUFnQyxFQUFDLFNBQVEsWUFBVCxFQUFzQixRQUFPLDRDQUE3QixFQUEwRSxTQUFRLEVBQUMsVUFBUyxHQUFWLEVBQWMsVUFBUyxrQkFBdkIsRUFBbEYsRUFBaEMsQ0FBYjs7QUFFQztBQUNELEtBQUlVLDBCQUEwQixTQUExQkEsdUJBQTBCLEdBQVU7O0FBRXZDO0FBQ0EsU0FBT1QsTUFBTVUsVUFBTixLQUFxQlYsTUFBTVUsVUFBTixHQUFtQixFQUF4QyxDQUFQO0FBQ0EsRUFKRDs7QUFNQSxLQUFJ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LHFCQUFULENBQ04xSSxNQUFNOEksUUFBTixDQUFlRyxJQUFmLENBQ0NOLFFBQVFDLEtBQVIsQ0FBY0ksUUFEZixDQURNLENBQVA7QUFLQSxLQU5ELENBTUUsT0FBT2pELENBQVAsRUFBVSxDQUFFLFdBQWE7QUFDM0I7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsU0FBTyxDQUFDSixRQUFNLFNBQVAsRUFBa0J1RCxLQUFsQixDQUF3QixHQUF4QixFQUE2QkMsR0FBN0IsRUFBUDtBQUNBO0FBN0hhLENBQWY7O0FBaUlBQyxPQUFPQyxPQUFQLEdBQWlCdkIsUUFBakIiLCJmaWxlIjoidXRpbC9QYWdlVXRpbC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBRID0gcmVxdWlyZShcInFcIiksXG5cdFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKSxcblx0bG9nZ2VyID0gcmVxdWlyZShcIi4uL2xvZ2dpbmdcIikuZ2V0TG9nZ2VyKHtcIm5hbWVcIjpcInJlYWN0LXNlcnZlci5jb3JlLnV0aWwuUGFnZVV0aWxcIixcImNvbG9yXCI6e1wic2VydmVyXCI6MTQzLFwiY2xpZW50XCI6XCJyZ2IoMTI3LDEyNyw0MilcIn19KSxcblx0UkxTID0gcmVxdWlyZShcIi4vUmVxdWVzdExvY2FsU3RvcmFnZVwiKS5nZXROYW1lc3BhY2UoKTtcblxudmFyIHtpc1Jvb3RDb250YWluZXIsIGZsYXR0ZW5Gb3JSZW5kZXJ9ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9Sb290Q29udGFpbmVyJyk7XG52YXIge2Vuc3VyZVJvb3RFbGVtZW50LCBzY2hlZHVsZVJlbmRlcn0gPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL1Jvb3RFbGVtZW50Jyk7XG52YXIge2lzVGhlRm9sZCwgbWFya1RoZUZvbGR9ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9UaGVGb2xkJyk7XG5cblxudmFyIFBhZ2VDb25maWcgPSAoZnVuY3Rpb24oKXtcblx0dmFyIGxvZ2dlciA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nXCIpLmdldExvZ2dlcih7XCJsYWJlbFwiOlwiUGFnZUNvbmZpZ1wiLFwibmFtZVwiOlwicmVhY3Qtc2VydmVyLmNvcmUudXRpbC5QYWdlVXRpbC5QYWdlQ29uZmlnXCIsXCJjb2xvclwiOntcInNlcnZlclwiOjE0NyxcImNsaWVudFwiOlwicmdiKDEyNywxMjcsMjEyKVwifX0pO1xuXG4gIC8vIEJlbG93IGhlcmUgYXJlIGhlbHBlcnMuIFRoZXkgYXJlIGhpZGRlbiBmcm9tIG91dHNpZGUgY2FsbGVycy5cblx0dmFyIF9nZXRDdXJyZW50Q29uZmlnT2JqZWN0ID0gZnVuY3Rpb24oKXtcblxuXHRcdC8vIFJldHVybiB0aGUgY3VycmVudCBtdXRhYmxlIGNvbmZpZy5cblx0XHRyZXR1cm4gUkxTKCkucGFnZUNvbmZpZyB8fCAoUkxTKCkucGFnZUNvbmZpZyA9IHt9KTtcblx0fVxuXG5cdHZhciBfc2V0ID0gZnVuY3Rpb24oaXNEZWZhdWx0LCBvYmopIHtcblx0XHR2YXIgY29uZmlnID0gX2dldEN1cnJlbnRDb25maWdPYmplY3QoKTtcblxuXHRcdC8vIENvcHkgaW5wdXQgdmFsdWVzIGludG8gaXQuXG5cdFx0T2JqZWN0LmtleXMob2JqfHx7fSkuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0dmFyIGtleUV4aXN0cyA9IGNvbmZpZy5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuXHRcdFx0aWYgKGlzRGVmYXVsdCAmJiBrZXlFeGlzdHMpe1xuXHRcdFx0XHQvLyBDYW4ndCBtYWtlIHRoaXMgZmF0YWwsIGJlY2F1c2UgcmVxdWVzdFxuXHRcdFx0XHQvLyBmb3J3YXJkaW5nIHVzZXMgYSBkaXJ0eSBSTFMoKSBjb250ZXh0LlxuXHRcdFx0XHRsb2dnZXIud2FybmluZyhgRHVwbGljYXRlIFBhZ2VDb25maWcgZGVmYXVsdDogXCIke2tleX1cImApO1xuXHRcdFx0fSBlbHNlIGlmICghaXNEZWZhdWx0ICYmICFrZXlFeGlzdHMpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIFBhZ2VDb25maWcgZGVmYXVsdDogXCIke2tleX1cImApO1xuXHRcdFx0fVxuXG5cdFx0XHRsb2dnZXIuZGVidWcoYCR7aXNEZWZhdWx0P1wiRGVmYXVsdFwiOlwiU2V0XCJ9IFwiJHtrZXl9XCIgPT4gXCIke29ialtrZXldfVwiYCk7XG5cblx0XHRcdGNvbmZpZ1trZXldID0gb2JqW2tleV07XG5cdFx0fSk7XG5cdH07XG5cblx0dmFyIF9zZXREZWZhdWx0cyA9IF9zZXQuYmluZCh7fSwgdHJ1ZSk7XG5cdHZhciBfc2V0VmFsdWVzICAgPSBfc2V0LmJpbmQoe30sIGZhbHNlKTtcblxuXHQvLyBUaGlzIGdldHMgYm91bmQgdG8gdGhlIG91dGVyIGBQYWdlQ29uZmlnYC5cblx0Ly9cblx0Ly8gT25seSBgUGFnZUNvbmZpZy5nZXQoa2V5KWAgaXMgZ2VuZXJhbGx5IHVzZWZ1bC5cblx0Ly9cblx0dmFyIFBhZ2VDb25maWcgPSB7XG5cblx0XHRnZXQoa2V5KSB7XG5cblx0XHRcdC8vIE5vIGFjY2VzcyB1bnRpbCBhbGwgYFBhZ2UuYWRkQ29uZmlnVmFsdWVzKClgIGFuZFxuXHRcdFx0Ly8gYFBhZ2Uuc2V0Q29uZmlnVmFsdWVzKClgIG1ldGhvZHMgYXJlIGNvbXBsZXRlLlxuXHRcdFx0aWYgKCFSTFMoKS5wYWdlQ29uZmlnRmluYWxpemVkKXtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBQcmVtYXR1cmUgYWNjZXNzOiBcIiR7a2V5fVwiYCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBrZXkgX211c3RfIGV4aXN0LlxuXHRcdFx0aWYgKCFfZ2V0Q3VycmVudENvbmZpZ09iamVjdCgpLmhhc093blByb3BlcnR5KGtleSkpe1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQga2V5OiBcIiR7a2V5fVwiYCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBfZ2V0Q3VycmVudENvbmZpZ09iamVjdCgpW2tleV07XG5cdFx0fSxcblxuXG5cdFx0Ly8gRG9uJ3QgY2FsbCB0aGlzLiAgSXQncyBjYWxsZWQgZm9yIHlvdS5cblx0XHQvLyBUaGUgYHBhZ2VgIGhlcmUgaXMgYSBwYWdlIGNoYWluLlxuXHRcdC8vIEl0J3MgY2FsbGVkIGBwYWdlYCBpbiBgTmF2aWdhdG9yYCBhbmQgYHJlbmRlck1pZGRsZXdhcmVgLlxuXHRcdGluaXRGcm9tUGFnZVdpdGhEZWZhdWx0cyhwYWdlLCBkZWZhdWx0cykge1xuXG5cdFx0XHQvLyBGaXJzdCBzZXQgdGhlIGZyYW1ld29yayBsZXZlbCBkZWZhdWx0cy5cblx0XHRcdF9zZXREZWZhdWx0cyhkZWZhdWx0cyk7XG5cblx0XHRcdC8vIFRoZW4gbGV0IHBhZ2UvbWlkZGxld2FyZSBkZWZpbmUgbmV3IGNvbmZpZyBkZWZhdWx0cyxcblx0XHRcdC8vIGFuZCBmaW5hbGx5IGxldCBwYWdlL21pZGRsZXdhcmUgYWx0ZXIgZXhpc3Rpbmdcblx0XHRcdC8vIGNvbmZpZyB2YWx1ZXMuXG5cdFx0XHRwYWdlLmFkZENvbmZpZ1ZhbHVlcygpLmZvckVhY2goX3NldERlZmF1bHRzKTtcblx0XHRcdHBhZ2Uuc2V0Q29uZmlnVmFsdWVzKCkuZm9yRWFjaChfc2V0VmFsdWVzKTtcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdGaW5hbCcsIF9nZXRDdXJyZW50Q29uZmlnT2JqZWN0KCkpO1xuXG5cdFx0XHRSTFMoKS5wYWdlQ29uZmlnRmluYWxpemVkID0gdHJ1ZTtcblx0XHR9LFxuXHR9XG5cblx0cmV0dXJuIFBhZ2VDb25maWc7XG59KSgpO1xuXG5cbi8vIFRoZXJlIGFyZSB0aHJlZSBkYXRhIHN0cnVjdHVyZXMgZGVmaW5lZCBoZXJlIHRoYXQgYXJlIHJlbGV2YW50IGZvciBwYWdlIGFuZFxuLy8gbWlkZGxld2FyZSBhdXRob3JzOlxuLy9cbi8vICAgLSBQQUdFX01JWElOICAgOiBNZXRob2RzIHRoYXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGRlZmluZWQgb24geW91ciBjbGFzcy5cbi8vICAgLSBQQUdFX01FVEhPRFMgOiBDaGFpbmVkIG1ldGhvZHMgdGhhdCBtYXkgYmUgb3ZlcnJpZGRlbiBpbiB5b3VyIGNsYXNzLlxuLy8gICAtIFBBR0VfSE9PS1MgICA6IE5vbi1jaGFpbmVkIG1ldGhvZHMgdGhhdCBtYXkgYmUgZGVmaW5lZCBpbiB5b3VyIGNsYXNzLlxuLy9cbi8vIFRoZXNlIHRocmVlIGRhdGEgc3RydWN0dXJlIGRlZmluZSB0aGUgcGFnZSBpbnRlcmZhY2UuXG5cbi8vIFRoZXNlIG1ldGhvZHMgd2lsbCBiZSBhdmFpbGFibGUgb24geW91ciBwYWdlL21pZGRsZXdhcmUgb2JqZWN0LlxuLy9cbi8vIEFjY2lkZW50YWwgZGVmaW5pdGlvbiBvZiBhIG1ldGhvZCB3aXRoIGEgY29uZmxpY3RpbmcgbmFtZSBkaXJlY3RseSBvbiB5b3VyXG4vLyBjbGFzcyB3aWxsIGdlbmVyYXRlIGFuIGVycm9yLlxuLy9cbnZhciBQQUdFX01JWElOID0ge1xuXHRnZXRFeHByZXNzUmVxdWVzdCAgOiBtYWtlR2V0dGVyKCdleHByZXNzUmVxdWVzdCcpLCAgLy8gT25seSBhdmFpbGFibGUgd2l0aCBgaXNSYXdSZXNwb25zZWAuXG5cdGdldEV4cHJlc3NSZXNwb25zZSA6IG1ha2VHZXR0ZXIoJ2V4cHJlc3NSZXNwb25zZScpLCAvLyBPbmx5IGF2YWlsYWJsZSB3aXRoIGBpc1Jhd1Jlc3BvbnNlYC5cblx0Z2V0UmVxdWVzdCAgICAgICAgIDogbWFrZUdldHRlcigncmVxdWVzdCcpLFxuXHRnZXRDb25maWcgICAgICAgICAgOiBrZXkgPT4gUGFnZUNvbmZpZy5nZXQoa2V5KSxcbn07XG5cbi8vIEVhY2ggaXRlbSBoZXJlIHJlcHJlc2VudHMgYSBtZXRob2QgdGhhdCBwYWdlL21pZGRsZXdhcmUgb2JqZWN0cyBtYXkgb3ZlcnJpZGUuXG4vL1xuLy8gVGhlIGtleXMgaGVyZSBhcmUgbWV0aG9kIG5hbWVzLlxuLy9cbi8vIFRoZSB2YWx1ZXMgYXJlIHR1cGxlcyBjb250YWluaW5nOlxuLy8gICAtIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIG1ldGhvZC5cbi8vICAgLSBOb3JtYWxpemF0aW9uIGZ1bmN0aW9uIGFwcGxpZWQgdG8gbWV0aG9kIG91dHB1dC5cbi8vXG4vLyBOb3RlIHRoYXQgZWFjaCBvZiB0aGVzZSBtZXRob2RzIHJlY2VpdmVzIGFuIGFyZ3VtZW50LCB3aGljaCBpcyB0aGUgbmV4dFxuLy8gaW1wbGVtZW50YXRpb24gb2YgdGhlIG1ldGhvZCBpbiB0aGUgY2FsbCBjaGFpbi5cbi8vICAgICAtIE1pZGRsZXdhcmUgaW1wbGVtZW50YXRpb25zIF9zaG91bGRfIGNhbGwgdGhpcyBpbiBtb3N0IGNhc2VzLipcbi8vICAgICAtIFBhZ2UgaW1wbGVtZW50YXRpb25zIF9tYXlfIGNhbGwgdGhpcyAoaXQgd2lsbCBiZSB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbikuXG4vL1xuLy8gKiBDb25zaWRlciBjYXJlZnVsbHkgYmVmb3JlIGRlY2lkaW5nIG5vdCB0byBjYWxsIGBuZXh0KClgIGluIG1pZGRsZXdhcmUuXG4vLyBPdGhlciBtaWRkbGV3YXJlIChhbmQgdGhlIHBhZ2UgaXRzZWxmKSBtYXkgZXhoaWJpdCB1bmRlZmluZWQgYmVoYXZpb3IgaWYgYVxuLy8gZ2l2ZW4gbWV0aG9kIGlzIG5vdCBjYWxsZWQuICBHZW5lcmFsbHksIG9ubHkgc2tpcCBjYWxsaW5nIGBuZXh0KClgIGZvclxuLy8gc2hvcnQtY2lyY3VpdCByZXNwb25zZXMgKGUuZy4gYSByZWRpcmVjdCBmcm9tIGBoYW5kbGVSb3V0ZWApLlxuLy9cbnZhciBQQUdFX01FVEhPRFMgPSB7XG5cdGhhbmRsZVJvdXRlICAgICAgICA6IFsoKSA9PiAoe2NvZGU6IDIwMH0pLCBRXSxcblx0Z2V0Q29udGVudFR5cGUgICAgIDogWygpID0+IFwidGV4dC9odG1sOyBjaGFyc2V0PXV0Zi04XCIsIF8gPT4gX10sXG5cdGdldEhlYWRlcnMgICAgICAgICA6IFsoKSA9PiBbXSwgUV0sXG5cdGdldFRpdGxlICAgICAgICAgICA6IFsoKSA9PiBcIlwiLCBRXSxcblx0Z2V0U2NyaXB0cyAgICAgICAgIDogWygpID0+IFtdLCBzdGFuZGFyZGl6ZVNjcmlwdHNdLFxuXHRnZXRTeXN0ZW1TY3JpcHRzICAgOiBbKCkgPT4gW10sIHN0YW5kYXJkaXplU2NyaXB0c10sXG5cdGdldEJvZHlTdGFydENvbnRlbnQ6IFsoKSA9PiBbXSwgUV0sXG5cdGdldEhlYWRTdHlsZXNoZWV0cyA6IFsoKSA9PiBbXSwgc3RhbmRhcmRpemVTdHlsZXNdLFxuXHRnZXREZWJ1Z0NvbW1lbnRzICAgOiBbKCkgPT4gW10sIHN0YW5kYXJkaXplRGVidWdDb21tZW50c10sXG5cdGdldE1ldGFUYWdzICAgICAgICA6IFsoKSA9PiBbXSwgc3RhbmRhcmRpemVNZXRhVGFnc10sXG5cdGdldExpbmtUYWdzICAgICAgICA6IFsoKSA9PiBbXSwgc3RhbmRhcmRpemVMaW5rVGFnc10sXG5cdGdldEJhc2UgICAgICAgICAgICA6IFsoKSA9PiBudWxsLCBRXSxcblx0Z2V0Qm9keUNsYXNzZXMgICAgIDogWygpID0+IFtdLCBRXSxcblx0Z2V0RWxlbWVudHMgICAgICAgIDogWygpID0+IFtdLCBzdGFuZGFyZGl6ZUVsZW1lbnRzXSxcblx0Z2V0UmVzcG9uc2VEYXRhICAgIDogWygpID0+IFwiXCIsIFFdLFxufTtcblxuLy8gVGhlc2UgYXJlIHNpbWlsYXIgdG8gYFBBR0VfTUVUSE9EU2AsIGJ1dCBkaWZmZXIgYXMgZm9sbG93czpcbi8vXG4vLyAgIC0gVGhleSBhcmUgbm90IGNoYWluZWQuXG4vLyAgIC0gVGhleSBkbyBub3QgaGF2ZSBkZWZhdWx0IGltcGxlbWVudGF0aW9ucy5cbi8vXG4vLyBFYWNoIHBhZ2UgYW5kIG1pZGRsZXdhcmUgdGhhdCBpbXBsZW1lbnRzIGEgcGFnZSBob29rIHdpbGwgaGF2ZSBpdHMgaG9va1xuLy8gY2FsbGVkIGluIHR1cm4uICBIb29rcyBkbyBub3QgcmVjZWl2ZSBhIGBuZXh0KClgIG1ldGhvZCwgYW5kIGFyZSBub3Rcbi8vIHJlc3BvbnNpYmxlIGZvciBtZXJnaW5nIHJldHVybiB2YWx1ZXMuXG4vL1xuLy8gVGhlIGtleXMgaGVyZSBhcmUgbWV0aG9kIG5hbWVzLlxuLy9cbi8vIFRoZSB2YWx1ZXMgYXJlIGVtcHR5IHBsYWNlaG9sZGVyIHR1cGxlcy5cbi8vXG52YXIgUEFHRV9IT09LUyA9IHtcblx0YWRkQ29uZmlnVmFsdWVzIDogW10sIC8vIERlZmluZSBuZXcgY29uZmlndXJhdGlvbiB2YWx1ZXMuXG5cdHNldENvbmZpZ1ZhbHVlcyA6IFtdLCAvLyBBbHRlciBleGlzdGluZyBjb25maWd1cmF0aW9uIHZhbHVlcy5cblx0aGFuZGxlQ29tcGxldGUgIDogW10sIC8vIERvIHN0dWZmIGFmdGVyIHRoZSByZXNwb25zZSBoYXMgYmVlbiBzZW50LlxufTtcblxuXG5cbi8vIFRoZXNlIG1ldGhvZHMgYXJlIG9ubHkgZGVmaW5lZCBvbiB0aGUgcGFnZSBfY2hhaW5fIHdoaWNoIGlzIHVzZWQgaW50ZXJuYWxseVxuLy8gd2l0aGluIHJlYWN0LXNlcnZlci4gIFBhZ2UvbWlkZGxld2FyZSBhdXRoZXJzIGNhbiBpZ25vcmUgdGhpcy5cbnZhciBQQUdFX0NIQUlOX1BST1RPVFlQRSA9IHtcblx0c2V0RXhwcmVzc1JlcXVlc3QgIDogbWFrZVNldHRlcignZXhwcmVzc1JlcXVlc3QnKSxcblx0c2V0RXhwcmVzc1Jlc3BvbnNlIDogbWFrZVNldHRlcignZXhwcmVzc1Jlc3BvbnNlJyksXG5cdHNldFJlcXVlc3QgICAgICAgICA6IG1ha2VTZXR0ZXIoJ3JlcXVlc3QnKSxcblx0Z2V0UmVxdWVzdCAgICAgICAgIDogbWFrZUdldHRlcigncmVxdWVzdCcpLFxuXG5cdC8vIFRPRE86IEtpbGwgdGhlc2U/ICBUaGV5J3JlIG9ubHkgdXNlZCB0byBwYXRjaCB2YWx1ZXNcblx0Ly8gdGhyb3VnaCBmcm9tIG5hdmlnYXRvciB0byByZW5kZXJNaWRkbGV3YXJlIHdpdGhpbiByZWFjdC1zZXJ2ZXIgaXRzZWxmLlxuXHQvLyBUaGV5IGRvbid0IG5lZWQgdG8gYmUgZXhwb3NlZCBwdWJsaWNseS5cblx0Ly9cblx0Ly8gVGhlIHdheSB0byBzZXQgYSByZXNwb25zZSBjb2RlIGZvciB5b3VyIHBhZ2UgaXMgdG8gcmV0dXJuIGl0IGZyb21cblx0Ly8gYGhhbmRsZVJvdXRlKClgIGFzIGUuZy4gYHtjb2RlOiAyMDB9YC5cblx0Ly9cblx0Ly8gVGhlIHdheSB0byBvcHQtaW4gdG8gcmVuZGVyaW5nIGEgZG9jdW1lbnQgZm9yIGEgbm9uLTJ4eCByZXNwb25zZVxuXHQvLyBjb2RlIGlzIHRvIGluY2x1ZGUgYGhhc0RvY3VtZW50OiB0cnVlYCBpbiB5b3VyIGBoYW5kbGVSb3V0ZSgpYFxuXHQvLyByZXNwb25zZSBvYmplY3QuXG5cdC8vXG5cdGdldFN0YXR1cyAgICAgICAgICA6IG1ha2VHZXR0ZXIoJ3N0YXR1cycpLFxuXHRzZXRTdGF0dXMgICAgICAgICAgOiBtYWtlU2V0dGVyKCdzdGF0dXMnKSxcblx0Z2V0SGFzRG9jdW1lbnQgICAgIDogbWFrZUdldHRlcignaGFzRG9jdW1lbnQnKSxcblx0c2V0SGFzRG9jdW1lbnQgICAgIDogbWFrZVNldHRlcignaGFzRG9jdW1lbnQnKSxcblx0Z2V0SnNCZWxvd1RoZUZvbGQgIDogbWFrZUdldHRlcignanNCZWxvd1RoZUZvbGQnKSxcblx0c2V0SnNCZWxvd1RoZUZvbGQgIDogbWFrZVNldHRlcignanNCZWxvd1RoZUZvbGQnKSxcblx0Z2V0U3BsaXRKc0xvYWQgICAgIDogbWFrZUdldHRlcignc3BsaXRKc0xvYWQnKSxcblx0c2V0U3BsaXRKc0xvYWQgICAgIDogbWFrZVNldHRlcignc3BsaXRKc0xvYWQnKSxcbn07XG5cbi8vIFdlIGxvZyBhbGwgbWV0aG9kIGNhbGxzIG9uIHRoZSBwYWdlIGNoYWluIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG5PYmplY3Qua2V5cyhQQUdFX0NIQUlOX1BST1RPVFlQRSkuZm9yRWFjaChtZXRob2QgPT4ge1xuXHRQQUdFX0NIQUlOX1BST1RPVFlQRVttZXRob2RdID0gbG9nSW52b2NhdGlvbihtZXRob2QsIFBBR0VfQ0hBSU5fUFJPVE9UWVBFW21ldGhvZF0pO1xufSk7XG5cbi8vIFRoZXNlIGFyZSBoZWxwZXJzIGZvciBgUEFHRV9NSVhJTmAgYW5kIGBQQUdFX0NIQUlOX1BST1RPVFlQRWAgbWV0aG9kcy5cbi8vXG4vLyBOb3RlIHRoYXQgZ2V0dGVycyBhbmQgc2V0dGVycyBkb24ndCBhY3R1YWxseSBtb2RpZnkgdGhlIHBhZ2UvbWlkZGxld2FyZVxuLy8gb2JqZWN0IGRpcmVjdGx5LCBidXQgcmF0aGVyIHN0YXNoIHZhbHVlcyBpbiByZXF1ZXN0IGxvY2FsIHN0b3JhZ2UuICBWYWx1ZXNcbi8vIGFyZSB0aGVyZWZvcmUgc2hhcmVkIGJldHdlZW4gdGhlIHBhZ2UgYW5kIGFsbCBtaWRkbGV3YXJlLlxuLy9cbmZ1bmN0aW9uIG1ha2VHZXR0ZXIoa2V5KXtcblx0cmV0dXJuICgpID0+IChSTFMoKS5taXhpblZhbHVlc3x8e30pW2tleV07XG59XG5cbmZ1bmN0aW9uIG1ha2VTZXR0ZXIoa2V5KXtcblx0cmV0dXJuIHZhbCA9PiB7XG5cdFx0KFJMUygpLm1peGluVmFsdWVzfHwoUkxTKCkubWl4aW5WYWx1ZXM9e30pKVtrZXldID0gdmFsO1xuXHR9XG59XG5cbi8vIFRoaXMgYXR0YWNoZXMgYFBBR0VfTUlYSU5gIG1ldGhvZHMgdG8gcGFnZS9taWRkbGV3YXJlIGNsYXNzZXMuXG4vL1xuLy8gSXQgZG9lcyB0aGlzIG9ubHkgX29uY2VfLCBhbmQgdGhlcmVhZnRlciBzaG9ydC1jaXJjdWl0cy5cbi8vXG5mdW5jdGlvbiBsYXp5TWl4aW5QYWdlVXRpbE1ldGhvZHMocGFnZSl7XG5cdHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwYWdlKTtcblx0aWYgKHByb3RvLl9oYXZlTWl4ZWRJblBhZ2VVdGlsTWV0aG9kcykgcmV0dXJuO1xuXG5cdHByb3RvLl9oYXZlTWl4ZWRJblBhZ2VVdGlsTWV0aG9kcyA9IHRydWU7XG5cblx0T2JqZWN0LmtleXMoUEFHRV9NSVhJTikuZm9yRWFjaChtZXRob2QgPT4ge1xuXHRcdGlmIChwcm90b1ttZXRob2RdKXtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgUEFHRV9NSVhJTlMgbWV0aG9kIG92ZXJyaWRlOiAke1xuXHRcdFx0XHQocHJvdG8uY29uc3RydWN0b3J8fHt9KS5uYW1lXG5cdFx0XHR9LiR7bWV0aG9kfWApO1xuXHRcdH1cblx0XHRwcm90b1ttZXRob2RdID0gUEFHRV9NSVhJTlttZXRob2RdO1xuXHR9KTtcbn1cblxuLy8gVGhlc2UgYHN0YW5kYXJkaXplKmAgZnVuY3Rpb25zIHNob3cgd2hhdCB3aWxsIGhhcHBlbiB0byB0aGUgb3V0cHV0IG9mIHlvdXJcbi8vIHBhZ2UgbWV0aG9kcy5cbi8vXG4vLyBGb3IgbWlkZGxld2FyZSBhdXRob3JzOiBCZSBhd2FyZSB0aGF0IHRoZXNlIHN0YW5kYXJkaXphdGlvbiBmdW5jdGlvbnMgd2lsbFxuLy8gaGF2ZSBiZWVuIGFwcGxpZWQgdG8gdGhlIG91dHB1dCBvZiBgbmV4dCgpYCBiZWZvcmUgeW91IGdldCBhY2Nlc3MgdG8gaXQuXG4vL1xuLy8gVGhlc2UgZnVuY3Rpb25zIGFyZSBhbHNvIGV4cG9zZWQgdmlhIGBQYWdlVXRpbC5zdGFuZGFyZGl6ZSpgLlxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHRha2VzIGluIGFueXRoaW5nIHJldHVybmVkIGZyb20gYSBQYWdlLmdldEVsZW1lbnRzIGNhbGwgYW5kXG4gKiByZXR1cm5zIHRoZSBlbGVtZW50cyBpbiBhIHN0YW5kYXJkaXplZCBmb3JtYXQ6IGFuIGFycmF5IG9mIEVhcmx5UHJvbWlzZXMgb2ZcbiAqIFJlYWN0RWxlbWVudHMuXG4gKi9cbmZ1bmN0aW9uIHN0YW5kYXJkaXplRWxlbWVudHMoZWxlbWVudHMpIHtcblxuXHQvLyBUaGUgcmV0dXJuIHZhbHVlIGNvdWxkIGJlIGEgc2luZ2xlIGVsZW1lbnQgb3IgYW4gYXJyYXkuXG5cdC8vIEZpcnN0LCBsZXQncyBtYWtlIHN1cmUgdGhhdCBpdCdzIGFuIGFycmF5LlxuXHQvLyBUaGVuLCBlbnN1cmUgdGhhdCBhbGwgZWxlbWVudHMgYXJlIHdyYXBwZWQgaW4gcHJvbWlzZXMuXG5cdHJldHVybiBtYWtlQXJyYXkoZWxlbWVudHMpXG5cdFx0Lm1hcChlID0+IGlzUm9vdENvbnRhaW5lcihlKT9mbGF0dGVuRm9yUmVuZGVyKGUpOmUpXG5cdFx0LnJlZHVjZSgobSwgZSkgPT4gbS5jb25jYXQoQXJyYXkuaXNBcnJheShlKT9lOltlXSksIFtdKVxuXHRcdC5tYXAoZSA9PiBpc1RoZUZvbGQoZSk/bWFya1RoZUZvbGQoKTplKVxuXHRcdC5tYXAoZW5zdXJlUm9vdEVsZW1lbnQpXG5cdFx0Lm1hcChzY2hlZHVsZVJlbmRlcilcbn1cblxuZnVuY3Rpb24gc3RhbmRhcmRpemVEZWJ1Z0NvbW1lbnRzKGRlYnVnQ29tbWVudHMpIHtcblx0cmV0dXJuIG1ha2VBcnJheShkZWJ1Z0NvbW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gc3RhbmRhcmRpemVNZXRhVGFncyhtZXRhVGFncykge1xuXHRyZXR1cm4gbWFrZUFycmF5KG1ldGFUYWdzKS5tYXAobWV0YVRhZyA9PiBRKG1ldGFUYWcpKTtcbn1cblxuZnVuY3Rpb24gc3RhbmRhcmRpemVMaW5rVGFncyhsaW5rVGFncykge1xuXHRyZXR1cm4gbWFrZUFycmF5KGxpbmtUYWdzKS5tYXAobGlua1RhZyA9PiBRKGxpbmtUYWcpKTtcbn1cblxuZnVuY3Rpb24gc3RhbmRhcmRpemVTY3JpcHRzKHNjcmlwdHMpIHtcblx0cmV0dXJuIG1ha2VBcnJheShzY3JpcHRzKS5tYXAoKHNjcmlwdCkgPT4ge1xuXHRcdGlmICghKHNjcmlwdC5ocmVmIHx8IHNjcmlwdC50ZXh0KSkge1xuXHRcdFx0c2NyaXB0ID0geyBocmVmOnNjcmlwdCB9XG5cdFx0fVxuXG5cdFx0aWYgKCFzY3JpcHQudHlwZSkgc2NyaXB0LnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xuXG5cdFx0Ly8gRGVmYXVsdCBpcyBzdHJpY3QgbW9kZSB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblx0XHRpZiAoIXNjcmlwdC5oYXNPd25Qcm9wZXJ0eSgnc3RyaWN0JykpIHNjcmlwdC5zdHJpY3QgPSB0cnVlO1xuXG5cdFx0Ly8gaWYgdGhlIGFuc3dlciB3YXMgYSBzdHJpbmcsIGxldCdzIG1ha2UgYSBzY3JpcHQgb2JqZWN0XG5cdFx0cmV0dXJuIHNjcmlwdDtcblx0fSlcbn1cblxuZnVuY3Rpb24gc3RhbmRhcmRpemVTdHlsZXMoc3R5bGVzKSB7XG5cdHJldHVybiBtYWtlQXJyYXkoc3R5bGVzKS5tYXAoc3R5bGVPclAgPT4ge1xuXHRcdHJldHVybiBRKHN0eWxlT3JQKS50aGVuKHN0eWxlID0+IHtcblx0XHRcdGlmICghc3R5bGUpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc3R5bGUuaHJlZiB8fCBzdHlsZS50ZXh0KSB7XG5cdFx0XHRcdGlmICghc3R5bGUudHlwZSkgc3R5bGUudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0XHRcdFx0aWYgKCFzdHlsZS5tZWRpYSkgc3R5bGUubWVkaWEgPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBzdHlsZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgdGhlIGFuc3dlciB3YXMgYSBzdHJpbmcsIGxldCdzIG1ha2UgYSBzY3JpcHQgb2JqZWN0XG5cdFx0XHRyZXR1cm4ge2hyZWY6c3R5bGUsIHR5cGU6XCJ0ZXh0L2Nzc1wiLCBtZWRpYTpcIlwifTtcblx0XHR9KTtcblx0fSlcbn1cblxuLy8gVGhpcyBpcyB1c2VkIHRvIGxvZyBtZXRob2QgY2FsbHMgb24gdGhlIHBhZ2UgX2NoYWluXy4gIE1ldGhvZCBjYWxscyBvblxuLy8gaW5kaXZpZHVhbCBwYWdlL21pZGRsZXdhcmUgb2JqZWN0cyBhcmUgbm90IGF1dG9tYXRpY2FsbHkgbG9nZ2VkLlxuZnVuY3Rpb24gbG9nSW52b2NhdGlvbihuYW1lLCBmdW5jKXtcblx0cmV0dXJuIGZ1bmN0aW9uKCl7XG5cdFx0bG9nZ2VyLmRlYnVnKGBDYWxsICR7bmFtZX1gKTtcblx0XHRyZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuXHR9XG59XG5cbi8vIFJldHVybiBgZm5gIHdpdGggYSB3cmFwcGVyIHRoYXQgcHV0cyBpdHMgcmV0dXJuIHZhbHVlIHRocm91Z2ggYHN0YW5kYXJkaXplYFxuLy8gb24gdGhlIHdheSBvdXQuXG5mdW5jdGlvbiBtYWtlU3RhbmRhcmQoc3RhbmRhcmRpemUsIGZuKXtcblx0cmV0dXJuIGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHN0YW5kYXJkaXplKGZuLmFwcGx5KG51bGwsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIG1ha2VBcnJheSh2YWx1ZU9yQXJyYXkpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KHZhbHVlT3JBcnJheSkpIHtcblx0XHRyZXR1cm4gW3ZhbHVlT3JBcnJheV07XG5cdH1cblx0cmV0dXJuIHZhbHVlT3JBcnJheTtcbn1cblxudmFyIFBhZ2VVdGlsID0ge1xuXHRQQUdFX01FVEhPRFMsXG5cblx0c3RhbmRhcmRpemVFbGVtZW50cyxcblx0c3RhbmRhcmRpemVNZXRhVGFncyxcblx0c3RhbmRhcmRpemVTY3JpcHRzLFxuXHRzdGFuZGFyZGl6ZVN0eWxlcyxcblxuXHRQYWdlQ29uZmlnLFxuXG5cdC8vIEdpdmVuIGFuIGFycmF5IG9mIHBhZ2UvbWlkZGxld2FyZSBpbnN0YW5jZXMsIHJldHVybiBhbiBvYmplY3QgdGhhdFxuXHQvLyBpbXBsZW1lbnRzIHRoZSBpbnRlcmZhY2UgZGVmaW5lZCBieSB0aGUgdW5pb24gb2Y6XG5cdC8vXG5cdC8vICAgLSBQQUdFX0NIQUlOX1BST1RPVFlQRVxuXHQvLyAgIC0gUEFHRV9NRVRIT0RTXG5cdC8vICAgLSBQQUdFX0hPT0tTXG5cdC8vXG5cdGNyZWF0ZVBhZ2VDaGFpbihwYWdlcykge1xuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0Ly8gVGhpcyB3aWxsIGJlIG91ciByZXR1cm4gdmFsdWUuXG5cdFx0Ly9cblx0XHQvLyBUaGlzIGBPYmplY3QuY3JlYXRlKClgIGNhbGwgY3JlYXRlcyBhIG5ldyBlbXB0eSBvYmplY3Rcblx0XHQvLyAoYHt9YCkgd2l0aCBgUEFHRV9DSEFJTl9QUk9UT1RZUEVgIGFzIGl0cyBwcm90b3R5cGUuXG5cdFx0Ly9cblx0XHR2YXIgcGFnZUNoYWluID0gT2JqZWN0LmNyZWF0ZShQQUdFX0NIQUlOX1BST1RPVFlQRSk7XG5cblx0XHQvLyBNYWtlIHN1cmUgYWxsIHBhZ2UgY2xhc3NlcyBoYXZlIGJlZW4gYXVnbWVudGVkIHdpdGggdGhlXG5cdFx0Ly8gbWV0aG9kcyBwcm92aWRlZCBieSBgUEFHRV9NSVhJTmAuXG5cdFx0cGFnZXMuZm9yRWFjaChsYXp5TWl4aW5QYWdlVXRpbE1ldGhvZHMpO1xuXG5cdFx0Ly8gV2lyZSB1cCB0aGUgY2hhaW5lZCBtZXRob2RzLlxuXHRcdGZvciAodmFyIG1ldGhvZCBpbiBQQUdFX01FVEhPRFMpe1xuXG5cdFx0XHRpZiAoIVBBR0VfTUVUSE9EUy5oYXNPd25Qcm9wZXJ0eShtZXRob2QpKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIFtkZWZhdWx0SW1wbCwgc3RhbmRhcmRpemVdID0gUEFHRV9NRVRIT0RTW21ldGhvZF07XG5cblx0XHRcdC8vIFRha2UgYm91bmQgbWV0aG9kcyBmb3IgZWFjaCBwYWdlL21pZGRsZXdhcmUgdGhhdFxuXHRcdFx0Ly8gaW1wbGVtZW50cyAocGx1cyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiksIGFuZFxuXHRcdFx0Ly8gY2hhaW4gdGhlbSB0b2dldGhlciBzbyB0aGF0IGVhY2ggcmVjZWl2ZXMgYXMgYW5cblx0XHRcdC8vIGFyZ3VtZW50IHRoZSByZXN0IG9mIHRoZSBjaGFpbiBpbiB0aGUgZm9ybSBvZiBhblxuXHRcdFx0Ly8gYXJpdHktemVybyBmdW5jdGlvbi5cblx0XHRcdC8vXG5cdFx0XHQvLyBUaGUgYG5leHRgIGFyZ3VtZW50IGluIHRoZSByZWR1Y3Rpb24gaGVyZSBpcyB0aGVcblx0XHRcdC8vIGFjY3VtdWxhdGVkIGNoYWluLiAgSXQgaXMgd2hhdCBlYWNoIGltcGxlbWVudGF0aW9uXG5cdFx0XHQvLyB3aWxsIHJlY2VpdmUgYXMgX2l0c18gYG5leHRgIGFyZ3VtZW50LlxuXHRcdFx0Ly9cblx0XHRcdHBhZ2VDaGFpblttZXRob2RdID0gbG9nSW52b2NhdGlvbihtZXRob2QsIHBhZ2VzXG5cdFx0XHRcdC5maWx0ZXIgICAgICAocGFnZSA9PiBwYWdlW21ldGhvZF0pXG5cdFx0XHRcdC5tYXAgICAgICAgICAocGFnZSA9PiBwYWdlW21ldGhvZF0uYmluZChwYWdlKSlcblx0XHRcdFx0LmNvbmNhdCAgICAgIChbZGVmYXVsdEltcGxdKVxuXHRcdFx0XHQubWFwICAgICAgICAgKG1ha2VTdGFuZGFyZC5iaW5kKG51bGwsIHN0YW5kYXJkaXplKSlcblx0XHRcdFx0LnJlZHVjZVJpZ2h0ICgobmV4dCwgY3VyKSA9PiBjdXIuYmluZChudWxsLCBuZXh0KSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gV2lyZSB1cCB0aGUgdW4tY2hhaW5lZCBtZXRob2RzLlxuXHRcdE9iamVjdC5rZXlzKFBBR0VfSE9PS1MpLmZvckVhY2gobWV0aG9kID0+IHtcblxuXHRcdFx0Ly8gR3JhYiBhIGxpc3Qgb2YgcGFnZXMgdGhhdCBpbXBsZW1lbnQgdGhpcyBtZXRob2QuXG5cdFx0XHR2YXIgaW1wbGVtZW50b3JzID0gcGFnZXMuZmlsdGVyKHBhZ2UgPT4gcGFnZVttZXRob2RdKTtcblxuXHRcdFx0Ly8gVGhlIHJlc3VsdGluZyBmdW5jdGlvbiBjYWxscyBlYWNoIGltcGxlbWVudG9yJ3Ncblx0XHRcdC8vIG1ldGhvZCBpbiB0dXJuIGFuZCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgaW5cblx0XHRcdC8vIHRoZWlyIHJldHVybiB2YWx1ZXMuXG5cdFx0XHRwYWdlQ2hhaW5bbWV0aG9kXSA9IGxvZ0ludm9jYXRpb24obWV0aG9kLCBmdW5jdGlvbigpe1xuXG5cdFx0XHRcdC8vIFRoZSBgYXJndW1lbnRzYCBvYmplY3QgaXNuJ3QgYSByZWFsIGFycmF5LlxuXHRcdFx0XHQvLyBQcmUtZXM1IGBGdW5jdGlvbi5hcHBseSgpYCByZXF1aXJlZCBhIHJlYWxcblx0XHRcdFx0Ly8gYXJyYXkuICBUaGlzIGBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylgXG5cdFx0XHRcdC8vIGlkaW9tIGNyZWF0ZXMgYSByZWFsIGFycmF5IHdpdGggdGhlIGVsZW1lbnRzXG5cdFx0XHRcdC8vIG9mIHRoZSBgYXJndW1lbnRzYCBvYmplY3QuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc2xpY2Vcblx0XHRcdFx0Ly9cblx0XHRcdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cblx0XHRcdFx0cmV0dXJuIGltcGxlbWVudG9ycy5tYXAoXG5cdFx0XHRcdFx0cGFnZSA9PiBwYWdlW21ldGhvZF0uYXBwbHkocGFnZSwgYXJncylcblx0XHRcdFx0KVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gcGFnZUNoYWluO1xuXHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cdH0sXG5cblx0bWFrZUFycmF5LFxuXG5cdGdldEVsZW1lbnREaXNwbGF5TmFtZShlbGVtZW50KXtcblxuXHRcdC8vIEdvdHRhIGJlIGEgcmVhY3QgZWxlbWVudC5cblx0XHRpZiAoIShlbGVtZW50ICYmIGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnByb3BzKSkgcmV0dXJuICdOb25lJztcblxuXHRcdHZhciBuYW1lID0gZWxlbWVudC50eXBlLmRpc3BsYXlOYW1lO1xuXG5cdFx0aWYgKCFuYW1lKSB7XG5cblx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhIGBkaXNwbGF5TmFtZWAsIGJ1dCBpdFxuXHRcdFx0Ly8gaGFzIG9ubHkgYSBzaW5nbGUgY2hpbGQsIHdlJ2xsIGxvb2sgYXQgdGhlIGNoaWxkIHRvXG5cdFx0XHQvLyBzZWUgaWYgaXQgaGFzIGEgbmljZSBuYW1lLiAgVGhpcyBoZWxwcyBieXBhc3Ncblx0XHRcdC8vIGFub255bW91cyB3cmFwcGVyIGVsZW1lbnRzLlxuXHRcdFx0aWYgKFJlYWN0LkNoaWxkcmVuLmNvdW50KGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pID09PSAxKXtcblxuXHRcdFx0XHQvLyBTaWdoLiAgYFJlYWN0LkNoaWxkcmVuLmNvdW50YCB3aWxsIGhhcHBpbHlcblx0XHRcdFx0Ly8gcmV0dXJuIDEgaWYgdGhlIG5vZGUgY29udGFpbnMgb25seSB0ZXh0LCBhbmRcblx0XHRcdFx0Ly8gdGhlbiBgUmVhY3QuQ2hpbGRyZW4ub25seWAgd2lsbCBoYXBwaWx5XG5cdFx0XHRcdC8vIF9ibG93IHVwXyBpZiBpdCByZWNlaXZlcyB0aGF0IHRleHQgc2F5aW5nIGl0XG5cdFx0XHRcdC8vIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQuLi4gd2hpY2hcblx0XHRcdFx0Ly8gYFJlYWN0LkNoaWxkcmVuLmNvdW50YCBqdXN0IHRvbGQgdXMgd2Vcblx0XHRcdFx0Ly8gaGF2ZS4uLiA6Z29iZXJ6ZXJrOlxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdG5hbWUgPSBQYWdlVXRpbC5nZXRFbGVtZW50RGlzcGxheU5hbWUoXG5cdFx0XHRcdFx0XHRSZWFjdC5DaGlsZHJlbi5vbmx5KFxuXHRcdFx0XHRcdFx0XHRlbGVtZW50LnByb3BzLmNoaWxkcmVuXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBjYXRjaCAoZSkgeyAvKiBQYXNzLiAqLyB9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU29tZSBvZiBvdXIgbmFtZXMgYXJlIG5hbWVzcGFjZWQgd2l0aCBkb3Qtc2VwYXJhdGlvbi4gIFdlXG5cdFx0Ly8ganVzdCB3YW50IHRoZSBtb3N0IHNpZ25pZmljYW50IHBhcnQgYXQgdGhlIGVuZC5cblx0XHRyZXR1cm4gKG5hbWV8fCdVbmtub3duJykuc3BsaXQoJy4nKS5wb3AoKTtcblx0fSxcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2VVdGlsXG4iXX0=
