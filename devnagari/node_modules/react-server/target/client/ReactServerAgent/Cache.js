"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var logger = require('../logging').getLogger({ "name": "react-server.core.ReactServerAgent.Cache", "color": { "server": 63, "client": "rgb(42,42,212)" } }),
    Q = require('q'),
    merge = require("lodash/merge"),
    isEqual = require("lodash/isEqual");

// TODO: we should figure out a way to consolidate this with SuperAgentExtender
var responseBodyParsers = {
	'application/json': function applicationJson(text) {
		if (text && text.trim) {
			text = text.trim();
		}
		if (/^{}&&/.test(text)) {
			text = text.substr(4);
		}
		return JSON.parse(text);
	}

	/**
  * An entry in the RequestDataCache
  */
};
var CacheEntry = function () {

	/**
  * @param cache [required] the RequestDataCache instance that owns this
  *        `CacheEntry`.
  * @param requestData a request data descriptor. Won't be passed if this
  *        CacheEntry is in the process of being rehydrated
  * @param cacheWhiteList [optional] the whitelist of repsonse fields that
  *        will be serialized with this entry. Not passed when rehydrating.
  */
	function CacheEntry(cache) {
		var _this = this;

		var requestData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		var cacheWhitelist = arguments[2];

		_classCallCheck(this, CacheEntry);

		this.cache = cache;
		this.cacheWhitelist = cacheWhitelist;
		this.requesters = 0;
		this.dfd = Q.defer();
		this.loaded = false;
		this.res = undefined;
		this.err = undefined;
		// copy the rest of the properties from input requestData
		// to this.requestData

		this.url = requestData.urlPath;
		this.requestData = {};
		Object.keys(requestData).forEach(function (key) {
			_this.requestData[key] = requestData[key];
		});
	}

	_createClass(CacheEntry, [{
		key: "dehydrate",
		value: function dehydrate() {
			var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
			    responseBodyOnly = _ref.responseBodyOnly;

			var err = this.err;
			if (err) {
				// create a shallow copy of the error object
				var errCopy = merge({}, err);
				if (errCopy.response) {
					errCopy.response = this._copyResponseForDehydrate(errCopy.response, { responseBodyOnly: responseBodyOnly });
				}
			}

			return {
				url: this.url,
				requestData: this.requestData,
				requesters: this.requesters,
				loaded: this.loaded,
				res: this._copyResponseForDehydrate(this.res, { responseBodyOnly: responseBodyOnly }),
				err: errCopy
			};
		}

		/**
   * _copyResponseForDehydrate attempts to construct a canonical form of the response object
   * that can be used later to reconstruct it. Its primary goal is to avoid duplication of
   * the response body in both the `.text` and `.body` properties of the cached response object.
   *
   * There are several ways this could have been handled, but the purest way (as of right now)
   * from the standpoint of the API appears to be to provide parsing functions for known
   * response types (e.g., "application/json"). If the response content-type is known, we'll
   * simply serialize a placeholder (`_hasBody`) indicating that we should try to reparse the
   * body from the response text when rehydrating. If there is a parsed body on the response at
   * the time of dehydrating and we *don't* recognize the response type, we'll serialize both
   * `.text` and `.body`, paying a penalty in response size, but guaranteeing correctness.
   * (We'll also log a warning saying that we should probably add another response type).
   *
   */

	}, {
		key: "_copyResponseForDehydrate",
		value: function _copyResponseForDehydrate(res) {
			var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
			    responseBodyOnly = _ref2.responseBodyOnly;

			if (!res) return res;

			var resCopy = {};
			if (responseBodyOnly) {
				resCopy.body = res.body;
				return resCopy;
			}

			var parseable = !!responseBodyParsers[res.type];

			Object.keys(res).forEach(function (prop) {
				if ("body" === prop && parseable) {
					// don't copy body if it's a well-known (easily-parsed) content-type
					resCopy._hasBody = true;
				} else {
					if ("body" === prop) {
						// 'parseable' must be false. we should log a warning
						logger.warning("ReactServerAgent needs responseBodyParser for content-type: " + res.type + " to avoid duplicating data in cache body");
					}
					resCopy[prop] = res[prop];
				}
			});
			return resCopy;
		}
	}, {
		key: "rehydrate",
		value: function rehydrate(state) {

			// NOTE: rehydrate will be called _TWICE_ for late arrivals:
			// once initially, when not loaded, and once again when
			// the request arrives

			var err = state.err;
			if (err) {
				err.response = this._rehydrateResponse(err.response);
			}

			this.url = state.url;
			this.requestData = state.requestData;
			this.requesters = state.requesters;
			this.loaded = state.loaded;
			this.res = this._rehydrateResponse(state.res);
			this.err = err;

			// TODO FIXME: these won't work if the response from the server was an error

			if (this.loaded) {
				// call setResponse to resolve the deferred
				if (this.res) {
					this.setResponse(this.res);
				} else if (this.err) {
					this.setError(this.err);
				}
				logger.debug("Rehydrating resolved url to cache: " + this.url);
			} else {
				logger.debug("Rehydrating pending url to cache without data: " + this.url);
			}
		}
	}, {
		key: "_rehydrateResponse",
		value: function _rehydrateResponse(res) {
			if (!res) return res;

			if (res._hasBody) {
				// re-parse the text of the response body serialized by the server.
				// if the body wasn't in a known format, it will have been included directly

				var parse = responseBodyParsers[res.type];
				if (!parse) {
					logger.warning("Unparseable content type for " + this.url + ": " + res.type + ", but response._hasBody was true. (This may be a bug in ReactServerAgent)");
				}
				res.body = parse && res.text && res.text.length ? parse(res.text) : null;
				delete res._hasBody;
			}

			return res;
		}
	}, {
		key: "setResponse",
		value: function setResponse(res) {
			// TODO: store superagent response? or body? or payload?

			if (false) {

				// Pull out the pieces of the response we care about.
				// This would be a NOOP client-side, so we'll skip it.
				res = this._trimResponseData(res);
			}

			// Stash away a reference to the response.
			this.res = res;
			this.loaded = true;

			// Resolve with a serialized copy.  We'll unserialize for each
			// requester.  This way we provide a fresh copy each time so mutations
			// don't leak.
			//
			// This also leaves _us_ with a clean copy of the original response.
			// This is important to ensure that we provide the same data from the
			// cache when we wake up in the browser as we initially provide on the
			// server.
			//
			this.dfd.resolve(JSON.stringify(res));
		}
	}, {
		key: "setError",
		value: function setError(err) {

			if (false) {

				// If the error was caused by a server response, trim it
				// and serialize it like a regular response
				if (err && err.response) {
					err.response = this._trimResponseData(err.response);
				}
			}

			this.err = err;
			this.loaded = true;

			if (false) {
				// Deep copy, to make sure nobody plays with the
				// object we put in the cache
				err = JSON.parse(JSON.stringify(err));
			}

			this.dfd.reject(err);
		}
	}, {
		key: "_parsePromise",
		value: function _parsePromise(dfd) {
			return dfd.promise.then(function (val) {
				return JSON.parse(val);
			});
		}
	}, {
		key: "whenDataReady",
		value: function whenDataReady() {
			if (false) {
				// server-side, we increment the number of requesters
				// we expect to retrieve the data on the frontend
				this.requesters += 1;
				return this._parsePromise(this.dfd);
			} else {
				// client-side, whenever someone retrieves data from the cache,
				// we decrement the number of retrievals expected, and when we
				// hit zero, remove the cache entry.
				return this._requesterDecrementingPromise(this.dfd);
			}
		}

		// for internal (react-server middleware) calls

	}, {
		key: "whenDataReadyInternal",
		value: function whenDataReadyInternal() {
			return this.dfd.promise;
		}
	}, {
		key: "decrementRequesters",
		value: function decrementRequesters() {
			logger.debug("Decrementing: " + this.url);
			this.requesters -= 1;

			if (this.requesters === 0) {
				this.cache._removeEntry(this);
			}
		}

		/**
   * Chain a promise with another promise that decrements
   * the number of expected requesters.
   */

	}, {
		key: "_requesterDecrementingPromise",
		value: function _requesterDecrementingPromise(dfd) {
			var _this2 = this;

			// regardless of whether we're resolved with a 'res' or 'err',
			// we want to decrement requests. the appropriate 'success' or 'error'
			// callback will be executed on whatever is chained after this method
			return this._parsePromise(dfd).fin(function (resOrErr) {
				_this2.decrementRequesters();
				return resOrErr;
			});
		}
	}, {
		key: "isForSameRequest",
		value: function isForSameRequest(requestData) {
			var otherRD = requestData;
			var myRD = this.requestData;

			function same(propName) {
				return isEqual(myRD[propName], otherRD[propName]);
			}

			// specifying the order of checks here to let the fast/common checks
			// fail first
			return same("urlPath") && same("method") && same("type") && same("queryParams") && same("postParams");
		}

		// Pull out the properties of the superagent response that we care
		// about and produce an object that's suitable for writing as JSON.

	}, {
		key: "_trimResponseData",
		value: function _trimResponseData(res) {
			var result = {};
			["body", "text", "type",

			/*'files'*/ // TODO

			/* "header",*/ // header is no longer included by default in the cache to save space
			"status", "statusType", "info", "ok", "clientError", "serverError", "error", "accepted", "noContent", "badRequest", "unauthorized", "notAcceptable", "notFound", "forbidden"].forEach(function (prop) {
				result[prop] = res[prop];
			});
			if (this.cacheWhitelist) {
				this.cacheWhitelist.forEach(function (prop) {
					result[prop] = res[prop];
				});
			}

			return result;
		}
	}]);

	return CacheEntry;
}();

/**
 * Cache of responses to API requests made server-side that will be
 * serialized as part of the initial page request and replayed in the
 * browser.
 */


var RequestDataCache = function () {
	function RequestDataCache() {
		_classCallCheck(this, RequestDataCache);

		/*
   * Map[String -> CacheEntry[]]
   */
		this.dataCache = {};
	}

	_createClass(RequestDataCache, [{
		key: "dehydrate",
		value: function dehydrate() {
			var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
			    _ref3$responseBodyOnl = _ref3.responseBodyOnly,
			    responseBodyOnly = _ref3$responseBodyOnl === undefined ? false : _ref3$responseBodyOnl;

			var out = {
				dataCache: {}
			};

			var dataCache = this.dataCache;
			Object.keys(dataCache).forEach(function (url) {
				// as a nice-to-have for FragmentDataCache, if there's only one entry
				// for a given URL, don't serialize it as an array, serialize it as a single
				// CacheEntry
				var dehydratedEntries = dataCache[url].map(function (entry) {
					return entry.dehydrate({ responseBodyOnly: responseBodyOnly });
				});
				out.dataCache[url] = dehydratedEntries.length === 1 ? dehydratedEntries[0] : dehydratedEntries;
			});

			return out;
		}
	}, {
		key: "rehydrate",
		value: function rehydrate(state) {
			var _this3 = this;

			logger.debug("Rehydrating RequestDataCache");

			// clear state
			var dataCache = this.dataCache = {};

			Object.keys(state.dataCache).forEach(function (url) {

				var entries = state.dataCache[url];
				// convert entries to an array, if it was serialized as
				// a single entry
				entries = Array.isArray(entries) ? entries : [entries];
				dataCache[url] = entries.map(function (entryData) {
					var newEntry = new CacheEntry(_this3);
					newEntry.rehydrate(entryData);
					return newEntry;
				});
			});
		}

		/**
   * Get (optionally creating if necessary) the entry for the given
   * requestData from the cache.
   *
   * @param createIfMissing boolean default false
   * @param cacheWhitelist array default []
   */

	}, {
		key: "entry",
		value: function entry(requestData) {
			var createIfMissing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
			var cacheWhitelist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

			if (!requestData.urlPath) {
				throw new Error("Missing requestData.urlPath");
			}

			logger.debug("Getting ReactServerAgent request data cache entry for " + requestData.urlPath);

			var cacheEntry = this._findEntry(requestData);
			if (!cacheEntry && createIfMissing) {
				cacheEntry = this._addEntry(requestData, cacheWhitelist);
			}

			return cacheEntry;
		}
	}, {
		key: "_findEntry",
		value: function _findEntry(requestData) {
			var urlPath = requestData.urlPath;
			var entries = this.dataCache[urlPath] || [];
			// old-school loop so we can break early
			for (var i = 0; i < entries.length; i++) {
				var entry = entries[i];
				if (entry.isForSameRequest(requestData)) {
					return entry;
				}
			}
			return null;
		}

		/**
   * Add a new CacheEntry for the request described by `requestData`
   *
   * @param requestData the request data descriptor, as defined by
   *        Request._getCacheAffectingData.
   * @param cacheWhiteList the whitelist of fields that will be provided
   *        on the request.
   */

	}, {
		key: "_addEntry",
		value: function _addEntry(requestData, cacheWhitelist) {
			var urlPath = requestData.urlPath,
			    entries = this.dataCache[urlPath] || (this.dataCache[urlPath] = []),
			    newEntry = new CacheEntry(this, requestData, cacheWhitelist);
			entries.push(newEntry);
			return newEntry;
		}
	}, {
		key: "_removeEntry",
		value: function _removeEntry(entry) {
			var urlPath = entry.requestData.urlPath,
			    entries = this.dataCache[urlPath],
			    idx = entries.indexOf(entry);
			if (idx >= 0) {
				entries.splice(idx, 1);
			}
			this.checkCacheDepleted();
		}
	}, {
		key: "markLateRequests",
		value: function markLateRequests() {
			this.getPendingRequests().forEach(function (req) {
				req.entry.late = true;
			});
		}
	}, {
		key: "getLateRequests",
		value: function getLateRequests() {
			return this.getAllRequests().filter(function (req) {
				return req.entry.late;
			});
		}
	}, {
		key: "getPendingRequests",
		value: function getPendingRequests() {
			return this.getAllRequests().filter(function (req) {
				return !req.entry.loaded;
			});
		}
	}, {
		key: "getAllRequests",
		value: function getAllRequests() {
			var _this4 = this;

			var all = [];
			Object.keys(this.dataCache).forEach(function (url) {
				_this4.dataCache[url].forEach(function (entry) {
					all.push({ url: url, entry: entry });
				});
			});
			return all;
		}
	}, {
		key: "whenAllPendingResolve",
		value: function whenAllPendingResolve() {
			var promises = this.getAllRequests().map(function (req) {
				return req.entry.dfd.promise;
			});
			return Q.allSettled(promises);
		}

		/**
   * Fires when the cache has been completely depleted, which is used as a signal to render when there was a timeout on the server.
   */

	}, {
		key: "whenCacheDepleted",
		value: function whenCacheDepleted() {
			this.whenCacheDepletedDfd = this.whenCacheDepletedDfd || Q.defer();

			this.checkCacheDepleted();

			return this.whenCacheDepletedDfd.promise;
		}
	}, {
		key: "checkCacheDepleted",
		value: function checkCacheDepleted() {
			logger.debug("_checkCacheDepleted");
			if (this.whenCacheDepletedDfd) {
				var totalRequestersPending = 0;
				this.getAllRequests().forEach(function (req) {
					if (req.entry.loaded) {
						totalRequestersPending += req.entry.requesters;
					}
				});
				logger.debug("Checking for depleted cache, with " + totalRequestersPending + " requesters left");
				if (totalRequestersPending === 0) this.whenCacheDepletedDfd.resolve();
			}
		}
	}, {
		key: "lateArrival",
		value: function lateArrival(url, dehydratedEntry) {
			logger.debug("Late arrival for " + url);
			var entry = this._findEntry(dehydratedEntry.requestData);
			if (entry) {
				entry.rehydrate(dehydratedEntry);
			} else {
				logger.debug("WTF?");
			}
		}
	}]);

	return RequestDataCache;
}();

module.exports = RequestDataCache;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlYWN0U2VydmVyQWdlbnQvQ2FjaGUuanMiXSwibmFtZXMiOlsibG9nZ2VyIiwicmVxdWlyZSIsImdldExvZ2dlciIsIlEiLCJtZXJnZSIsImlzRXF1YWwiLCJyZXNwb25zZUJvZHlQYXJzZXJzIiwidGV4dCIsInRyaW0iLCJ0ZXN0Iiwic3Vic3RyIiwiSlNPTiIsInBhcnNlIiwiQ2FjaGVFbnRyeSIsImNhY2hlIiwicmVxdWVzdERhdGEiLCJjYWNoZVdoaXRlbGlzdCIsInJlcXVlc3RlcnMiLCJkZmQiLCJkZWZlciIsImxvYWRlZCIsInJlcyIsInVuZGVmaW5lZCIsImVyciIsInVybCIsInVybFBhdGgiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsInJlc3BvbnNlQm9keU9ubHkiLCJlcnJDb3B5IiwicmVzcG9uc2UiLCJfY29weVJlc3BvbnNlRm9yRGVoeWRyYXRlIiwicmVzQ29weSIsImJvZHkiLCJwYXJzZWFibGUiLCJ0eXBlIiwicHJvcCIsIl9oYXNCb2R5Iiwid2FybmluZyIsInN0YXRlIiwiX3JlaHlkcmF0ZVJlc3BvbnNlIiwic2V0UmVzcG9uc2UiLCJzZXRFcnJvciIsImRlYnVnIiwibGVuZ3RoIiwiX3RyaW1SZXNwb25zZURhdGEiLCJyZXNvbHZlIiwic3RyaW5naWZ5IiwicmVqZWN0IiwicHJvbWlzZSIsInRoZW4iLCJ2YWwiLCJfcGFyc2VQcm9taXNlIiwiX3JlcXVlc3RlckRlY3JlbWVudGluZ1Byb21pc2UiLCJfcmVtb3ZlRW50cnkiLCJmaW4iLCJkZWNyZW1lbnRSZXF1ZXN0ZXJzIiwicmVzT3JFcnIiLCJvdGhlclJEIiwibXlSRCIsInNhbWUiLCJwcm9wTmFtZSIsInJlc3VsdCIsIlJlcXVlc3REYXRhQ2FjaGUiLCJkYXRhQ2FjaGUiLCJvdXQiLCJkZWh5ZHJhdGVkRW50cmllcyIsIm1hcCIsImVudHJ5IiwiZGVoeWRyYXRlIiwiZW50cmllcyIsIkFycmF5IiwiaXNBcnJheSIsIm5ld0VudHJ5IiwicmVoeWRyYXRlIiwiZW50cnlEYXRhIiwiY3JlYXRlSWZNaXNzaW5nIiwiRXJyb3IiLCJjYWNoZUVudHJ5IiwiX2ZpbmRFbnRyeSIsIl9hZGRFbnRyeSIsImkiLCJpc0ZvclNhbWVSZXF1ZXN0IiwicHVzaCIsImlkeCIsImluZGV4T2YiLCJzcGxpY2UiLCJjaGVja0NhY2hlRGVwbGV0ZWQiLCJnZXRQZW5kaW5nUmVxdWVzdHMiLCJyZXEiLCJsYXRlIiwiZ2V0QWxsUmVxdWVzdHMiLCJmaWx0ZXIiLCJhbGwiLCJwcm9taXNlcyIsImFsbFNldHRsZWQiLCJ3aGVuQ2FjaGVEZXBsZXRlZERmZCIsInRvdGFsUmVxdWVzdGVyc1BlbmRpbmciLCJkZWh5ZHJhdGVkRW50cnkiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSxJQUFJQSxTQUFTQyxRQUFRLFlBQVIsRUFBc0JDLFNBQXRCLENBQWdDLEVBQUMsUUFBTywwQ0FBUixFQUFtRCxTQUFRLEVBQUMsVUFBUyxFQUFWLEVBQWEsVUFBUyxnQkFBdEIsRUFBM0QsRUFBaEMsQ0FBYjtBQUFBLElBQ0VDLElBQUlGLFFBQVEsR0FBUixDQUROO0FBQUEsSUFFRUcsUUFBUUgsUUFBUSxjQUFSLENBRlY7QUFBQSxJQUdFSSxVQUFVSixRQUFRLGdCQUFSLENBSFo7O0FBTUE7QUFDQSxJQUFJSyxzQkFBc0I7QUFDekIscUJBQW9CLHlCQUFVQyxJQUFWLEVBQWdCO0FBQ25DLE1BQUlBLFFBQVFBLEtBQUtDLElBQWpCLEVBQXVCO0FBQ3RCRCxVQUFPQSxLQUFLQyxJQUFMLEVBQVA7QUFDQTtBQUNELE1BQUksUUFBUUMsSUFBUixDQUFhRixJQUFiLENBQUosRUFBd0I7QUFDdkJBLFVBQU9BLEtBQUtHLE1BQUwsQ0FBWSxDQUFaLENBQVA7QUFDQTtBQUNELFNBQU9DLEtBQUtDLEtBQUwsQ0FBV0wsSUFBWCxDQUFQO0FBQ0E7O0FBR0Y7OztBQVowQixDQUExQjtJQWVNTSxVOztBQUVMOzs7Ozs7OztBQVFBLHFCQUFhQyxLQUFiLEVBQXNEO0FBQUE7O0FBQUEsTUFBbENDLFdBQWtDLHVFQUFwQixFQUFvQjtBQUFBLE1BQWhCQyxjQUFnQjs7QUFBQTs7QUFDckQsT0FBS0YsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsT0FBS0UsY0FBTCxHQUFzQkEsY0FBdEI7QUFDQSxPQUFLQyxVQUFMLEdBQWtCLENBQWxCO0FBQ0EsT0FBS0MsR0FBTCxHQUFXZixFQUFFZ0IsS0FBRixFQUFYO0FBQ0EsT0FBS0MsTUFBTCxHQUFjLEtBQWQ7QUFDQSxPQUFLQyxHQUFMLEdBQVdDLFNBQVg7QUFDQSxPQUFLQyxHQUFMLEdBQVdELFNBQVg7QUFDQTtBQUNBOztBQUVBLE9BQUtFLEdBQUwsR0FBV1QsWUFBWVUsT0FBdkI7QUFDQSxPQUFLVixXQUFMLEdBQW1CLEVBQW5CO0FBQ0FXLFNBQU9DLElBQVAsQ0FBWVosV0FBWixFQUNFYSxPQURGLENBQ1UsZUFBTztBQUFDLFNBQUtiLFdBQUwsQ0FBaUJjLEdBQWpCLElBQXdCZCxZQUFZYyxHQUFaLENBQXhCO0FBQXlDLEdBRDNEO0FBRUE7Ozs7OEJBRXFDO0FBQUEsa0ZBQUwsRUFBSztBQUFBLE9BQXpCQyxnQkFBeUIsUUFBekJBLGdCQUF5Qjs7QUFFckMsT0FBSVAsTUFBTSxLQUFLQSxHQUFmO0FBQ0EsT0FBSUEsR0FBSixFQUFTO0FBQ1I7QUFDQSxRQUFJUSxVQUFVM0IsTUFBTSxFQUFOLEVBQVVtQixHQUFWLENBQWQ7QUFDQSxRQUFJUSxRQUFRQyxRQUFaLEVBQXNCO0FBQ3JCRCxhQUFRQyxRQUFSLEdBQW1CLEtBQUtDLHlCQUFMLENBQStCRixRQUFRQyxRQUF2QyxFQUFpRCxFQUFFRixrQ0FBRixFQUFqRCxDQUFuQjtBQUNBO0FBQ0Q7O0FBRUQsVUFBTztBQUNOTixTQUFLLEtBQUtBLEdBREo7QUFFTlQsaUJBQWEsS0FBS0EsV0FGWjtBQUdORSxnQkFBWSxLQUFLQSxVQUhYO0FBSU5HLFlBQVEsS0FBS0EsTUFKUDtBQUtOQyxTQUFLLEtBQUtZLHlCQUFMLENBQStCLEtBQUtaLEdBQXBDLEVBQXlDLEVBQUVTLGtDQUFGLEVBQXpDLENBTEM7QUFNTlAsU0FBS1E7QUFOQyxJQUFQO0FBUUE7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0Q0FlMkJWLEcsRUFBOEI7QUFBQSxtRkFBSixFQUFJO0FBQUEsT0FBeEJTLGdCQUF3QixTQUF4QkEsZ0JBQXdCOztBQUN4RCxPQUFJLENBQUNULEdBQUwsRUFBVSxPQUFPQSxHQUFQOztBQUVWLE9BQUlhLFVBQVUsRUFBZDtBQUNBLE9BQUlKLGdCQUFKLEVBQXNCO0FBQ3JCSSxZQUFRQyxJQUFSLEdBQWVkLElBQUljLElBQW5CO0FBQ0EsV0FBT0QsT0FBUDtBQUNBOztBQUVELE9BQUlFLFlBQVksQ0FBQyxDQUFDOUIsb0JBQW9CZSxJQUFJZ0IsSUFBeEIsQ0FBbEI7O0FBRUFYLFVBQU9DLElBQVAsQ0FBWU4sR0FBWixFQUFpQk8sT0FBakIsQ0FBMEIsVUFBQ1UsSUFBRCxFQUFVO0FBQ25DLFFBQUksV0FBV0EsSUFBWCxJQUFtQkYsU0FBdkIsRUFBa0M7QUFDakM7QUFDQUYsYUFBUUssUUFBUixHQUFtQixJQUFuQjtBQUNBLEtBSEQsTUFHTztBQUNOLFNBQUksV0FBV0QsSUFBZixFQUFxQjtBQUNwQjtBQUNBdEMsYUFBT3dDLE9BQVAsa0VBQThFbkIsSUFBSWdCLElBQWxGO0FBQ0E7QUFDREgsYUFBUUksSUFBUixJQUFnQmpCLElBQUlpQixJQUFKLENBQWhCO0FBQ0E7QUFDRCxJQVhEO0FBWUEsVUFBT0osT0FBUDtBQUNBOzs7NEJBRVVPLEssRUFBTzs7QUFFakI7QUFDQTtBQUNBOztBQUVBLE9BQUlsQixNQUFNa0IsTUFBTWxCLEdBQWhCO0FBQ0EsT0FBSUEsR0FBSixFQUFTO0FBQ1JBLFFBQUlTLFFBQUosR0FBZSxLQUFLVSxrQkFBTCxDQUF3Qm5CLElBQUlTLFFBQTVCLENBQWY7QUFDQTs7QUFFRCxRQUFLUixHQUFMLEdBQVdpQixNQUFNakIsR0FBakI7QUFDQSxRQUFLVCxXQUFMLEdBQW1CMEIsTUFBTTFCLFdBQXpCO0FBQ0EsUUFBS0UsVUFBTCxHQUFrQndCLE1BQU14QixVQUF4QjtBQUNBLFFBQUtHLE1BQUwsR0FBY3FCLE1BQU1yQixNQUFwQjtBQUNBLFFBQUtDLEdBQUwsR0FBVyxLQUFLcUIsa0JBQUwsQ0FBd0JELE1BQU1wQixHQUE5QixDQUFYO0FBQ0EsUUFBS0UsR0FBTCxHQUFXQSxHQUFYOztBQUVBOztBQUVBLE9BQUksS0FBS0gsTUFBVCxFQUFpQjtBQUNoQjtBQUNBLFFBQUksS0FBS0MsR0FBVCxFQUFjO0FBQ2IsVUFBS3NCLFdBQUwsQ0FBaUIsS0FBS3RCLEdBQXRCO0FBQ0EsS0FGRCxNQUVPLElBQUksS0FBS0UsR0FBVCxFQUFjO0FBQ3BCLFVBQUtxQixRQUFMLENBQWMsS0FBS3JCLEdBQW5CO0FBQ0E7QUFDRHZCLFdBQU82QyxLQUFQLHlDQUFtRCxLQUFLckIsR0FBeEQ7QUFDQSxJQVJELE1BUU87QUFDTnhCLFdBQU82QyxLQUFQLHFEQUErRCxLQUFLckIsR0FBcEU7QUFDQTtBQUNEOzs7cUNBRW1CSCxHLEVBQUs7QUFDeEIsT0FBSSxDQUFDQSxHQUFMLEVBQVUsT0FBT0EsR0FBUDs7QUFFVixPQUFJQSxJQUFJa0IsUUFBUixFQUFrQjtBQUNqQjtBQUNBOztBQUVBLFFBQUkzQixRQUFRTixvQkFBb0JlLElBQUlnQixJQUF4QixDQUFaO0FBQ0EsUUFBSSxDQUFDekIsS0FBTCxFQUFZO0FBQ1haLFlBQU93QyxPQUFQLG1DQUErQyxLQUFLaEIsR0FBcEQsVUFBNERILElBQUlnQixJQUFoRTtBQUNBO0FBQ0RoQixRQUFJYyxJQUFKLEdBQVd2QixTQUFTUyxJQUFJZCxJQUFiLElBQXFCYyxJQUFJZCxJQUFKLENBQVN1QyxNQUE5QixHQUNSbEMsTUFBTVMsSUFBSWQsSUFBVixDQURRLEdBRVIsSUFGSDtBQUdBLFdBQU9jLElBQUlrQixRQUFYO0FBQ0E7O0FBRUQsVUFBT2xCLEdBQVA7QUFDQTs7OzhCQUVZQSxHLEVBQUs7QUFDakI7O0FBRUEsT0FBSSxLQUFKLEVBQVU7O0FBRVQ7QUFDQTtBQUNBQSxVQUFNLEtBQUswQixpQkFBTCxDQUF1QjFCLEdBQXZCLENBQU47QUFDQTs7QUFFRDtBQUNBLFFBQUtBLEdBQUwsR0FBY0EsR0FBZDtBQUNBLFFBQUtELE1BQUwsR0FBYyxJQUFkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUtGLEdBQUwsQ0FBUzhCLE9BQVQsQ0FBaUJyQyxLQUFLc0MsU0FBTCxDQUFlNUIsR0FBZixDQUFqQjtBQUNBOzs7MkJBRVNFLEcsRUFBSzs7QUFFZCxPQUFJLEtBQUosRUFBVzs7QUFFVjtBQUNBO0FBQ0EsUUFBSUEsT0FBT0EsSUFBSVMsUUFBZixFQUF5QjtBQUN4QlQsU0FBSVMsUUFBSixHQUFlLEtBQUtlLGlCQUFMLENBQXVCeEIsSUFBSVMsUUFBM0IsQ0FBZjtBQUNBO0FBQ0Q7O0FBRUQsUUFBS1QsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsUUFBS0gsTUFBTCxHQUFjLElBQWQ7O0FBRUEsT0FBSSxLQUFKLEVBQVc7QUFDVjtBQUNBO0FBQ0FHLFVBQU1aLEtBQUtDLEtBQUwsQ0FBV0QsS0FBS3NDLFNBQUwsQ0FBZTFCLEdBQWYsQ0FBWCxDQUFOO0FBQ0E7O0FBRUQsUUFBS0wsR0FBTCxDQUFTZ0MsTUFBVCxDQUFnQjNCLEdBQWhCO0FBQ0E7OztnQ0FFYUwsRyxFQUFLO0FBQ2xCLFVBQU9BLElBQUlpQyxPQUFKLENBQVlDLElBQVosQ0FBaUI7QUFBQSxXQUFPekMsS0FBS0MsS0FBTCxDQUFXeUMsR0FBWCxDQUFQO0FBQUEsSUFBakIsQ0FBUDtBQUNBOzs7a0NBRWdCO0FBQ2hCLE9BQUksS0FBSixFQUFXO0FBQ1Y7QUFDQTtBQUNBLFNBQUtwQyxVQUFMLElBQW1CLENBQW5CO0FBQ0EsV0FBTyxLQUFLcUMsYUFBTCxDQUFtQixLQUFLcEMsR0FBeEIsQ0FBUDtBQUNBLElBTEQsTUFLTztBQUNOO0FBQ0E7QUFDQTtBQUNBLFdBQU8sS0FBS3FDLDZCQUFMLENBQW1DLEtBQUtyQyxHQUF4QyxDQUFQO0FBQ0E7QUFDRDs7QUFFRDs7OzswQ0FDeUI7QUFDeEIsVUFBTyxLQUFLQSxHQUFMLENBQVNpQyxPQUFoQjtBQUNBOzs7d0NBRXNCO0FBQ3RCbkQsVUFBTzZDLEtBQVAsQ0FBYSxtQkFBbUIsS0FBS3JCLEdBQXJDO0FBQ0EsUUFBS1AsVUFBTCxJQUFtQixDQUFuQjs7QUFFQSxPQUFJLEtBQUtBLFVBQUwsS0FBb0IsQ0FBeEIsRUFBMkI7QUFDMUIsU0FBS0gsS0FBTCxDQUFXMEMsWUFBWCxDQUF3QixJQUF4QjtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Z0RBSStCdEMsRyxFQUFLO0FBQUE7O0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFVBQU8sS0FBS29DLGFBQUwsQ0FBbUJwQyxHQUFuQixFQUF3QnVDLEdBQXhCLENBQTZCLG9CQUFZO0FBQy9DLFdBQUtDLG1CQUFMO0FBQ0EsV0FBT0MsUUFBUDtBQUNBLElBSE0sQ0FBUDtBQUlBOzs7bUNBRWlCNUMsVyxFQUFhO0FBQzlCLE9BQUk2QyxVQUFVN0MsV0FBZDtBQUNBLE9BQUk4QyxPQUFPLEtBQUs5QyxXQUFoQjs7QUFFQSxZQUFTK0MsSUFBVCxDQUFjQyxRQUFkLEVBQXdCO0FBQ3ZCLFdBQU8xRCxRQUFRd0QsS0FBS0UsUUFBTCxDQUFSLEVBQXdCSCxRQUFRRyxRQUFSLENBQXhCLENBQVA7QUFDQTs7QUFFRDtBQUNBO0FBQ0EsVUFBT0QsS0FBSyxTQUFMLEtBQ0hBLEtBQUssUUFBTCxDQURHLElBRUhBLEtBQUssTUFBTCxDQUZHLElBR0hBLEtBQUssYUFBTCxDQUhHLElBSUhBLEtBQUssWUFBTCxDQUpKO0FBS0E7O0FBRUQ7QUFDQTs7OztvQ0FDbUJ6QyxHLEVBQUs7QUFDdkIsT0FBSTJDLFNBQVMsRUFBYjtBQUNBLElBQ0MsTUFERCxFQUVDLE1BRkQsRUFHQyxNQUhEOztBQUtDLGNBTEQsQ0FLYTs7QUFFWixpQkFQRCxDQU9nQjtBQUNmLFdBUkQsRUFTQyxZQVRELEVBVUMsTUFWRCxFQVdDLElBWEQsRUFZQyxhQVpELEVBYUMsYUFiRCxFQWNDLE9BZEQsRUFnQkMsVUFoQkQsRUFpQkMsV0FqQkQsRUFrQkMsWUFsQkQsRUFtQkMsY0FuQkQsRUFvQkMsZUFwQkQsRUFxQkMsVUFyQkQsRUFzQkMsV0F0QkQsRUF1QkVwQyxPQXZCRixDQXVCVyxnQkFBUTtBQUNsQm9DLFdBQU8xQixJQUFQLElBQWVqQixJQUFJaUIsSUFBSixDQUFmO0FBQ0EsSUF6QkQ7QUEwQkEsT0FBSSxLQUFLdEIsY0FBVCxFQUF5QjtBQUN4QixTQUFLQSxjQUFMLENBQW9CWSxPQUFwQixDQUE2QixnQkFBUTtBQUNwQ29DLFlBQU8xQixJQUFQLElBQWVqQixJQUFJaUIsSUFBSixDQUFmO0FBQ0EsS0FGRDtBQUdBOztBQUVELFVBQU8wQixNQUFQO0FBQ0E7Ozs7OztBQUtGOzs7Ozs7O0lBS01DLGdCO0FBRUwsNkJBQWU7QUFBQTs7QUFDZDs7O0FBR0EsT0FBS0MsU0FBTCxHQUFpQixFQUFqQjtBQUNBOzs7OzhCQUV5QztBQUFBLG1GQUFKLEVBQUk7QUFBQSxxQ0FBOUJwQyxnQkFBOEI7QUFBQSxPQUE5QkEsZ0JBQThCLHlDQUFiLEtBQWE7O0FBRXpDLE9BQUlxQyxNQUFNO0FBQ1RELGVBQVc7QUFERixJQUFWOztBQUlBLE9BQUlBLFlBQVksS0FBS0EsU0FBckI7QUFDQXhDLFVBQU9DLElBQVAsQ0FBWXVDLFNBQVosRUFBdUJ0QyxPQUF2QixDQUErQixlQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFFBQUl3QyxvQkFDSEYsVUFBVTFDLEdBQVYsRUFBZTZDLEdBQWYsQ0FBbUI7QUFBQSxZQUFTQyxNQUFNQyxTQUFOLENBQWdCLEVBQUV6QyxrQ0FBRixFQUFoQixDQUFUO0FBQUEsS0FBbkIsQ0FERDtBQUVBcUMsUUFBSUQsU0FBSixDQUFjMUMsR0FBZCxJQUFxQjRDLGtCQUFrQnRCLE1BQWxCLEtBQTZCLENBQTdCLEdBQWlDc0Isa0JBQWtCLENBQWxCLENBQWpDLEdBQXdEQSxpQkFBN0U7QUFFQSxJQVJEOztBQVVBLFVBQU9ELEdBQVA7QUFDQTs7OzRCQUVVMUIsSyxFQUFPO0FBQUE7O0FBRWpCekMsVUFBTzZDLEtBQVAsQ0FBYSw4QkFBYjs7QUFFQTtBQUNBLE9BQUlxQixZQUFZLEtBQUtBLFNBQUwsR0FBaUIsRUFBakM7O0FBRUF4QyxVQUFPQyxJQUFQLENBQVljLE1BQU15QixTQUFsQixFQUE2QnRDLE9BQTdCLENBQXFDLGVBQU87O0FBRTNDLFFBQUk0QyxVQUFVL0IsTUFBTXlCLFNBQU4sQ0FBZ0IxQyxHQUFoQixDQUFkO0FBQ0E7QUFDQTtBQUNBZ0QsY0FBVUMsTUFBTUMsT0FBTixDQUFjRixPQUFkLElBQXlCQSxPQUF6QixHQUFtQyxDQUFDQSxPQUFELENBQTdDO0FBQ0FOLGNBQVUxQyxHQUFWLElBQWlCZ0QsUUFBUUgsR0FBUixDQUFZLHFCQUFhO0FBQ3pDLFNBQUlNLFdBQVcsSUFBSTlELFVBQUosUUFBZjtBQUNBOEQsY0FBU0MsU0FBVCxDQUFtQkMsU0FBbkI7QUFDQSxZQUFPRixRQUFQO0FBQ0EsS0FKZ0IsQ0FBakI7QUFLQSxJQVhEO0FBYUE7O0FBRUQ7Ozs7Ozs7Ozs7d0JBT081RCxXLEVBQTJEO0FBQUEsT0FBOUMrRCxlQUE4Qyx1RUFBNUIsS0FBNEI7QUFBQSxPQUFyQjlELGNBQXFCLHVFQUFKLEVBQUk7O0FBQ2pFLE9BQUksQ0FBQ0QsWUFBWVUsT0FBakIsRUFBMEI7QUFDekIsVUFBTSxJQUFJc0QsS0FBSixDQUFVLDZCQUFWLENBQU47QUFDQTs7QUFFRC9FLFVBQU82QyxLQUFQLDREQUFzRTlCLFlBQVlVLE9BQWxGOztBQUVBLE9BQUl1RCxhQUFhLEtBQUtDLFVBQUwsQ0FBZ0JsRSxXQUFoQixDQUFqQjtBQUNBLE9BQUksQ0FBQ2lFLFVBQUQsSUFBZUYsZUFBbkIsRUFBb0M7QUFDbkNFLGlCQUFhLEtBQUtFLFNBQUwsQ0FBZW5FLFdBQWYsRUFBNEJDLGNBQTVCLENBQWI7QUFDQTs7QUFFRCxVQUFPZ0UsVUFBUDtBQUNBOzs7NkJBRVdqRSxXLEVBQWE7QUFDeEIsT0FBSVUsVUFBVVYsWUFBWVUsT0FBMUI7QUFDQSxPQUFJK0MsVUFBVSxLQUFLTixTQUFMLENBQWV6QyxPQUFmLEtBQTJCLEVBQXpDO0FBQ0E7QUFDQSxRQUFLLElBQUkwRCxJQUFJLENBQWIsRUFBZ0JBLElBQUlYLFFBQVExQixNQUE1QixFQUFvQ3FDLEdBQXBDLEVBQXlDO0FBQ3hDLFFBQUliLFFBQVFFLFFBQVFXLENBQVIsQ0FBWjtBQUNBLFFBQUliLE1BQU1jLGdCQUFOLENBQXVCckUsV0FBdkIsQ0FBSixFQUF5QztBQUN4QyxZQUFPdUQsS0FBUDtBQUNBO0FBQ0Q7QUFDRCxVQUFPLElBQVA7QUFDQTs7QUFFRDs7Ozs7Ozs7Ozs7NEJBUVd2RCxXLEVBQWFDLGMsRUFBZ0I7QUFDdkMsT0FBSVMsVUFBVVYsWUFBWVUsT0FBMUI7QUFBQSxPQUNDK0MsVUFBVSxLQUFLTixTQUFMLENBQWV6QyxPQUFmLE1BQTRCLEtBQUt5QyxTQUFMLENBQWV6QyxPQUFmLElBQTBCLEVBQXRELENBRFg7QUFBQSxPQUVDa0QsV0FBVyxJQUFJOUQsVUFBSixDQUFlLElBQWYsRUFBcUJFLFdBQXJCLEVBQWtDQyxjQUFsQyxDQUZaO0FBR0F3RCxXQUFRYSxJQUFSLENBQWFWLFFBQWI7QUFDQSxVQUFPQSxRQUFQO0FBQ0E7OzsrQkFFYUwsSyxFQUFPO0FBQ3BCLE9BQUk3QyxVQUFVNkMsTUFBTXZELFdBQU4sQ0FBa0JVLE9BQWhDO0FBQUEsT0FDQytDLFVBQVUsS0FBS04sU0FBTCxDQUFlekMsT0FBZixDQURYO0FBQUEsT0FFQzZELE1BQU1kLFFBQVFlLE9BQVIsQ0FBZ0JqQixLQUFoQixDQUZQO0FBR0EsT0FBSWdCLE9BQU8sQ0FBWCxFQUFjO0FBQ2JkLFlBQVFnQixNQUFSLENBQWVGLEdBQWYsRUFBb0IsQ0FBcEI7QUFDQTtBQUNELFFBQUtHLGtCQUFMO0FBQ0E7OztxQ0FFbUI7QUFDbkIsUUFBS0Msa0JBQUwsR0FBMEI5RCxPQUExQixDQUFrQyxlQUFPO0FBQUMrRCxRQUFJckIsS0FBSixDQUFVc0IsSUFBVixHQUFpQixJQUFqQjtBQUFzQixJQUFoRTtBQUNBOzs7b0NBRWtCO0FBQ2xCLFVBQU8sS0FBS0MsY0FBTCxHQUFzQkMsTUFBdEIsQ0FBNkI7QUFBQSxXQUFPSCxJQUFJckIsS0FBSixDQUFVc0IsSUFBakI7QUFBQSxJQUE3QixDQUFQO0FBQ0E7Ozt1Q0FFcUI7QUFDckIsVUFBTyxLQUFLQyxjQUFMLEdBQXNCQyxNQUF0QixDQUE2QjtBQUFBLFdBQU8sQ0FBQ0gsSUFBSXJCLEtBQUosQ0FBVWxELE1BQWxCO0FBQUEsSUFBN0IsQ0FBUDtBQUNBOzs7bUNBRWdCO0FBQUE7O0FBQ2hCLE9BQUkyRSxNQUFNLEVBQVY7QUFDQXJFLFVBQU9DLElBQVAsQ0FBWSxLQUFLdUMsU0FBakIsRUFBNEJ0QyxPQUE1QixDQUFvQyxlQUFPO0FBQzFDLFdBQUtzQyxTQUFMLENBQWUxQyxHQUFmLEVBQW9CSSxPQUFwQixDQUE0QixpQkFBUztBQUNwQ21FLFNBQUlWLElBQUosQ0FBUyxFQUFFN0QsUUFBRixFQUFPOEMsWUFBUCxFQUFUO0FBQ0EsS0FGRDtBQUdBLElBSkQ7QUFLQSxVQUFPeUIsR0FBUDtBQUNBOzs7MENBRXdCO0FBQ3hCLE9BQUlDLFdBQVcsS0FBS0gsY0FBTCxHQUFzQnhCLEdBQXRCLENBQTBCO0FBQUEsV0FBT3NCLElBQUlyQixLQUFKLENBQVVwRCxHQUFWLENBQWNpQyxPQUFyQjtBQUFBLElBQTFCLENBQWY7QUFDQSxVQUFPaEQsRUFBRThGLFVBQUYsQ0FBYUQsUUFBYixDQUFQO0FBQ0E7O0FBRUQ7Ozs7OztzQ0FHcUI7QUFDcEIsUUFBS0Usb0JBQUwsR0FBNEIsS0FBS0Esb0JBQUwsSUFBNkIvRixFQUFFZ0IsS0FBRixFQUF6RDs7QUFFQSxRQUFLc0Usa0JBQUw7O0FBRUEsVUFBTyxLQUFLUyxvQkFBTCxDQUEwQi9DLE9BQWpDO0FBQ0E7Ozt1Q0FFb0I7QUFDcEJuRCxVQUFPNkMsS0FBUCxDQUFhLHFCQUFiO0FBQ0EsT0FBSSxLQUFLcUQsb0JBQVQsRUFBK0I7QUFDOUIsUUFBSUMseUJBQXlCLENBQTdCO0FBQ0EsU0FBS04sY0FBTCxHQUFzQmpFLE9BQXRCLENBQThCLGVBQU87QUFDcEMsU0FBSStELElBQUlyQixLQUFKLENBQVVsRCxNQUFkLEVBQXNCO0FBQ3JCK0UsZ0NBQTBCUixJQUFJckIsS0FBSixDQUFVckQsVUFBcEM7QUFDQTtBQUNELEtBSkQ7QUFLQWpCLFdBQU82QyxLQUFQLHdDQUFrRHNELHNCQUFsRDtBQUNBLFFBQUlBLDJCQUEyQixDQUEvQixFQUFrQyxLQUFLRCxvQkFBTCxDQUEwQmxELE9BQTFCO0FBQ2xDO0FBQ0Q7Ozs4QkFFWXhCLEcsRUFBSzRFLGUsRUFBaUI7QUFDbENwRyxVQUFPNkMsS0FBUCx1QkFBaUNyQixHQUFqQztBQUNBLE9BQUk4QyxRQUFRLEtBQUtXLFVBQUwsQ0FBZ0JtQixnQkFBZ0JyRixXQUFoQyxDQUFaO0FBQ0EsT0FBSXVELEtBQUosRUFBVztBQUNWQSxVQUFNTSxTQUFOLENBQWdCd0IsZUFBaEI7QUFDQSxJQUZELE1BRU87QUFDTnBHLFdBQU82QyxLQUFQLENBQWEsTUFBYjtBQUNBO0FBQ0Q7Ozs7OztBQUlGd0QsT0FBT0MsT0FBUCxHQUFpQnJDLGdCQUFqQiIsImZpbGUiOiJSZWFjdFNlcnZlckFnZW50L0NhY2hlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgbG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2luZycpLmdldExvZ2dlcih7XCJuYW1lXCI6XCJyZWFjdC1zZXJ2ZXIuY29yZS5SZWFjdFNlcnZlckFnZW50LkNhY2hlXCIsXCJjb2xvclwiOntcInNlcnZlclwiOjYzLFwiY2xpZW50XCI6XCJyZ2IoNDIsNDIsMjEyKVwifX0pXG4sXHRRID0gcmVxdWlyZSgncScpXG4sXHRtZXJnZSA9IHJlcXVpcmUoXCJsb2Rhc2gvbWVyZ2VcIilcbixcdGlzRXF1YWwgPSByZXF1aXJlKFwibG9kYXNoL2lzRXF1YWxcIilcbjtcblxuLy8gVE9ETzogd2Ugc2hvdWxkIGZpZ3VyZSBvdXQgYSB3YXkgdG8gY29uc29saWRhdGUgdGhpcyB3aXRoIFN1cGVyQWdlbnRFeHRlbmRlclxudmFyIHJlc3BvbnNlQm9keVBhcnNlcnMgPSB7XG5cdCdhcHBsaWNhdGlvbi9qc29uJzogZnVuY3Rpb24gKHRleHQpIHtcblx0XHRpZiAodGV4dCAmJiB0ZXh0LnRyaW0pIHtcblx0XHRcdHRleHQgPSB0ZXh0LnRyaW0oKTtcblx0XHR9XG5cdFx0aWYgKC9ee30mJi8udGVzdCh0ZXh0KSkge1xuXHRcdFx0dGV4dCA9IHRleHQuc3Vic3RyKDQpO1xuXHRcdH1cblx0XHRyZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcblx0fSxcbn1cblxuLyoqXG4gKiBBbiBlbnRyeSBpbiB0aGUgUmVxdWVzdERhdGFDYWNoZVxuICovXG5jbGFzcyBDYWNoZUVudHJ5IHtcblxuXHQvKipcblx0ICogQHBhcmFtIGNhY2hlIFtyZXF1aXJlZF0gdGhlIFJlcXVlc3REYXRhQ2FjaGUgaW5zdGFuY2UgdGhhdCBvd25zIHRoaXNcblx0ICogICAgICAgIGBDYWNoZUVudHJ5YC5cblx0ICogQHBhcmFtIHJlcXVlc3REYXRhIGEgcmVxdWVzdCBkYXRhIGRlc2NyaXB0b3IuIFdvbid0IGJlIHBhc3NlZCBpZiB0aGlzXG5cdCAqICAgICAgICBDYWNoZUVudHJ5IGlzIGluIHRoZSBwcm9jZXNzIG9mIGJlaW5nIHJlaHlkcmF0ZWRcblx0ICogQHBhcmFtIGNhY2hlV2hpdGVMaXN0IFtvcHRpb25hbF0gdGhlIHdoaXRlbGlzdCBvZiByZXBzb25zZSBmaWVsZHMgdGhhdFxuXHQgKiAgICAgICAgd2lsbCBiZSBzZXJpYWxpemVkIHdpdGggdGhpcyBlbnRyeS4gTm90IHBhc3NlZCB3aGVuIHJlaHlkcmF0aW5nLlxuXHQgKi9cblx0Y29uc3RydWN0b3IgKGNhY2hlLCByZXF1ZXN0RGF0YSA9IHt9LCBjYWNoZVdoaXRlbGlzdCkge1xuXHRcdHRoaXMuY2FjaGUgPSBjYWNoZTtcblx0XHR0aGlzLmNhY2hlV2hpdGVsaXN0ID0gY2FjaGVXaGl0ZWxpc3Q7XG5cdFx0dGhpcy5yZXF1ZXN0ZXJzID0gMDtcblx0XHR0aGlzLmRmZCA9IFEuZGVmZXIoKTtcblx0XHR0aGlzLmxvYWRlZCA9IGZhbHNlO1xuXHRcdHRoaXMucmVzID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZXJyID0gdW5kZWZpbmVkO1xuXHRcdC8vIGNvcHkgdGhlIHJlc3Qgb2YgdGhlIHByb3BlcnRpZXMgZnJvbSBpbnB1dCByZXF1ZXN0RGF0YVxuXHRcdC8vIHRvIHRoaXMucmVxdWVzdERhdGFcblxuXHRcdHRoaXMudXJsID0gcmVxdWVzdERhdGEudXJsUGF0aDtcblx0XHR0aGlzLnJlcXVlc3REYXRhID0ge307XG5cdFx0T2JqZWN0LmtleXMocmVxdWVzdERhdGEpXG5cdFx0XHQuZm9yRWFjaChrZXkgPT4ge3RoaXMucmVxdWVzdERhdGFba2V5XSA9IHJlcXVlc3REYXRhW2tleV19KTtcblx0fVxuXG5cdGRlaHlkcmF0ZSAoIHtyZXNwb25zZUJvZHlPbmx5fSA9IHt9ICkge1xuXG5cdFx0dmFyIGVyciA9IHRoaXMuZXJyO1xuXHRcdGlmIChlcnIpIHtcblx0XHRcdC8vIGNyZWF0ZSBhIHNoYWxsb3cgY29weSBvZiB0aGUgZXJyb3Igb2JqZWN0XG5cdFx0XHR2YXIgZXJyQ29weSA9IG1lcmdlKHt9LCBlcnIpO1xuXHRcdFx0aWYgKGVyckNvcHkucmVzcG9uc2UpIHtcblx0XHRcdFx0ZXJyQ29weS5yZXNwb25zZSA9IHRoaXMuX2NvcHlSZXNwb25zZUZvckRlaHlkcmF0ZShlcnJDb3B5LnJlc3BvbnNlLCB7IHJlc3BvbnNlQm9keU9ubHkgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHVybDogdGhpcy51cmwsXG5cdFx0XHRyZXF1ZXN0RGF0YTogdGhpcy5yZXF1ZXN0RGF0YSxcblx0XHRcdHJlcXVlc3RlcnM6IHRoaXMucmVxdWVzdGVycyxcblx0XHRcdGxvYWRlZDogdGhpcy5sb2FkZWQsXG5cdFx0XHRyZXM6IHRoaXMuX2NvcHlSZXNwb25zZUZvckRlaHlkcmF0ZSh0aGlzLnJlcywgeyByZXNwb25zZUJvZHlPbmx5IH0pLFxuXHRcdFx0ZXJyOiBlcnJDb3B5LFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogX2NvcHlSZXNwb25zZUZvckRlaHlkcmF0ZSBhdHRlbXB0cyB0byBjb25zdHJ1Y3QgYSBjYW5vbmljYWwgZm9ybSBvZiB0aGUgcmVzcG9uc2Ugb2JqZWN0XG5cdCAqIHRoYXQgY2FuIGJlIHVzZWQgbGF0ZXIgdG8gcmVjb25zdHJ1Y3QgaXQuIEl0cyBwcmltYXJ5IGdvYWwgaXMgdG8gYXZvaWQgZHVwbGljYXRpb24gb2Zcblx0ICogdGhlIHJlc3BvbnNlIGJvZHkgaW4gYm90aCB0aGUgYC50ZXh0YCBhbmQgYC5ib2R5YCBwcm9wZXJ0aWVzIG9mIHRoZSBjYWNoZWQgcmVzcG9uc2Ugb2JqZWN0LlxuXHQgKlxuXHQgKiBUaGVyZSBhcmUgc2V2ZXJhbCB3YXlzIHRoaXMgY291bGQgaGF2ZSBiZWVuIGhhbmRsZWQsIGJ1dCB0aGUgcHVyZXN0IHdheSAoYXMgb2YgcmlnaHQgbm93KVxuXHQgKiBmcm9tIHRoZSBzdGFuZHBvaW50IG9mIHRoZSBBUEkgYXBwZWFycyB0byBiZSB0byBwcm92aWRlIHBhcnNpbmcgZnVuY3Rpb25zIGZvciBrbm93blxuXHQgKiByZXNwb25zZSB0eXBlcyAoZS5nLiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpLiBJZiB0aGUgcmVzcG9uc2UgY29udGVudC10eXBlIGlzIGtub3duLCB3ZSdsbFxuXHQgKiBzaW1wbHkgc2VyaWFsaXplIGEgcGxhY2Vob2xkZXIgKGBfaGFzQm9keWApIGluZGljYXRpbmcgdGhhdCB3ZSBzaG91bGQgdHJ5IHRvIHJlcGFyc2UgdGhlXG5cdCAqIGJvZHkgZnJvbSB0aGUgcmVzcG9uc2UgdGV4dCB3aGVuIHJlaHlkcmF0aW5nLiBJZiB0aGVyZSBpcyBhIHBhcnNlZCBib2R5IG9uIHRoZSByZXNwb25zZSBhdFxuXHQgKiB0aGUgdGltZSBvZiBkZWh5ZHJhdGluZyBhbmQgd2UgKmRvbid0KiByZWNvZ25pemUgdGhlIHJlc3BvbnNlIHR5cGUsIHdlJ2xsIHNlcmlhbGl6ZSBib3RoXG5cdCAqIGAudGV4dGAgYW5kIGAuYm9keWAsIHBheWluZyBhIHBlbmFsdHkgaW4gcmVzcG9uc2Ugc2l6ZSwgYnV0IGd1YXJhbnRlZWluZyBjb3JyZWN0bmVzcy5cblx0ICogKFdlJ2xsIGFsc28gbG9nIGEgd2FybmluZyBzYXlpbmcgdGhhdCB3ZSBzaG91bGQgcHJvYmFibHkgYWRkIGFub3RoZXIgcmVzcG9uc2UgdHlwZSkuXG5cdCAqXG5cdCAqL1xuXHRfY29weVJlc3BvbnNlRm9yRGVoeWRyYXRlIChyZXMsIHtyZXNwb25zZUJvZHlPbmx5fSA9IHt9KSB7XG5cdFx0aWYgKCFyZXMpIHJldHVybiByZXM7XG5cblx0XHR2YXIgcmVzQ29weSA9IHt9O1xuXHRcdGlmIChyZXNwb25zZUJvZHlPbmx5KSB7XG5cdFx0XHRyZXNDb3B5LmJvZHkgPSByZXMuYm9keTtcblx0XHRcdHJldHVybiByZXNDb3B5O1xuXHRcdH1cblxuXHRcdHZhciBwYXJzZWFibGUgPSAhIXJlc3BvbnNlQm9keVBhcnNlcnNbcmVzLnR5cGVdO1xuXG5cdFx0T2JqZWN0LmtleXMocmVzKS5mb3JFYWNoKCAocHJvcCkgPT4ge1xuXHRcdFx0aWYgKFwiYm9keVwiID09PSBwcm9wICYmIHBhcnNlYWJsZSkge1xuXHRcdFx0XHQvLyBkb24ndCBjb3B5IGJvZHkgaWYgaXQncyBhIHdlbGwta25vd24gKGVhc2lseS1wYXJzZWQpIGNvbnRlbnQtdHlwZVxuXHRcdFx0XHRyZXNDb3B5Ll9oYXNCb2R5ID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChcImJvZHlcIiA9PT0gcHJvcCkge1xuXHRcdFx0XHRcdC8vICdwYXJzZWFibGUnIG11c3QgYmUgZmFsc2UuIHdlIHNob3VsZCBsb2cgYSB3YXJuaW5nXG5cdFx0XHRcdFx0bG9nZ2VyLndhcm5pbmcoYFJlYWN0U2VydmVyQWdlbnQgbmVlZHMgcmVzcG9uc2VCb2R5UGFyc2VyIGZvciBjb250ZW50LXR5cGU6ICR7cmVzLnR5cGV9IHRvIGF2b2lkIGR1cGxpY2F0aW5nIGRhdGEgaW4gY2FjaGUgYm9keWApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc0NvcHlbcHJvcF0gPSByZXNbcHJvcF07XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHJlc0NvcHk7XG5cdH1cblxuXHRyZWh5ZHJhdGUgKHN0YXRlKSB7XG5cblx0XHQvLyBOT1RFOiByZWh5ZHJhdGUgd2lsbCBiZSBjYWxsZWQgX1RXSUNFXyBmb3IgbGF0ZSBhcnJpdmFsczpcblx0XHQvLyBvbmNlIGluaXRpYWxseSwgd2hlbiBub3QgbG9hZGVkLCBhbmQgb25jZSBhZ2FpbiB3aGVuXG5cdFx0Ly8gdGhlIHJlcXVlc3QgYXJyaXZlc1xuXG5cdFx0dmFyIGVyciA9IHN0YXRlLmVycjtcblx0XHRpZiAoZXJyKSB7XG5cdFx0XHRlcnIucmVzcG9uc2UgPSB0aGlzLl9yZWh5ZHJhdGVSZXNwb25zZShlcnIucmVzcG9uc2UpO1xuXHRcdH1cblxuXHRcdHRoaXMudXJsID0gc3RhdGUudXJsO1xuXHRcdHRoaXMucmVxdWVzdERhdGEgPSBzdGF0ZS5yZXF1ZXN0RGF0YTtcblx0XHR0aGlzLnJlcXVlc3RlcnMgPSBzdGF0ZS5yZXF1ZXN0ZXJzO1xuXHRcdHRoaXMubG9hZGVkID0gc3RhdGUubG9hZGVkO1xuXHRcdHRoaXMucmVzID0gdGhpcy5fcmVoeWRyYXRlUmVzcG9uc2Uoc3RhdGUucmVzKTtcblx0XHR0aGlzLmVyciA9IGVycjtcblxuXHRcdC8vIFRPRE8gRklYTUU6IHRoZXNlIHdvbid0IHdvcmsgaWYgdGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciB3YXMgYW4gZXJyb3JcblxuXHRcdGlmICh0aGlzLmxvYWRlZCkge1xuXHRcdFx0Ly8gY2FsbCBzZXRSZXNwb25zZSB0byByZXNvbHZlIHRoZSBkZWZlcnJlZFxuXHRcdFx0aWYgKHRoaXMucmVzKSB7XG5cdFx0XHRcdHRoaXMuc2V0UmVzcG9uc2UodGhpcy5yZXMpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmVycikge1xuXHRcdFx0XHR0aGlzLnNldEVycm9yKHRoaXMuZXJyKTtcblx0XHRcdH1cblx0XHRcdGxvZ2dlci5kZWJ1ZyhgUmVoeWRyYXRpbmcgcmVzb2x2ZWQgdXJsIHRvIGNhY2hlOiAke3RoaXMudXJsfWApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoYFJlaHlkcmF0aW5nIHBlbmRpbmcgdXJsIHRvIGNhY2hlIHdpdGhvdXQgZGF0YTogJHt0aGlzLnVybH1gKTtcblx0XHR9XG5cdH1cblxuXHRfcmVoeWRyYXRlUmVzcG9uc2UgKHJlcykge1xuXHRcdGlmICghcmVzKSByZXR1cm4gcmVzO1xuXG5cdFx0aWYgKHJlcy5faGFzQm9keSkge1xuXHRcdFx0Ly8gcmUtcGFyc2UgdGhlIHRleHQgb2YgdGhlIHJlc3BvbnNlIGJvZHkgc2VyaWFsaXplZCBieSB0aGUgc2VydmVyLlxuXHRcdFx0Ly8gaWYgdGhlIGJvZHkgd2Fzbid0IGluIGEga25vd24gZm9ybWF0LCBpdCB3aWxsIGhhdmUgYmVlbiBpbmNsdWRlZCBkaXJlY3RseVxuXG5cdFx0XHR2YXIgcGFyc2UgPSByZXNwb25zZUJvZHlQYXJzZXJzW3Jlcy50eXBlXTtcblx0XHRcdGlmICghcGFyc2UpIHtcblx0XHRcdFx0bG9nZ2VyLndhcm5pbmcoYFVucGFyc2VhYmxlIGNvbnRlbnQgdHlwZSBmb3IgJHt0aGlzLnVybH06ICR7cmVzLnR5cGV9LCBidXQgcmVzcG9uc2UuX2hhc0JvZHkgd2FzIHRydWUuIChUaGlzIG1heSBiZSBhIGJ1ZyBpbiBSZWFjdFNlcnZlckFnZW50KWApO1xuXHRcdFx0fVxuXHRcdFx0cmVzLmJvZHkgPSBwYXJzZSAmJiByZXMudGV4dCAmJiByZXMudGV4dC5sZW5ndGhcblx0XHRcdFx0PyBwYXJzZShyZXMudGV4dClcblx0XHRcdFx0OiBudWxsO1xuXHRcdFx0ZGVsZXRlIHJlcy5faGFzQm9keTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzO1xuXHR9XG5cblx0c2V0UmVzcG9uc2UgKHJlcykge1xuXHRcdC8vIFRPRE86IHN0b3JlIHN1cGVyYWdlbnQgcmVzcG9uc2U/IG9yIGJvZHk/IG9yIHBheWxvYWQ/XG5cblx0XHRpZiAoZmFsc2Upe1xuXG5cdFx0XHQvLyBQdWxsIG91dCB0aGUgcGllY2VzIG9mIHRoZSByZXNwb25zZSB3ZSBjYXJlIGFib3V0LlxuXHRcdFx0Ly8gVGhpcyB3b3VsZCBiZSBhIE5PT1AgY2xpZW50LXNpZGUsIHNvIHdlJ2xsIHNraXAgaXQuXG5cdFx0XHRyZXMgPSB0aGlzLl90cmltUmVzcG9uc2VEYXRhKHJlcyk7XG5cdFx0fVxuXG5cdFx0Ly8gU3Rhc2ggYXdheSBhIHJlZmVyZW5jZSB0byB0aGUgcmVzcG9uc2UuXG5cdFx0dGhpcy5yZXMgICAgPSByZXM7XG5cdFx0dGhpcy5sb2FkZWQgPSB0cnVlO1xuXG5cdFx0Ly8gUmVzb2x2ZSB3aXRoIGEgc2VyaWFsaXplZCBjb3B5LiAgV2UnbGwgdW5zZXJpYWxpemUgZm9yIGVhY2hcblx0XHQvLyByZXF1ZXN0ZXIuICBUaGlzIHdheSB3ZSBwcm92aWRlIGEgZnJlc2ggY29weSBlYWNoIHRpbWUgc28gbXV0YXRpb25zXG5cdFx0Ly8gZG9uJ3QgbGVhay5cblx0XHQvL1xuXHRcdC8vIFRoaXMgYWxzbyBsZWF2ZXMgX3VzXyB3aXRoIGEgY2xlYW4gY29weSBvZiB0aGUgb3JpZ2luYWwgcmVzcG9uc2UuXG5cdFx0Ly8gVGhpcyBpcyBpbXBvcnRhbnQgdG8gZW5zdXJlIHRoYXQgd2UgcHJvdmlkZSB0aGUgc2FtZSBkYXRhIGZyb20gdGhlXG5cdFx0Ly8gY2FjaGUgd2hlbiB3ZSB3YWtlIHVwIGluIHRoZSBicm93c2VyIGFzIHdlIGluaXRpYWxseSBwcm92aWRlIG9uIHRoZVxuXHRcdC8vIHNlcnZlci5cblx0XHQvL1xuXHRcdHRoaXMuZGZkLnJlc29sdmUoSlNPTi5zdHJpbmdpZnkocmVzKSk7XG5cdH1cblxuXHRzZXRFcnJvciAoZXJyKSB7XG5cblx0XHRpZiAoZmFsc2UpIHtcblxuXHRcdFx0Ly8gSWYgdGhlIGVycm9yIHdhcyBjYXVzZWQgYnkgYSBzZXJ2ZXIgcmVzcG9uc2UsIHRyaW0gaXRcblx0XHRcdC8vIGFuZCBzZXJpYWxpemUgaXQgbGlrZSBhIHJlZ3VsYXIgcmVzcG9uc2Vcblx0XHRcdGlmIChlcnIgJiYgZXJyLnJlc3BvbnNlKSB7XG5cdFx0XHRcdGVyci5yZXNwb25zZSA9IHRoaXMuX3RyaW1SZXNwb25zZURhdGEoZXJyLnJlc3BvbnNlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmVyciA9IGVycjtcblx0XHR0aGlzLmxvYWRlZCA9IHRydWU7XG5cblx0XHRpZiAoZmFsc2UpIHtcblx0XHRcdC8vIERlZXAgY29weSwgdG8gbWFrZSBzdXJlIG5vYm9keSBwbGF5cyB3aXRoIHRoZVxuXHRcdFx0Ly8gb2JqZWN0IHdlIHB1dCBpbiB0aGUgY2FjaGVcblx0XHRcdGVyciA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZXJyKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5kZmQucmVqZWN0KGVycik7XG5cdH1cblxuXHRfcGFyc2VQcm9taXNlKGRmZCkge1xuXHRcdHJldHVybiBkZmQucHJvbWlzZS50aGVuKHZhbCA9PiBKU09OLnBhcnNlKHZhbCkpO1xuXHR9XG5cblx0d2hlbkRhdGFSZWFkeSAoKSB7XG5cdFx0aWYgKGZhbHNlKSB7XG5cdFx0XHQvLyBzZXJ2ZXItc2lkZSwgd2UgaW5jcmVtZW50IHRoZSBudW1iZXIgb2YgcmVxdWVzdGVyc1xuXHRcdFx0Ly8gd2UgZXhwZWN0IHRvIHJldHJpZXZlIHRoZSBkYXRhIG9uIHRoZSBmcm9udGVuZFxuXHRcdFx0dGhpcy5yZXF1ZXN0ZXJzICs9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcGFyc2VQcm9taXNlKHRoaXMuZGZkKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gY2xpZW50LXNpZGUsIHdoZW5ldmVyIHNvbWVvbmUgcmV0cmlldmVzIGRhdGEgZnJvbSB0aGUgY2FjaGUsXG5cdFx0XHQvLyB3ZSBkZWNyZW1lbnQgdGhlIG51bWJlciBvZiByZXRyaWV2YWxzIGV4cGVjdGVkLCBhbmQgd2hlbiB3ZVxuXHRcdFx0Ly8gaGl0IHplcm8sIHJlbW92ZSB0aGUgY2FjaGUgZW50cnkuXG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVxdWVzdGVyRGVjcmVtZW50aW5nUHJvbWlzZSh0aGlzLmRmZCk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gZm9yIGludGVybmFsIChyZWFjdC1zZXJ2ZXIgbWlkZGxld2FyZSkgY2FsbHNcblx0d2hlbkRhdGFSZWFkeUludGVybmFsICgpIHtcblx0XHRyZXR1cm4gdGhpcy5kZmQucHJvbWlzZTtcblx0fVxuXG5cdGRlY3JlbWVudFJlcXVlc3RlcnMgKCkge1xuXHRcdGxvZ2dlci5kZWJ1ZyhcIkRlY3JlbWVudGluZzogXCIgKyB0aGlzLnVybCk7XG5cdFx0dGhpcy5yZXF1ZXN0ZXJzIC09IDE7XG5cblx0XHRpZiAodGhpcy5yZXF1ZXN0ZXJzID09PSAwKSB7XG5cdFx0XHR0aGlzLmNhY2hlLl9yZW1vdmVFbnRyeSh0aGlzKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hhaW4gYSBwcm9taXNlIHdpdGggYW5vdGhlciBwcm9taXNlIHRoYXQgZGVjcmVtZW50c1xuXHQgKiB0aGUgbnVtYmVyIG9mIGV4cGVjdGVkIHJlcXVlc3RlcnMuXG5cdCAqL1xuXHRfcmVxdWVzdGVyRGVjcmVtZW50aW5nUHJvbWlzZSAoZGZkKSB7XG5cdFx0Ly8gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHdlJ3JlIHJlc29sdmVkIHdpdGggYSAncmVzJyBvciAnZXJyJyxcblx0XHQvLyB3ZSB3YW50IHRvIGRlY3JlbWVudCByZXF1ZXN0cy4gdGhlIGFwcHJvcHJpYXRlICdzdWNjZXNzJyBvciAnZXJyb3InXG5cdFx0Ly8gY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBvbiB3aGF0ZXZlciBpcyBjaGFpbmVkIGFmdGVyIHRoaXMgbWV0aG9kXG5cdFx0cmV0dXJuIHRoaXMuX3BhcnNlUHJvbWlzZShkZmQpLmZpbiggcmVzT3JFcnIgPT4ge1xuXHRcdFx0dGhpcy5kZWNyZW1lbnRSZXF1ZXN0ZXJzKCk7XG5cdFx0XHRyZXR1cm4gcmVzT3JFcnI7XG5cdFx0fSk7XG5cdH1cblxuXHRpc0ZvclNhbWVSZXF1ZXN0IChyZXF1ZXN0RGF0YSkge1xuXHRcdHZhciBvdGhlclJEID0gcmVxdWVzdERhdGE7XG5cdFx0dmFyIG15UkQgPSB0aGlzLnJlcXVlc3REYXRhO1xuXG5cdFx0ZnVuY3Rpb24gc2FtZShwcm9wTmFtZSkge1xuXHRcdFx0cmV0dXJuIGlzRXF1YWwobXlSRFtwcm9wTmFtZV0sIG90aGVyUkRbcHJvcE5hbWVdKTtcblx0XHR9XG5cblx0XHQvLyBzcGVjaWZ5aW5nIHRoZSBvcmRlciBvZiBjaGVja3MgaGVyZSB0byBsZXQgdGhlIGZhc3QvY29tbW9uIGNoZWNrc1xuXHRcdC8vIGZhaWwgZmlyc3Rcblx0XHRyZXR1cm4gc2FtZShcInVybFBhdGhcIilcblx0XHRcdCYmIHNhbWUoXCJtZXRob2RcIilcblx0XHRcdCYmIHNhbWUoXCJ0eXBlXCIpXG5cdFx0XHQmJiBzYW1lKFwicXVlcnlQYXJhbXNcIilcblx0XHRcdCYmIHNhbWUoXCJwb3N0UGFyYW1zXCIpO1xuXHR9XG5cblx0Ly8gUHVsbCBvdXQgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHN1cGVyYWdlbnQgcmVzcG9uc2UgdGhhdCB3ZSBjYXJlXG5cdC8vIGFib3V0IGFuZCBwcm9kdWNlIGFuIG9iamVjdCB0aGF0J3Mgc3VpdGFibGUgZm9yIHdyaXRpbmcgYXMgSlNPTi5cblx0X3RyaW1SZXNwb25zZURhdGEgKHJlcykge1xuXHRcdHZhciByZXN1bHQgPSB7fTtcblx0XHRbXG5cdFx0XHRcImJvZHlcIixcblx0XHRcdFwidGV4dFwiLFxuXHRcdFx0XCJ0eXBlXCIsXG5cblx0XHRcdC8qJ2ZpbGVzJyovIC8vIFRPRE9cblxuXHRcdFx0LyogXCJoZWFkZXJcIiwqLyAvLyBoZWFkZXIgaXMgbm8gbG9uZ2VyIGluY2x1ZGVkIGJ5IGRlZmF1bHQgaW4gdGhlIGNhY2hlIHRvIHNhdmUgc3BhY2Vcblx0XHRcdFwic3RhdHVzXCIsXG5cdFx0XHRcInN0YXR1c1R5cGVcIixcblx0XHRcdFwiaW5mb1wiLFxuXHRcdFx0XCJva1wiLFxuXHRcdFx0XCJjbGllbnRFcnJvclwiLFxuXHRcdFx0XCJzZXJ2ZXJFcnJvclwiLFxuXHRcdFx0XCJlcnJvclwiLFxuXG5cdFx0XHRcImFjY2VwdGVkXCIsXG5cdFx0XHRcIm5vQ29udGVudFwiLFxuXHRcdFx0XCJiYWRSZXF1ZXN0XCIsXG5cdFx0XHRcInVuYXV0aG9yaXplZFwiLFxuXHRcdFx0XCJub3RBY2NlcHRhYmxlXCIsXG5cdFx0XHRcIm5vdEZvdW5kXCIsXG5cdFx0XHRcImZvcmJpZGRlblwiLFxuXHRcdF0uZm9yRWFjaCggcHJvcCA9PiB7XG5cdFx0XHRyZXN1bHRbcHJvcF0gPSByZXNbcHJvcF07XG5cdFx0fSk7XG5cdFx0aWYgKHRoaXMuY2FjaGVXaGl0ZWxpc3QpIHtcblx0XHRcdHRoaXMuY2FjaGVXaGl0ZWxpc3QuZm9yRWFjaCggcHJvcCA9PiB7XG5cdFx0XHRcdHJlc3VsdFtwcm9wXSA9IHJlc1twcm9wXTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxufVxuXG5cbi8qKlxuICogQ2FjaGUgb2YgcmVzcG9uc2VzIHRvIEFQSSByZXF1ZXN0cyBtYWRlIHNlcnZlci1zaWRlIHRoYXQgd2lsbCBiZVxuICogc2VyaWFsaXplZCBhcyBwYXJ0IG9mIHRoZSBpbml0aWFsIHBhZ2UgcmVxdWVzdCBhbmQgcmVwbGF5ZWQgaW4gdGhlXG4gKiBicm93c2VyLlxuICovXG5jbGFzcyBSZXF1ZXN0RGF0YUNhY2hlIHtcblxuXHRjb25zdHJ1Y3RvciAoKSB7XG5cdFx0Lypcblx0XHQgKiBNYXBbU3RyaW5nIC0+IENhY2hlRW50cnlbXV1cblx0XHQgKi9cblx0XHR0aGlzLmRhdGFDYWNoZSA9IHt9O1xuXHR9XG5cblx0ZGVoeWRyYXRlICh7cmVzcG9uc2VCb2R5T25seT1mYWxzZX0gPSB7fSkge1xuXG5cdFx0dmFyIG91dCA9IHtcblx0XHRcdGRhdGFDYWNoZToge30sXG5cdFx0fTtcblxuXHRcdHZhciBkYXRhQ2FjaGUgPSB0aGlzLmRhdGFDYWNoZTtcblx0XHRPYmplY3Qua2V5cyhkYXRhQ2FjaGUpLmZvckVhY2godXJsID0+IHtcblx0XHRcdC8vIGFzIGEgbmljZS10by1oYXZlIGZvciBGcmFnbWVudERhdGFDYWNoZSwgaWYgdGhlcmUncyBvbmx5IG9uZSBlbnRyeVxuXHRcdFx0Ly8gZm9yIGEgZ2l2ZW4gVVJMLCBkb24ndCBzZXJpYWxpemUgaXQgYXMgYW4gYXJyYXksIHNlcmlhbGl6ZSBpdCBhcyBhIHNpbmdsZVxuXHRcdFx0Ly8gQ2FjaGVFbnRyeVxuXHRcdFx0dmFyIGRlaHlkcmF0ZWRFbnRyaWVzID1cblx0XHRcdFx0ZGF0YUNhY2hlW3VybF0ubWFwKGVudHJ5ID0+IGVudHJ5LmRlaHlkcmF0ZSh7IHJlc3BvbnNlQm9keU9ubHkgfSkpO1xuXHRcdFx0b3V0LmRhdGFDYWNoZVt1cmxdID0gZGVoeWRyYXRlZEVudHJpZXMubGVuZ3RoID09PSAxID8gZGVoeWRyYXRlZEVudHJpZXNbMF0gOiBkZWh5ZHJhdGVkRW50cmllcztcblxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXG5cdHJlaHlkcmF0ZSAoc3RhdGUpIHtcblxuXHRcdGxvZ2dlci5kZWJ1ZyhcIlJlaHlkcmF0aW5nIFJlcXVlc3REYXRhQ2FjaGVcIik7XG5cblx0XHQvLyBjbGVhciBzdGF0ZVxuXHRcdHZhciBkYXRhQ2FjaGUgPSB0aGlzLmRhdGFDYWNoZSA9IHt9O1xuXG5cdFx0T2JqZWN0LmtleXMoc3RhdGUuZGF0YUNhY2hlKS5mb3JFYWNoKHVybCA9PiB7XG5cblx0XHRcdHZhciBlbnRyaWVzID0gc3RhdGUuZGF0YUNhY2hlW3VybF07XG5cdFx0XHQvLyBjb252ZXJ0IGVudHJpZXMgdG8gYW4gYXJyYXksIGlmIGl0IHdhcyBzZXJpYWxpemVkIGFzXG5cdFx0XHQvLyBhIHNpbmdsZSBlbnRyeVxuXHRcdFx0ZW50cmllcyA9IEFycmF5LmlzQXJyYXkoZW50cmllcykgPyBlbnRyaWVzIDogW2VudHJpZXNdO1xuXHRcdFx0ZGF0YUNhY2hlW3VybF0gPSBlbnRyaWVzLm1hcChlbnRyeURhdGEgPT4ge1xuXHRcdFx0XHR2YXIgbmV3RW50cnkgPSBuZXcgQ2FjaGVFbnRyeSh0aGlzKTtcblx0XHRcdFx0bmV3RW50cnkucmVoeWRyYXRlKGVudHJ5RGF0YSk7XG5cdFx0XHRcdHJldHVybiBuZXdFbnRyeTtcblx0XHRcdH0pXG5cdFx0fSk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgKG9wdGlvbmFsbHkgY3JlYXRpbmcgaWYgbmVjZXNzYXJ5KSB0aGUgZW50cnkgZm9yIHRoZSBnaXZlblxuXHQgKiByZXF1ZXN0RGF0YSBmcm9tIHRoZSBjYWNoZS5cblx0ICpcblx0ICogQHBhcmFtIGNyZWF0ZUlmTWlzc2luZyBib29sZWFuIGRlZmF1bHQgZmFsc2Vcblx0ICogQHBhcmFtIGNhY2hlV2hpdGVsaXN0IGFycmF5IGRlZmF1bHQgW11cblx0ICovXG5cdGVudHJ5IChyZXF1ZXN0RGF0YSwgY3JlYXRlSWZNaXNzaW5nID0gZmFsc2UsIGNhY2hlV2hpdGVsaXN0ID0gW10pIHtcblx0XHRpZiAoIXJlcXVlc3REYXRhLnVybFBhdGgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWVzdERhdGEudXJsUGF0aFwiKTtcblx0XHR9XG5cblx0XHRsb2dnZXIuZGVidWcoYEdldHRpbmcgUmVhY3RTZXJ2ZXJBZ2VudCByZXF1ZXN0IGRhdGEgY2FjaGUgZW50cnkgZm9yICR7cmVxdWVzdERhdGEudXJsUGF0aH1gKVxuXG5cdFx0dmFyIGNhY2hlRW50cnkgPSB0aGlzLl9maW5kRW50cnkocmVxdWVzdERhdGEpO1xuXHRcdGlmICghY2FjaGVFbnRyeSAmJiBjcmVhdGVJZk1pc3NpbmcpIHtcblx0XHRcdGNhY2hlRW50cnkgPSB0aGlzLl9hZGRFbnRyeShyZXF1ZXN0RGF0YSwgY2FjaGVXaGl0ZWxpc3QpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjYWNoZUVudHJ5O1xuXHR9XG5cblx0X2ZpbmRFbnRyeSAocmVxdWVzdERhdGEpIHtcblx0XHR2YXIgdXJsUGF0aCA9IHJlcXVlc3REYXRhLnVybFBhdGg7XG5cdFx0dmFyIGVudHJpZXMgPSB0aGlzLmRhdGFDYWNoZVt1cmxQYXRoXSB8fCBbXTtcblx0XHQvLyBvbGQtc2Nob29sIGxvb3Agc28gd2UgY2FuIGJyZWFrIGVhcmx5XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZW50cnkgPSBlbnRyaWVzW2ldO1xuXHRcdFx0aWYgKGVudHJ5LmlzRm9yU2FtZVJlcXVlc3QocmVxdWVzdERhdGEpKSB7XG5cdFx0XHRcdHJldHVybiBlbnRyeTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQWRkIGEgbmV3IENhY2hlRW50cnkgZm9yIHRoZSByZXF1ZXN0IGRlc2NyaWJlZCBieSBgcmVxdWVzdERhdGFgXG5cdCAqXG5cdCAqIEBwYXJhbSByZXF1ZXN0RGF0YSB0aGUgcmVxdWVzdCBkYXRhIGRlc2NyaXB0b3IsIGFzIGRlZmluZWQgYnlcblx0ICogICAgICAgIFJlcXVlc3QuX2dldENhY2hlQWZmZWN0aW5nRGF0YS5cblx0ICogQHBhcmFtIGNhY2hlV2hpdGVMaXN0IHRoZSB3aGl0ZWxpc3Qgb2YgZmllbGRzIHRoYXQgd2lsbCBiZSBwcm92aWRlZFxuXHQgKiAgICAgICAgb24gdGhlIHJlcXVlc3QuXG5cdCAqL1xuXHRfYWRkRW50cnkgKHJlcXVlc3REYXRhLCBjYWNoZVdoaXRlbGlzdCkge1xuXHRcdHZhciB1cmxQYXRoID0gcmVxdWVzdERhdGEudXJsUGF0aCxcblx0XHRcdGVudHJpZXMgPSB0aGlzLmRhdGFDYWNoZVt1cmxQYXRoXSB8fCAodGhpcy5kYXRhQ2FjaGVbdXJsUGF0aF0gPSBbXSksXG5cdFx0XHRuZXdFbnRyeSA9IG5ldyBDYWNoZUVudHJ5KHRoaXMsIHJlcXVlc3REYXRhLCBjYWNoZVdoaXRlbGlzdCk7XG5cdFx0ZW50cmllcy5wdXNoKG5ld0VudHJ5KTtcblx0XHRyZXR1cm4gbmV3RW50cnlcblx0fVxuXG5cdF9yZW1vdmVFbnRyeSAoZW50cnkpIHtcblx0XHR2YXIgdXJsUGF0aCA9IGVudHJ5LnJlcXVlc3REYXRhLnVybFBhdGgsXG5cdFx0XHRlbnRyaWVzID0gdGhpcy5kYXRhQ2FjaGVbdXJsUGF0aF0sXG5cdFx0XHRpZHggPSBlbnRyaWVzLmluZGV4T2YoZW50cnkpO1xuXHRcdGlmIChpZHggPj0gMCkge1xuXHRcdFx0ZW50cmllcy5zcGxpY2UoaWR4LCAxKTtcblx0XHR9XG5cdFx0dGhpcy5jaGVja0NhY2hlRGVwbGV0ZWQoKTtcblx0fVxuXG5cdG1hcmtMYXRlUmVxdWVzdHMgKCkge1xuXHRcdHRoaXMuZ2V0UGVuZGluZ1JlcXVlc3RzKCkuZm9yRWFjaChyZXEgPT4ge3JlcS5lbnRyeS5sYXRlID0gdHJ1ZX0pO1xuXHR9XG5cblx0Z2V0TGF0ZVJlcXVlc3RzICgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRBbGxSZXF1ZXN0cygpLmZpbHRlcihyZXEgPT4gcmVxLmVudHJ5LmxhdGUpO1xuXHR9XG5cblx0Z2V0UGVuZGluZ1JlcXVlc3RzICgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRBbGxSZXF1ZXN0cygpLmZpbHRlcihyZXEgPT4gIXJlcS5lbnRyeS5sb2FkZWQpO1xuXHR9XG5cblx0Z2V0QWxsUmVxdWVzdHMoKSB7XG5cdFx0dmFyIGFsbCA9IFtdO1xuXHRcdE9iamVjdC5rZXlzKHRoaXMuZGF0YUNhY2hlKS5mb3JFYWNoKHVybCA9PiB7XG5cdFx0XHR0aGlzLmRhdGFDYWNoZVt1cmxdLmZvckVhY2goZW50cnkgPT4ge1xuXHRcdFx0XHRhbGwucHVzaCh7IHVybCwgZW50cnkgfSlcblx0XHRcdH0pXG5cdFx0fSk7XG5cdFx0cmV0dXJuIGFsbDtcblx0fVxuXG5cdHdoZW5BbGxQZW5kaW5nUmVzb2x2ZSAoKSB7XG5cdFx0dmFyIHByb21pc2VzID0gdGhpcy5nZXRBbGxSZXF1ZXN0cygpLm1hcChyZXEgPT4gcmVxLmVudHJ5LmRmZC5wcm9taXNlKTtcblx0XHRyZXR1cm4gUS5hbGxTZXR0bGVkKHByb21pc2VzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGaXJlcyB3aGVuIHRoZSBjYWNoZSBoYXMgYmVlbiBjb21wbGV0ZWx5IGRlcGxldGVkLCB3aGljaCBpcyB1c2VkIGFzIGEgc2lnbmFsIHRvIHJlbmRlciB3aGVuIHRoZXJlIHdhcyBhIHRpbWVvdXQgb24gdGhlIHNlcnZlci5cblx0ICovXG5cdHdoZW5DYWNoZURlcGxldGVkICgpIHtcblx0XHR0aGlzLndoZW5DYWNoZURlcGxldGVkRGZkID0gdGhpcy53aGVuQ2FjaGVEZXBsZXRlZERmZCB8fCBRLmRlZmVyKCk7XG5cblx0XHR0aGlzLmNoZWNrQ2FjaGVEZXBsZXRlZCgpO1xuXG5cdFx0cmV0dXJuIHRoaXMud2hlbkNhY2hlRGVwbGV0ZWREZmQucHJvbWlzZTtcblx0fVxuXG5cdGNoZWNrQ2FjaGVEZXBsZXRlZCgpIHtcblx0XHRsb2dnZXIuZGVidWcoXCJfY2hlY2tDYWNoZURlcGxldGVkXCIpO1xuXHRcdGlmICh0aGlzLndoZW5DYWNoZURlcGxldGVkRGZkKSB7XG5cdFx0XHR2YXIgdG90YWxSZXF1ZXN0ZXJzUGVuZGluZyA9IDA7XG5cdFx0XHR0aGlzLmdldEFsbFJlcXVlc3RzKCkuZm9yRWFjaChyZXEgPT4ge1xuXHRcdFx0XHRpZiAocmVxLmVudHJ5LmxvYWRlZCkge1xuXHRcdFx0XHRcdHRvdGFsUmVxdWVzdGVyc1BlbmRpbmcgKz0gcmVxLmVudHJ5LnJlcXVlc3RlcnM7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0bG9nZ2VyLmRlYnVnKGBDaGVja2luZyBmb3IgZGVwbGV0ZWQgY2FjaGUsIHdpdGggJHt0b3RhbFJlcXVlc3RlcnNQZW5kaW5nfSByZXF1ZXN0ZXJzIGxlZnRgKTtcblx0XHRcdGlmICh0b3RhbFJlcXVlc3RlcnNQZW5kaW5nID09PSAwKSB0aGlzLndoZW5DYWNoZURlcGxldGVkRGZkLnJlc29sdmUoKTtcblx0XHR9XG5cdH1cblxuXHRsYXRlQXJyaXZhbCAodXJsLCBkZWh5ZHJhdGVkRW50cnkpIHtcblx0XHRsb2dnZXIuZGVidWcoYExhdGUgYXJyaXZhbCBmb3IgJHt1cmx9YCk7XG5cdFx0dmFyIGVudHJ5ID0gdGhpcy5fZmluZEVudHJ5KGRlaHlkcmF0ZWRFbnRyeS5yZXF1ZXN0RGF0YSk7XG5cdFx0aWYgKGVudHJ5KSB7XG5cdFx0XHRlbnRyeS5yZWh5ZHJhdGUoZGVoeWRyYXRlZEVudHJ5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKFwiV1RGP1wiKTtcblx0XHR9XG5cdH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3REYXRhQ2FjaGU7XG4iXX0=
