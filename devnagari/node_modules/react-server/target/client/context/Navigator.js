'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EventEmitter = require('events').EventEmitter,
    logger = require('../logging').getLogger({ "name": "react-server.core.context.Navigator", "color": { "server": 85, "client": "rgb(42,212,127)" } }),
    Router = require('routr'),
    Q = require('q'),
    History = require("../components/History"),
    ReactServerAgent = require("../ReactServerAgent"),
    PageUtil = require("../util/PageUtil"),
    DebugUtil = require("../util/DebugUtil"),
    _ref = false ? require('../logging/response') : { setResponseLoggerPage: function setResponseLoggerPage() {} },
    setResponseLoggerPage = _ref.setResponseLoggerPage;

var Navigator = function (_EventEmitter) {
	_inherits(Navigator, _EventEmitter);

	function Navigator(context, routes) {
		_classCallCheck(this, Navigator);

		var _this = _possibleConstructorReturn(this, (Navigator.__proto__ || Object.getPrototypeOf(Navigator)).call(this));

		_this.router = new Router(routes.routes);
		_this.context = context;

		_this._globalMiddleware = routes.middleware;
		_this._loading = false;
		_this._currentRoute = null;
		_this._nextRoute = null;
		return _this;
	}

	/**
  * type is one of
  *    History.events.PUSHSTATE: user clicked something to go forward but browser didn't do a
  * full page load
  *    History.events.POPSTATE: user clicked back button but browser didn't do a full page load
  *    History.events.PAGELOAD: full browser page load, not using History API.
  *
  * Default is History.events.PAGELOAD.
  */


	_createClass(Navigator, [{
		key: 'navigate',
		value: function navigate(request, type) {
			var _this2 = this;

			logger.debug('Navigating to ' + request.getUrl());
			type = type || History.events.PAGELOAD;

			this._haveInitialized = true;

			// Pull debug parameters out of the query string and expose via a well
			// defined interface.
			DebugUtil.setRequest(request);

			var route = this.router.getRoute(request.getUrl(), { method: request.getMethod() });

			if (route) {
				logger.debug('Mapped ' + request.getUrl() + ' to route ' + route.name);
			} else {
				this.emit('navigateDone', { status: 404, message: "No Route!" }, null, request.getUrl(), type);
				return;
			}

			// We may or may not _actually_ start this route client side.
			//
			// If there's a flurry of navigation we skip any routes that
			// blow by while we're still working on a page, and only
			// finally start the _last_ one.
			//
			// The promise returned from `startRoute()` will be rejected
			// if we're not going to proceed, so resources will be freed.
			//
			this.startRoute(route, request, type)

			// We might have a data bundle on hand, or the request may
			// have asked us to fetch it one.
			.then(this._dealWithDataBundleLoading.bind(this, request)).then(function () {
				if (_this2._ignoreCurrentNavigation) {
					// This is a one-time deal.
					_this2._ignoreCurrentNavigation = false;
					return;
				}

				/* Breathe... */

				var loaders = route.config.page;

				var deviceType = _this2.context.getDeviceType();

				if (loaders[deviceType]) {
					route.name += "-" + deviceType;
				}

				// Our route may have multiple page implementations if
				// there are device-specific variations.
				//
				// We'll take one of those if the request device
				// matches, otherwise we'll use the default.
				//
				// Note that the page object may either directly be a
				// loader or it may be an object whose values are
				// loaders.
				(loaders[deviceType] || loaders.default || loaders)().done(function (pageConstructor) {
					if (request.setRoute) {
						request.setRoute(route);
					}
					_this2.handlePage(pageConstructor, request, type);
				}, function (err) {
					console.error("Error resolving page", err);
				});
			});
		}

		// If you call this you're responsible for calling `finishRoute()`
		// when you're done with whatever it is you're hiding from the
		// navigator.

	}, {
		key: 'ignoreCurrentNavigation',
		value: function ignoreCurrentNavigation() {
			this._ignoreCurrentNavigation = true;
		}
	}, {
		key: '_dealWithDataBundleLoading',
		value: function _dealWithDataBundleLoading(request) {

			// If we're managing a frame's navigation, we want _it_ to
			// use a data bundle.
			if (this._ignoreCurrentNavigation) return Q();

			// If this request doesn't use a data bundle, we're done.
			if (!request.getBundleData()) return Q();

			// If the request wants all of the data fetched as a bundle
			// we'll need to kick off the request for the bundle.
			return ReactServerAgent._fetchDataBundle(request.getUrl()).then(ReactServerAgent._rehydrateDataBundle).catch(function (err) {
				return logger.error('Data bundle error', err);
			});
		}
	}, {
		key: 'handlePage',
		value: function handlePage(pageConstructor, request, type) {
			var _this3 = this;

			// instantiate the pages we need to fulfill this request.
			var pageClasses = [];

			this._addPageMiddlewareToArray(this._globalMiddleware, pageClasses);
			this._addPageMiddlewareToArray([pageConstructor], pageClasses);

			var pages = pageClasses.map(function (pageClass) {
				if (Object.getOwnPropertyNames(pageClass).length === 0) {
					throw new Error("Tried to instantiate a page or middleware class that was an empty object. Did you forget to assign a class to module.exports?");
				}
				return new pageClass();
			});
			var page = PageUtil.createPageChain(pages);

			this.emit("page", page);

			page.setRequest(request);

			PageUtil.PageConfig.initFromPageWithDefaults(page, {
				isFragment: false,
				isRawResponse: false
			});

			// Set the page context on the response logger so it can figure
			// out whether to flush logs to the response document
			setResponseLoggerPage(page);

			// call page.handleRoute(), and use the resulting code to decide how to
			// respond.
			// We call it in a promise handler so any exception that
			// arises will get converted to a rejection that we can handle
			// below.
			Q().then(page.handleRoute).then(function (handleRouteResult) {

				page.setStatus(handleRouteResult.code);

				page.setHasDocument(handleRouteResult.hasDocument);

				page.setJsBelowTheFold(DebugUtil.getJsBelowTheFold() || handleRouteResult.jsBelowTheFold);
				page.setSplitJsLoad(DebugUtil.getSplitJsLoad() || handleRouteResult.splitJsLoad);

				// TODO: I think that 3xx/4xx/5xx shouldn't be considered "errors" in navigateDone, but that's
				// how the code is structured right now, and I'm changing too many things at once at the moment. -sra.
				if (handleRouteResult.code && (handleRouteResult.code / 100 | 0) !== 2) {
					_this3.emit("navigateDone", { status: handleRouteResult.code, redirectUrl: handleRouteResult.location }, page, request.getUrl(), type);
					return;
				}
				if (handleRouteResult.page) {
					// in this case, we should forward to a new page *without* changing the URL. Since we are already
					// in an async callback, we should schedule a new handlePage with the new page constructor and return
					// from this call.
					setTimeout(function () {
						return _this3.handlePage(handleRouteResult.page, request, type);
					}, 0);
					return;
				}

				_this3.emit('navigateDone', null, page, request.getUrl(), type);
			}).catch(function (err) {
				logger.error("Error while handling route", err);

				_this3.emit('navigateDone', { status: 500 }, page, request.getUrl(), type);
			});
		}

		/**
   * recursively adds the middleware in the pages array to array.
   */

	}, {
		key: '_addPageMiddlewareToArray',
		value: function _addPageMiddlewareToArray(pages, array) {
			var _this4 = this;

			if (!pages) return;
			pages.forEach(function (page) {
				if (page.middleware) {
					_this4._addPageMiddlewareToArray(page.middleware(), array);
				}
				array.push(page);
			});
		}
	}, {
		key: 'getState',
		value: function getState() {
			return {
				loading: this._loading,
				route: this._currentRoute
			};
		}
	}, {
		key: 'getCurrentRoute',
		value: function getCurrentRoute() {
			return this._currentRoute;
		}
	}, {
		key: 'getLoading',
		value: function getLoading() {
			return this._loading;
		}
	}, {
		key: 'startRoute',
		value: function startRoute(route, request, type) {

			// If we're being called with a requested route, we'll need to
			// tell the caller when they can proceed with their
			// navigation.
			var dfd, promise;

			// We need to handle the case where routes are requested while
			// we're handling the previous navigation.  This can happen if
			// the user furiously clicks the browser's forward/back
			// navigation buttons.
			//
			// We don't want a _queue_ here, because we're only ultimately
			// going to show the user the _final_ route that's requested,
			// so we'll just keep a single reference to the next route we
			// need to actually render once our current navigation is
			// complete.
			//
			if (request) {

				// We don't want to leave navigation detritus
				// laying around as we discard bypassed pages.
				if (this._nextRoute) this._nextRoute.dfd.reject();

				dfd = Q.defer(), promise = dfd.promise;

				this._nextRoute = { route: route, request: request, type: type, dfd: dfd };
			}

			// If we're _currently_ navigating, we'll wait to start the
			// next route until this navigation is complete.  Interleaved
			// navigation causes all kinds of havoc.
			if (!this._loading && this._nextRoute) {
				var _nextRoute = this._nextRoute,
				    _route = _nextRoute.route,
				    _request = _nextRoute.request,
				    _type = _nextRoute.type,
				    _dfd = _nextRoute.dfd;


				this._loading = true;
				this._currentRoute = _route;
				this._nextRoute = null;

				this.emit('navigateStart', { route: _route, request: _request, type: _type });

				// This allows the actual navigation to
				// proceed.
				_dfd.resolve();
			}

			return promise;
		}
	}, {
		key: 'finishRoute',
		value: function finishRoute() {
			this._loading = false;

			this.emit('loadComplete');

			// If other routes were queued while we were navigating, we'll
			// start the next one right off.
			//
			this.startRoute();
		}
	}]);

	return Navigator;
}(EventEmitter);

module.exports = Navigator;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbnRleHQvTmF2aWdhdG9yLmpzIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJFdmVudEVtaXR0ZXIiLCJsb2dnZXIiLCJnZXRMb2dnZXIiLCJSb3V0ZXIiLCJRIiwiSGlzdG9yeSIsIlJlYWN0U2VydmVyQWdlbnQiLCJQYWdlVXRpbCIsIkRlYnVnVXRpbCIsInNldFJlc3BvbnNlTG9nZ2VyUGFnZSIsIk5hdmlnYXRvciIsImNvbnRleHQiLCJyb3V0ZXMiLCJyb3V0ZXIiLCJfZ2xvYmFsTWlkZGxld2FyZSIsIm1pZGRsZXdhcmUiLCJfbG9hZGluZyIsIl9jdXJyZW50Um91dGUiLCJfbmV4dFJvdXRlIiwicmVxdWVzdCIsInR5cGUiLCJkZWJ1ZyIsImdldFVybCIsImV2ZW50cyIsIlBBR0VMT0FEIiwiX2hhdmVJbml0aWFsaXplZCIsInNldFJlcXVlc3QiLCJyb3V0ZSIsImdldFJvdXRlIiwibWV0aG9kIiwiZ2V0TWV0aG9kIiwibmFtZSIsImVtaXQiLCJzdGF0dXMiLCJtZXNzYWdlIiwic3RhcnRSb3V0ZSIsInRoZW4iLCJfZGVhbFdpdGhEYXRhQnVuZGxlTG9hZGluZyIsImJpbmQiLCJfaWdub3JlQ3VycmVudE5hdmlnYXRpb24iLCJsb2FkZXJzIiwiY29uZmlnIiwicGFnZSIsImRldmljZVR5cGUiLCJnZXREZXZpY2VUeXBlIiwiZGVmYXVsdCIsImRvbmUiLCJzZXRSb3V0ZSIsImhhbmRsZVBhZ2UiLCJwYWdlQ29uc3RydWN0b3IiLCJjb25zb2xlIiwiZXJyb3IiLCJlcnIiLCJnZXRCdW5kbGVEYXRhIiwiX2ZldGNoRGF0YUJ1bmRsZSIsIl9yZWh5ZHJhdGVEYXRhQnVuZGxlIiwiY2F0Y2giLCJwYWdlQ2xhc3NlcyIsIl9hZGRQYWdlTWlkZGxld2FyZVRvQXJyYXkiLCJwYWdlcyIsIm1hcCIsInBhZ2VDbGFzcyIsIk9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJsZW5ndGgiLCJFcnJvciIsImNyZWF0ZVBhZ2VDaGFpbiIsIlBhZ2VDb25maWciLCJpbml0RnJvbVBhZ2VXaXRoRGVmYXVsdHMiLCJpc0ZyYWdtZW50IiwiaXNSYXdSZXNwb25zZSIsImhhbmRsZVJvdXRlIiwic2V0U3RhdHVzIiwiaGFuZGxlUm91dGVSZXN1bHQiLCJjb2RlIiwic2V0SGFzRG9jdW1lbnQiLCJoYXNEb2N1bWVudCIsInNldEpzQmVsb3dUaGVGb2xkIiwiZ2V0SnNCZWxvd1RoZUZvbGQiLCJqc0JlbG93VGhlRm9sZCIsInNldFNwbGl0SnNMb2FkIiwiZ2V0U3BsaXRKc0xvYWQiLCJzcGxpdEpzTG9hZCIsInJlZGlyZWN0VXJsIiwibG9jYXRpb24iLCJzZXRUaW1lb3V0IiwiYXJyYXkiLCJmb3JFYWNoIiwicHVzaCIsImxvYWRpbmciLCJkZmQiLCJwcm9taXNlIiwicmVqZWN0IiwiZGVmZXIiLCJyZXNvbHZlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNJLG1CQUFlQSxRQUFRLFFBQVIsRUFBa0JDLFlBQWpDO0FBQUEsSUFDSEMsTUFERyxHQUNNRixRQUFRLFlBQVIsRUFBc0JHLFNBQXRCLENBQWdDLEVBQUMsUUFBTyxxQ0FBUixFQUE4QyxTQUFRLEVBQUMsVUFBUyxFQUFWLEVBQWEsVUFBUyxpQkFBdEIsRUFBdEQsRUFBaEMsQ0FETjtBQUFBLElBRUhDLE1BRkcsR0FFTUosUUFBUSxPQUFSLENBRk47QUFBQSxJQUdISyxDQUhHLEdBR0NMLFFBQVEsR0FBUixDQUhEO0FBQUEsSUFJSE0sT0FKRyxHQUlPTixRQUFRLHVCQUFSLENBSlA7QUFBQSxJQUtITyxnQkFMRyxHQUtnQlAsUUFBUSxxQkFBUixDQUxoQjtBQUFBLElBTUhRLFFBTkcsR0FNUVIsUUFBUSxrQkFBUixDQU5SO0FBQUEsSUFPSFMsU0FQRyxHQU9TVCxRQUFRLG1CQUFSLENBUFQ7QUFBQSxXQVF1QixRQUFRQSxRQUFRLHFCQUFSLENBQVIsR0FBeUMsRUFBRVUsdUJBQXVCLGlDQUFNLENBQUUsQ0FBakMsRUFSaEU7QUFBQSxJQVFGQSxxQkFSRSxRQVFGQSxxQkFSRTs7SUFV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LGNBRTlCQSxLQUY4QjtBQUFBLFFBRXZCUixRQUZ1QixjQUV2QkEsT0FGdUI7QUFBQSxRQUVkQyxLQUZjLGNBRWRBLElBRmM7QUFBQSxRQUVSc0UsSUFGUSxjQUVSQSxHQUZROzs7QUFJckMsU0FBSzFFLFFBQUwsR0FBcUIsSUFBckI7QUFDQSxTQUFLQyxhQUFMLEdBQXFCVSxNQUFyQjtBQUNBLFNBQUtULFVBQUwsR0FBcUIsSUFBckI7O0FBRUEsU0FBS2MsSUFBTCxDQUFVLGVBQVYsRUFBMkIsRUFBQ0wsYUFBRCxFQUFRUixpQkFBUixFQUFpQkMsV0FBakIsRUFBM0I7O0FBRUE7QUFDQTtBQUNBc0UsU0FBSUksT0FBSjtBQUNBOztBQUVELFVBQU9ILE9BQVA7QUFDQTs7O2dDQUVjO0FBQ2QsUUFBSzNFLFFBQUwsR0FBZ0IsS0FBaEI7O0FBRUEsUUFBS2dCLElBQUwsQ0FBVSxjQUFWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQUtHLFVBQUw7QUFDQTs7OztFQXRSc0JuQyxZOztBQXlSeEIrRixPQUFPQyxPQUFQLEdBQWlCdEYsU0FBakIiLCJmaWxlIjoiY29udGV4dC9OYXZpZ2F0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXIsXG5cdGxvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dpbmcnKS5nZXRMb2dnZXIoe1wibmFtZVwiOlwicmVhY3Qtc2VydmVyLmNvcmUuY29udGV4dC5OYXZpZ2F0b3JcIixcImNvbG9yXCI6e1wic2VydmVyXCI6ODUsXCJjbGllbnRcIjpcInJnYig0MiwyMTIsMTI3KVwifX0pLFxuXHRSb3V0ZXIgPSByZXF1aXJlKCdyb3V0cicpLFxuXHRRID0gcmVxdWlyZSgncScpLFxuXHRIaXN0b3J5ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvSGlzdG9yeVwiKSxcblx0UmVhY3RTZXJ2ZXJBZ2VudCA9IHJlcXVpcmUoXCIuLi9SZWFjdFNlcnZlckFnZW50XCIpLFxuXHRQYWdlVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL1BhZ2VVdGlsXCIpLFxuXHREZWJ1Z1V0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9EZWJ1Z1V0aWxcIiksXG5cdHtzZXRSZXNwb25zZUxvZ2dlclBhZ2V9ID0gZmFsc2UgPyByZXF1aXJlKCcuLi9sb2dnaW5nL3Jlc3BvbnNlJykgOiB7IHNldFJlc3BvbnNlTG9nZ2VyUGFnZTogKCkgPT4ge30gfTtcblxuY2xhc3MgTmF2aWdhdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuXHRjb25zdHJ1Y3RvciAoY29udGV4dCwgcm91dGVzKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMucm91dGVyID0gbmV3IFJvdXRlcihyb3V0ZXMucm91dGVzKTtcblx0XHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuXG5cdFx0dGhpcy5fZ2xvYmFsTWlkZGxld2FyZSA9IHJvdXRlcy5taWRkbGV3YXJlO1xuXHRcdHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcblx0XHR0aGlzLl9jdXJyZW50Um91dGUgPSBudWxsO1xuXHRcdHRoaXMuX25leHRSb3V0ZSA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogdHlwZSBpcyBvbmUgb2Zcblx0ICogICAgSGlzdG9yeS5ldmVudHMuUFVTSFNUQVRFOiB1c2VyIGNsaWNrZWQgc29tZXRoaW5nIHRvIGdvIGZvcndhcmQgYnV0IGJyb3dzZXIgZGlkbid0IGRvIGFcblx0ICogZnVsbCBwYWdlIGxvYWRcblx0ICogICAgSGlzdG9yeS5ldmVudHMuUE9QU1RBVEU6IHVzZXIgY2xpY2tlZCBiYWNrIGJ1dHRvbiBidXQgYnJvd3NlciBkaWRuJ3QgZG8gYSBmdWxsIHBhZ2UgbG9hZFxuXHQgKiAgICBIaXN0b3J5LmV2ZW50cy5QQUdFTE9BRDogZnVsbCBicm93c2VyIHBhZ2UgbG9hZCwgbm90IHVzaW5nIEhpc3RvcnkgQVBJLlxuXHQgKlxuXHQgKiBEZWZhdWx0IGlzIEhpc3RvcnkuZXZlbnRzLlBBR0VMT0FELlxuXHQgKi9cblx0bmF2aWdhdGUgKHJlcXVlc3QsIHR5cGUpIHtcblxuXHRcdGxvZ2dlci5kZWJ1ZyhgTmF2aWdhdGluZyB0byAke3JlcXVlc3QuZ2V0VXJsKCl9YCk7XG5cdFx0dHlwZSA9IHR5cGUgfHwgSGlzdG9yeS5ldmVudHMuUEFHRUxPQUQ7XG5cblx0XHR0aGlzLl9oYXZlSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG5cdFx0Ly8gUHVsbCBkZWJ1ZyBwYXJhbWV0ZXJzIG91dCBvZiB0aGUgcXVlcnkgc3RyaW5nIGFuZCBleHBvc2UgdmlhIGEgd2VsbFxuXHRcdC8vIGRlZmluZWQgaW50ZXJmYWNlLlxuXHRcdERlYnVnVXRpbC5zZXRSZXF1ZXN0KHJlcXVlc3QpO1xuXG5cdFx0dmFyIHJvdXRlID0gdGhpcy5yb3V0ZXIuZ2V0Um91dGUocmVxdWVzdC5nZXRVcmwoKSwgeyBtZXRob2Q6IHJlcXVlc3QuZ2V0TWV0aG9kKCkgfSk7XG5cblx0XHRpZiAocm91dGUpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZyhgTWFwcGVkICR7cmVxdWVzdC5nZXRVcmwoKX0gdG8gcm91dGUgJHtyb3V0ZS5uYW1lfWApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVtaXQoJ25hdmlnYXRlRG9uZScsIHsgc3RhdHVzOiA0MDQsIG1lc3NhZ2U6IFwiTm8gUm91dGUhXCIgfSwgbnVsbCwgcmVxdWVzdC5nZXRVcmwoKSwgdHlwZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gV2UgbWF5IG9yIG1heSBub3QgX2FjdHVhbGx5XyBzdGFydCB0aGlzIHJvdXRlIGNsaWVudCBzaWRlLlxuXHRcdC8vXG5cdFx0Ly8gSWYgdGhlcmUncyBhIGZsdXJyeSBvZiBuYXZpZ2F0aW9uIHdlIHNraXAgYW55IHJvdXRlcyB0aGF0XG5cdFx0Ly8gYmxvdyBieSB3aGlsZSB3ZSdyZSBzdGlsbCB3b3JraW5nIG9uIGEgcGFnZSwgYW5kIG9ubHlcblx0XHQvLyBmaW5hbGx5IHN0YXJ0IHRoZSBfbGFzdF8gb25lLlxuXHRcdC8vXG5cdFx0Ly8gVGhlIHByb21pc2UgcmV0dXJuZWQgZnJvbSBgc3RhcnRSb3V0ZSgpYCB3aWxsIGJlIHJlamVjdGVkXG5cdFx0Ly8gaWYgd2UncmUgbm90IGdvaW5nIHRvIHByb2NlZWQsIHNvIHJlc291cmNlcyB3aWxsIGJlIGZyZWVkLlxuXHRcdC8vXG5cdFx0dGhpc1xuXHRcdC5zdGFydFJvdXRlKHJvdXRlLCByZXF1ZXN0LCB0eXBlKVxuXG5cdFx0Ly8gV2UgbWlnaHQgaGF2ZSBhIGRhdGEgYnVuZGxlIG9uIGhhbmQsIG9yIHRoZSByZXF1ZXN0IG1heVxuXHRcdC8vIGhhdmUgYXNrZWQgdXMgdG8gZmV0Y2ggaXQgb25lLlxuXHRcdC50aGVuKHRoaXMuX2RlYWxXaXRoRGF0YUJ1bmRsZUxvYWRpbmcuYmluZCh0aGlzLCByZXF1ZXN0KSlcblxuXHRcdC50aGVuKCgpID0+IHtcblx0XHRcdGlmICh0aGlzLl9pZ25vcmVDdXJyZW50TmF2aWdhdGlvbil7XG5cdFx0XHRcdC8vIFRoaXMgaXMgYSBvbmUtdGltZSBkZWFsLlxuXHRcdFx0XHR0aGlzLl9pZ25vcmVDdXJyZW50TmF2aWdhdGlvbiA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8qIEJyZWF0aGUuLi4gKi9cblxuXHRcdFx0dmFyIGxvYWRlcnMgPSByb3V0ZS5jb25maWcucGFnZTtcblxuXHRcdFx0dmFyIGRldmljZVR5cGUgPSB0aGlzLmNvbnRleHQuZ2V0RGV2aWNlVHlwZSgpO1xuXG5cdFx0XHRpZiAobG9hZGVyc1tkZXZpY2VUeXBlXSkge1xuXHRcdFx0XHRyb3V0ZS5uYW1lICs9IFwiLVwiICsgZGV2aWNlVHlwZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3VyIHJvdXRlIG1heSBoYXZlIG11bHRpcGxlIHBhZ2UgaW1wbGVtZW50YXRpb25zIGlmXG5cdFx0XHQvLyB0aGVyZSBhcmUgZGV2aWNlLXNwZWNpZmljIHZhcmlhdGlvbnMuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gV2UnbGwgdGFrZSBvbmUgb2YgdGhvc2UgaWYgdGhlIHJlcXVlc3QgZGV2aWNlXG5cdFx0XHQvLyBtYXRjaGVzLCBvdGhlcndpc2Ugd2UnbGwgdXNlIHRoZSBkZWZhdWx0LlxuXHRcdFx0Ly9cblx0XHRcdC8vIE5vdGUgdGhhdCB0aGUgcGFnZSBvYmplY3QgbWF5IGVpdGhlciBkaXJlY3RseSBiZSBhXG5cdFx0XHQvLyBsb2FkZXIgb3IgaXQgbWF5IGJlIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlXG5cdFx0XHQvLyBsb2FkZXJzLlxuXHRcdFx0KFxuXHRcdFx0XHRsb2FkZXJzW2RldmljZVR5cGVdIHx8XG5cdFx0XHRcdGxvYWRlcnMuZGVmYXVsdCB8fFxuXHRcdFx0XHRsb2FkZXJzXG5cdFx0XHQpKCkuZG9uZShwYWdlQ29uc3RydWN0b3IgPT4ge1xuXHRcdFx0XHRpZiAocmVxdWVzdC5zZXRSb3V0ZSkge1xuXHRcdFx0XHRcdHJlcXVlc3Quc2V0Um91dGUocm91dGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuaGFuZGxlUGFnZShwYWdlQ29uc3RydWN0b3IsIHJlcXVlc3QsIHR5cGUpO1xuXG5cdFx0XHR9LCBlcnIgPT4ge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgcmVzb2x2aW5nIHBhZ2VcIiwgZXJyKTtcblx0XHRcdH0pO1xuXG5cdFx0fSk7XG5cblx0fVxuXG5cdC8vIElmIHlvdSBjYWxsIHRoaXMgeW91J3JlIHJlc3BvbnNpYmxlIGZvciBjYWxsaW5nIGBmaW5pc2hSb3V0ZSgpYFxuXHQvLyB3aGVuIHlvdSdyZSBkb25lIHdpdGggd2hhdGV2ZXIgaXQgaXMgeW91J3JlIGhpZGluZyBmcm9tIHRoZVxuXHQvLyBuYXZpZ2F0b3IuXG5cdGlnbm9yZUN1cnJlbnROYXZpZ2F0aW9uKCkge1xuXHRcdHRoaXMuX2lnbm9yZUN1cnJlbnROYXZpZ2F0aW9uID0gdHJ1ZTtcblx0fVxuXG5cdF9kZWFsV2l0aERhdGFCdW5kbGVMb2FkaW5nKHJlcXVlc3QpIHtcblxuXHRcdC8vIElmIHdlJ3JlIG1hbmFnaW5nIGEgZnJhbWUncyBuYXZpZ2F0aW9uLCB3ZSB3YW50IF9pdF8gdG9cblx0XHQvLyB1c2UgYSBkYXRhIGJ1bmRsZS5cblx0XHRpZiAodGhpcy5faWdub3JlQ3VycmVudE5hdmlnYXRpb24pIHJldHVybiBRKCk7XG5cblx0XHQvLyBJZiB0aGlzIHJlcXVlc3QgZG9lc24ndCB1c2UgYSBkYXRhIGJ1bmRsZSwgd2UncmUgZG9uZS5cblx0XHRpZiAoIXJlcXVlc3QuZ2V0QnVuZGxlRGF0YSgpKSByZXR1cm4gUSgpO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgd2FudHMgYWxsIG9mIHRoZSBkYXRhIGZldGNoZWQgYXMgYSBidW5kbGVcblx0XHQvLyB3ZSdsbCBuZWVkIHRvIGtpY2sgb2ZmIHRoZSByZXF1ZXN0IGZvciB0aGUgYnVuZGxlLlxuXHRcdHJldHVybiBSZWFjdFNlcnZlckFnZW50Ll9mZXRjaERhdGFCdW5kbGUocmVxdWVzdC5nZXRVcmwoKSlcblx0XHRcdC50aGVuKFJlYWN0U2VydmVyQWdlbnQuX3JlaHlkcmF0ZURhdGFCdW5kbGUpXG5cdFx0XHQuY2F0Y2goZXJyID0+IGxvZ2dlci5lcnJvcignRGF0YSBidW5kbGUgZXJyb3InLCBlcnIpKTtcblx0fVxuXG5cdGhhbmRsZVBhZ2UocGFnZUNvbnN0cnVjdG9yLCByZXF1ZXN0LCB0eXBlKSB7XG5cdFx0Ly8gaW5zdGFudGlhdGUgdGhlIHBhZ2VzIHdlIG5lZWQgdG8gZnVsZmlsbCB0aGlzIHJlcXVlc3QuXG5cdFx0dmFyIHBhZ2VDbGFzc2VzID0gW107XG5cblx0XHR0aGlzLl9hZGRQYWdlTWlkZGxld2FyZVRvQXJyYXkodGhpcy5fZ2xvYmFsTWlkZGxld2FyZSwgcGFnZUNsYXNzZXMpO1xuXHRcdHRoaXMuX2FkZFBhZ2VNaWRkbGV3YXJlVG9BcnJheShbcGFnZUNvbnN0cnVjdG9yXSwgcGFnZUNsYXNzZXMpO1xuXG5cdFx0dmFyIHBhZ2VzID0gcGFnZUNsYXNzZXMubWFwKChwYWdlQ2xhc3MpID0+IHtcblx0XHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwYWdlQ2xhc3MpLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBpbnN0YW50aWF0ZSBhIHBhZ2Ugb3IgbWlkZGxld2FyZSBjbGFzcyB0aGF0IHdhcyBhbiBlbXB0eSBvYmplY3QuIERpZCB5b3UgZm9yZ2V0IHRvIGFzc2lnbiBhIGNsYXNzIHRvIG1vZHVsZS5leHBvcnRzP1wiKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXcgcGFnZUNsYXNzKCk7XG5cdFx0fSk7XG5cdFx0dmFyIHBhZ2UgPSBQYWdlVXRpbC5jcmVhdGVQYWdlQ2hhaW4ocGFnZXMpO1xuXG5cdFx0dGhpcy5lbWl0KFwicGFnZVwiLCBwYWdlKTtcblxuXHRcdHBhZ2Uuc2V0UmVxdWVzdChyZXF1ZXN0KTtcblxuXHRcdFBhZ2VVdGlsLlBhZ2VDb25maWcuaW5pdEZyb21QYWdlV2l0aERlZmF1bHRzKHBhZ2UsIHtcblx0XHRcdGlzRnJhZ21lbnQgICAgOiBmYWxzZSxcblx0XHRcdGlzUmF3UmVzcG9uc2UgOiBmYWxzZSxcblx0XHR9KTtcblxuXHRcdC8vIFNldCB0aGUgcGFnZSBjb250ZXh0IG9uIHRoZSByZXNwb25zZSBsb2dnZXIgc28gaXQgY2FuIGZpZ3VyZVxuXHRcdC8vIG91dCB3aGV0aGVyIHRvIGZsdXNoIGxvZ3MgdG8gdGhlIHJlc3BvbnNlIGRvY3VtZW50XG5cdFx0c2V0UmVzcG9uc2VMb2dnZXJQYWdlKHBhZ2UpO1xuXG5cdFx0Ly8gY2FsbCBwYWdlLmhhbmRsZVJvdXRlKCksIGFuZCB1c2UgdGhlIHJlc3VsdGluZyBjb2RlIHRvIGRlY2lkZSBob3cgdG9cblx0XHQvLyByZXNwb25kLlxuXHRcdC8vIFdlIGNhbGwgaXQgaW4gYSBwcm9taXNlIGhhbmRsZXIgc28gYW55IGV4Y2VwdGlvbiB0aGF0XG5cdFx0Ly8gYXJpc2VzIHdpbGwgZ2V0IGNvbnZlcnRlZCB0byBhIHJlamVjdGlvbiB0aGF0IHdlIGNhbiBoYW5kbGVcblx0XHQvLyBiZWxvdy5cblx0XHRRKCkudGhlbihwYWdlLmhhbmRsZVJvdXRlKS50aGVuKGhhbmRsZVJvdXRlUmVzdWx0ID0+IHtcblxuXHRcdFx0cGFnZS5zZXRTdGF0dXMoaGFuZGxlUm91dGVSZXN1bHQuY29kZSk7XG5cblx0XHRcdHBhZ2Uuc2V0SGFzRG9jdW1lbnQoaGFuZGxlUm91dGVSZXN1bHQuaGFzRG9jdW1lbnQpO1xuXG5cdFx0XHRwYWdlLnNldEpzQmVsb3dUaGVGb2xkKERlYnVnVXRpbC5nZXRKc0JlbG93VGhlRm9sZCgpIHx8IGhhbmRsZVJvdXRlUmVzdWx0LmpzQmVsb3dUaGVGb2xkKTtcblx0XHRcdHBhZ2Uuc2V0U3BsaXRKc0xvYWQoRGVidWdVdGlsLmdldFNwbGl0SnNMb2FkKCkgfHwgaGFuZGxlUm91dGVSZXN1bHQuc3BsaXRKc0xvYWQpO1xuXG5cdFx0XHQvLyBUT0RPOiBJIHRoaW5rIHRoYXQgM3h4LzR4eC81eHggc2hvdWxkbid0IGJlIGNvbnNpZGVyZWQgXCJlcnJvcnNcIiBpbiBuYXZpZ2F0ZURvbmUsIGJ1dCB0aGF0J3Ncblx0XHRcdC8vIGhvdyB0aGUgY29kZSBpcyBzdHJ1Y3R1cmVkIHJpZ2h0IG5vdywgYW5kIEknbSBjaGFuZ2luZyB0b28gbWFueSB0aGluZ3MgYXQgb25jZSBhdCB0aGUgbW9tZW50LiAtc3JhLlxuXHRcdFx0aWYgKGhhbmRsZVJvdXRlUmVzdWx0LmNvZGUgJiYgKChoYW5kbGVSb3V0ZVJlc3VsdC5jb2RlIC8gMTAwKXwwKSAhPT0gMikge1xuXHRcdFx0XHR0aGlzLmVtaXQoXCJuYXZpZ2F0ZURvbmVcIiwge3N0YXR1czogaGFuZGxlUm91dGVSZXN1bHQuY29kZSwgcmVkaXJlY3RVcmw6IGhhbmRsZVJvdXRlUmVzdWx0LmxvY2F0aW9ufSwgcGFnZSwgcmVxdWVzdC5nZXRVcmwoKSwgdHlwZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmIChoYW5kbGVSb3V0ZVJlc3VsdC5wYWdlKSB7XG5cdFx0XHRcdC8vIGluIHRoaXMgY2FzZSwgd2Ugc2hvdWxkIGZvcndhcmQgdG8gYSBuZXcgcGFnZSAqd2l0aG91dCogY2hhbmdpbmcgdGhlIFVSTC4gU2luY2Ugd2UgYXJlIGFscmVhZHlcblx0XHRcdFx0Ly8gaW4gYW4gYXN5bmMgY2FsbGJhY2ssIHdlIHNob3VsZCBzY2hlZHVsZSBhIG5ldyBoYW5kbGVQYWdlIHdpdGggdGhlIG5ldyBwYWdlIGNvbnN0cnVjdG9yIGFuZCByZXR1cm5cblx0XHRcdFx0Ly8gZnJvbSB0aGlzIGNhbGwuXG5cdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oYW5kbGVQYWdlKGhhbmRsZVJvdXRlUmVzdWx0LnBhZ2UsIHJlcXVlc3QsIHR5cGUpLCAwKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmVtaXQoJ25hdmlnYXRlRG9uZScsIG51bGwsIHBhZ2UsIHJlcXVlc3QuZ2V0VXJsKCksIHR5cGUpO1xuXHRcdH0pLmNhdGNoKGVyciA9PiB7XG5cdFx0XHRsb2dnZXIuZXJyb3IoXCJFcnJvciB3aGlsZSBoYW5kbGluZyByb3V0ZVwiLCBlcnIpO1xuXG5cdFx0XHR0aGlzLmVtaXQoJ25hdmlnYXRlRG9uZScsIHtzdGF0dXM6IDUwMH0sIHBhZ2UsIHJlcXVlc3QuZ2V0VXJsKCksIHR5cGUpO1xuXHRcdH0pO1xuXG5cdH1cblxuXHQvKipcblx0ICogcmVjdXJzaXZlbHkgYWRkcyB0aGUgbWlkZGxld2FyZSBpbiB0aGUgcGFnZXMgYXJyYXkgdG8gYXJyYXkuXG5cdCAqL1xuXHRfYWRkUGFnZU1pZGRsZXdhcmVUb0FycmF5KHBhZ2VzLCBhcnJheSkge1xuXHRcdGlmICghcGFnZXMpIHJldHVybjtcblx0XHRwYWdlcy5mb3JFYWNoKChwYWdlKSA9PiB7XG5cdFx0XHRpZiAocGFnZS5taWRkbGV3YXJlKSB7XG5cdFx0XHRcdHRoaXMuX2FkZFBhZ2VNaWRkbGV3YXJlVG9BcnJheShwYWdlLm1pZGRsZXdhcmUoKSwgYXJyYXkpO1xuXHRcdFx0fVxuXHRcdFx0YXJyYXkucHVzaChwYWdlKTtcblx0XHR9KTtcblx0fVxuXG5cdGdldFN0YXRlICgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bG9hZGluZzogdGhpcy5fbG9hZGluZyxcblx0XHRcdHJvdXRlOiB0aGlzLl9jdXJyZW50Um91dGUsXG5cdFx0fVxuXHR9XG5cblx0Z2V0Q3VycmVudFJvdXRlICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY3VycmVudFJvdXRlO1xuXHR9XG5cblx0Z2V0TG9hZGluZyAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRpbmc7XG5cdH1cblxuXHRzdGFydFJvdXRlIChyb3V0ZSwgcmVxdWVzdCwgdHlwZSkge1xuXG5cdFx0Ly8gSWYgd2UncmUgYmVpbmcgY2FsbGVkIHdpdGggYSByZXF1ZXN0ZWQgcm91dGUsIHdlJ2xsIG5lZWQgdG9cblx0XHQvLyB0ZWxsIHRoZSBjYWxsZXIgd2hlbiB0aGV5IGNhbiBwcm9jZWVkIHdpdGggdGhlaXJcblx0XHQvLyBuYXZpZ2F0aW9uLlxuXHRcdHZhciBkZmQsIHByb21pc2U7XG5cblx0XHQvLyBXZSBuZWVkIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSByb3V0ZXMgYXJlIHJlcXVlc3RlZCB3aGlsZVxuXHRcdC8vIHdlJ3JlIGhhbmRsaW5nIHRoZSBwcmV2aW91cyBuYXZpZ2F0aW9uLiAgVGhpcyBjYW4gaGFwcGVuIGlmXG5cdFx0Ly8gdGhlIHVzZXIgZnVyaW91c2x5IGNsaWNrcyB0aGUgYnJvd3NlcidzIGZvcndhcmQvYmFja1xuXHRcdC8vIG5hdmlnYXRpb24gYnV0dG9ucy5cblx0XHQvL1xuXHRcdC8vIFdlIGRvbid0IHdhbnQgYSBfcXVldWVfIGhlcmUsIGJlY2F1c2Ugd2UncmUgb25seSB1bHRpbWF0ZWx5XG5cdFx0Ly8gZ29pbmcgdG8gc2hvdyB0aGUgdXNlciB0aGUgX2ZpbmFsXyByb3V0ZSB0aGF0J3MgcmVxdWVzdGVkLFxuXHRcdC8vIHNvIHdlJ2xsIGp1c3Qga2VlcCBhIHNpbmdsZSByZWZlcmVuY2UgdG8gdGhlIG5leHQgcm91dGUgd2Vcblx0XHQvLyBuZWVkIHRvIGFjdHVhbGx5IHJlbmRlciBvbmNlIG91ciBjdXJyZW50IG5hdmlnYXRpb24gaXNcblx0XHQvLyBjb21wbGV0ZS5cblx0XHQvL1xuXHRcdGlmIChyZXF1ZXN0KSB7XG5cblx0XHRcdC8vIFdlIGRvbid0IHdhbnQgdG8gbGVhdmUgbmF2aWdhdGlvbiBkZXRyaXR1c1xuXHRcdFx0Ly8gbGF5aW5nIGFyb3VuZCBhcyB3ZSBkaXNjYXJkIGJ5cGFzc2VkIHBhZ2VzLlxuXHRcdFx0aWYgKHRoaXMuX25leHRSb3V0ZSkgdGhpcy5fbmV4dFJvdXRlLmRmZC5yZWplY3QoKTtcblxuXHRcdFx0ZGZkID0gUS5kZWZlcigpLCBwcm9taXNlID0gZGZkLnByb21pc2U7XG5cblx0XHRcdHRoaXMuX25leHRSb3V0ZSA9IHtyb3V0ZSwgcmVxdWVzdCwgdHlwZSwgZGZkfTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSdyZSBfY3VycmVudGx5XyBuYXZpZ2F0aW5nLCB3ZSdsbCB3YWl0IHRvIHN0YXJ0IHRoZVxuXHRcdC8vIG5leHQgcm91dGUgdW50aWwgdGhpcyBuYXZpZ2F0aW9uIGlzIGNvbXBsZXRlLiAgSW50ZXJsZWF2ZWRcblx0XHQvLyBuYXZpZ2F0aW9uIGNhdXNlcyBhbGwga2luZHMgb2YgaGF2b2MuXG5cdFx0aWYgKCF0aGlzLl9sb2FkaW5nICYmIHRoaXMuX25leHRSb3V0ZSl7XG5cblx0XHRcdGNvbnN0IHtyb3V0ZSwgcmVxdWVzdCwgdHlwZSwgZGZkfSA9IHRoaXMuX25leHRSb3V0ZTtcblxuXHRcdFx0dGhpcy5fbG9hZGluZyAgICAgID0gdHJ1ZTtcblx0XHRcdHRoaXMuX2N1cnJlbnRSb3V0ZSA9IHJvdXRlO1xuXHRcdFx0dGhpcy5fbmV4dFJvdXRlICAgID0gbnVsbDtcblxuXHRcdFx0dGhpcy5lbWl0KCduYXZpZ2F0ZVN0YXJ0Jywge3JvdXRlLCByZXF1ZXN0LCB0eXBlfSk7XG5cblx0XHRcdC8vIFRoaXMgYWxsb3dzIHRoZSBhY3R1YWwgbmF2aWdhdGlvbiB0b1xuXHRcdFx0Ly8gcHJvY2VlZC5cblx0XHRcdGRmZC5yZXNvbHZlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByb21pc2U7XG5cdH1cblxuXHRmaW5pc2hSb3V0ZSAoKSB7XG5cdFx0dGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5lbWl0KCdsb2FkQ29tcGxldGUnKTtcblxuXHRcdC8vIElmIG90aGVyIHJvdXRlcyB3ZXJlIHF1ZXVlZCB3aGlsZSB3ZSB3ZXJlIG5hdmlnYXRpbmcsIHdlJ2xsXG5cdFx0Ly8gc3RhcnQgdGhlIG5leHQgb25lIHJpZ2h0IG9mZi5cblx0XHQvL1xuXHRcdHRoaXMuc3RhcnRSb3V0ZSgpO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTmF2aWdhdG9yO1xuIl19
