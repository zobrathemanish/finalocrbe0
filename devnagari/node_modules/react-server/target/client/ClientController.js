'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = require('react'),
    ReactDOM = require('react-dom'),
    logging = require('./logging'),
    RequestContext = require('./context/RequestContext'),
    RequestLocalStorage = require('./util/RequestLocalStorage'),
    DebugUtil = require('./util/DebugUtil'),
    Q = require('q'),
    cssHelper = require('./util/ClientCssHelper'),
    EventEmitter = require("events").EventEmitter,
    ClientRequest = require("./ClientRequest"),
    History = require('./components/History'),
    PageUtil = require("./util/PageUtil"),
    ReactServerAgent = require('./ReactServerAgent'),
    _require = require('./components/RootElement'),
    getRootElementAttributes = _require.getRootElementAttributes,
    _require2 = require('./constants'),
    PAGE_LINK_NODE_ID = _require2.PAGE_LINK_NODE_ID,
    PAGE_CONTAINER_NODE_ID = _require2.PAGE_CONTAINER_NODE_ID;


var _ = {
	forEach: require('lodash/forEach'),
	assign: require('lodash/assign')
};

var RLS = RequestLocalStorage.getNamespace();

var logger = logging.getLogger({ "name": "react-server.core.ClientController", "color": { "server": 63, "client": "rgb(42,42,212)" } });

// for dev tools
window.React = React;

var REACT_SERVER_DATA_ATTRIBUTE = "data-react-server-root-id";

/**
 * Set up a Q error handler to make sure that errors that bubble
 * up are logged via our logger. Note: This will affect all unhandled
 * Q promise rejections, not just the ones in this file.
 */
Q.onerror = function (err) {
	logger.error("Unhandled exception in Q promise", err);
};

function getHistoryStateFrame(request) {

	// Mark the frame as ours.
	// Stash the request opts that were used to navigate to this frame.
	return { reactServerFrame: request ? request.getOpts() : {} };
}

function getHistoryPathname() {
	return location.pathname + location.search + location.hash;
}

var ClientController = function (_EventEmitter) {
	_inherits(ClientController, _EventEmitter);

	function ClientController(_ref) {
		var routes = _ref.routes;

		_classCallCheck(this, ClientController);

		var _this = _possibleConstructorReturn(this, (ClientController.__proto__ || Object.getPrototypeOf(ClientController)).call(this));

		window.__reactServerTimingStart = window.performance ? window.performance.timing.navigationStart : undefined;

		var dehydratedState = window.__reactServerState;

		checkNotEmpty(dehydratedState, 'InitialContext');
		checkNotEmpty(dehydratedState, 'Config');

		RequestLocalStorage.startRequest();

		_this.config = buildConfig(dehydratedState.Config);

		if (routes.onClientConfigLoaded) {
			routes.onClientConfigLoaded.call(_this);
		}

		_this.context = buildContext(routes);
		_this.context.setDeviceType(dehydratedState.InitialContext.deviceType);
		ReactServerAgent.cache().rehydrate(dehydratedState.InitialContext['ReactServerAgent.cache']);
		_this.mountNode = document.getElementById('content');

		_this._setupNavigateListener();
		_this._setupArrivalHandlers();

		_this._previouslyRendered = false;
		_this._rootNodeDfds = [];
		_this._failDfd = Q.defer();

		// Log this after loglevel is set.
		logTimingData('wakeFromStart', window.__reactServerTimingStart);

		performanceMark('wake');

		// this is a proxy for when above the fold content gets painted (displayed) on the browser
		logTimingData('displayAboveTheFold.fromStart', window.__reactServerTimingStart, window.__displayAboveTheFold);
		return _this;
	}

	_createClass(ClientController, [{
		key: 'terminate',
		value: function terminate() {
			// We may not have set up any history stuff...
			if (!this._history) return;
			this._history.off(this._historyListener);
			this._historyListener = null;
			this._history = null;
		}
	}, {
		key: '_startRequest',
		value: function _startRequest(_ref2) {
			var request = _ref2.request,
			    type = _ref2.type;


			var t0 = type === History.events.PAGELOAD ? window.__reactServerTimingStart // Try to use navigation timing.
			: new Date(); // There's no naviagation.  We're it.

			var url = request.getUrl();
			var isPush = type === History.events.PUSHSTATE;

			// This is the navigator we're going to listen to regarding when navigation
			// is complete for timing purposes.
			var navigationTimingAuthority = this.context.navigator;

			this._reuseDom = request.getReuseDom();

			if (this._previouslyRendered) {

				// This is a secondary request (client transition)
				// within a session, so we'll get a fresh
				// RequestLocalStorage container.
				RequestLocalStorage.startRequest();

				// If we're not going to reuse the DOM, let's
				// clean up right away to blank the screen.
				if (!this._reuseDom) {
					this._cleanupPreviousRender();
				}

				// we need to re-register the request context
				// as a RequestLocal.
				this.context.registerRequestLocal();
			}

			// If this is a History.events.PUSHSTATE navigation,
			// and we have control of the navigation bar we should
			// change the URL in the location bar before rendering.
			//
			// Note that for browsers that do not have pushState,
			// this will result in a window.location change and
			// full browser load.
			//
			if (this._history) {

				if (isPush) {

					// Sorry folks.  If we need to do a client
					// transition, then we're going to clobber
					// your state.  You must be able to render
					// from URL, anyway, so if you're set up right
					// it won't affect user experience.  It means,
					// though, that there exists a navigation path
					// to an extraneous full-page rebuild.
					// Such is life.
					if (
					// Don't replace state unless we've
					// got a real history API.
					this._history.canClientNavigate() && !(history.state || {}).reactServerFrame) {
						this._history.replaceState(getHistoryStateFrame(), null, getHistoryPathname());
					}

					this._setHistoryRequestOpts({
						// If we're reusing the DOM on the way
						// forward, then we can also reuse on
						// the way back.
						reuseDom: request.getReuseDom()
					});

					this._history.pushState(getHistoryStateFrame(request), null, url);
				} else if (type === History.events.PAGELOAD) {

					// This _seems_ redundant with the
					// `replaceState` above, but keep in mind that
					// an initial `pushState` might not be a
					// client transition.  It could be a
					// non-`react-server` use of the history API.
					//
					// This also _replaces_ state with the request
					// URL, which handles client-side redirects.
					this._history.replaceState(getHistoryStateFrame(request), null, url);

					this._setHistoryRequestOpts({

						// If we wind up back here without
						// first client-transitioning away
						// then presumably we're still on the
						// same page that just had some
						// history maniptulation outside of
						// `react-server`.  In that case we're
						// ourselves and we should be able to
						// re-use the DOM.  Maybe
						// presumptuous, but a nicer
						// experience than clobbering.
						reuseDom: true
					});
				}
			}

			// logging how long the request took in a variety of ways:
			// - Request type (pageload, pushstate, popstate)
			// - Request options (reuseDom, bundleData, etc)
			navigationTimingAuthority.once('loadComplete', function () {
				var bas = 'handleRequest';
				var typ = 'type.' + (type || 'PAGELOAD');
				logTimingData(bas + '.all', t0);
				logTimingData(bas + '.' + typ + '.all', t0);
				_.forEach(request.getOpts(), function (val, key) {
					if (val) {
						var opt = 'opt.' + key;
						logTimingData(bas + '.' + opt, t0);
						logTimingData(bas + '.' + typ + '.' + opt, t0);
					}
				});
			});

			this._lastState = history.state;
		}

		// Update the request options for the _current_ history navigation
		// state frame prior to pushing a new frame.

	}, {
		key: '_setHistoryRequestOpts',
		value: function _setHistoryRequestOpts(opts) {

			// If we don't have a real history API then we don't want to
			// mess with state since it results in full navigation.
			if (!this._history.canClientNavigate()) return;

			var state = _.assign({}, history.state);
			state.reactServerFrame = _.assign(state.reactServerFrame || {}, opts);
			this._history.replaceState(state, null, getHistoryPathname());
		}
	}, {
		key: '_setupNavigateListener',
		value: function _setupNavigateListener() {
			var _this2 = this;

			var context = this.context;

			context.onNavigateStart(this._startRequest.bind(this));

			/**
    * type is one of
    *    History.events.PUSHSTATE: user clicked something to go forward but browser didn't do a
    * full page load
    *    History.events.POPSTATE: user clicked back button but browser didn't do a full page load
    *    History.events.PAGELOAD: full browser page load, not using History API.
    */
			context.onNavigate(function (err, page) {
				logger.debug('Executing navigate action');

				_this2._handleDebugParams(page);

				if (err) {
					// redirects are sent as errors, so let's handle it if that's the case.
					if (err.status && (err.status === 301 || err.status === 302)) {
						if (!err.redirectUrl) {
							console.error("A redirect status was sent without a corresponding redirect redirectUrl.", err);
						} else {
							setTimeout(function () {
								// we're about to load the _next_ page, so we should mark the
								// redirect navigation finished
								context.navigator.finishRoute();
								context.navigate(new ClientRequest(err.redirectUrl));
							}, 0);
						}
					} else {
						logger.error("onNavigate error", err);
					}
					return;
				}

				var routeName = context.navigator.getCurrentRoute().name;

				if (!_this2._previouslyRendered) {
					cssHelper.registerPageLoad(routeName);
				} else {
					// render the document title.
					_this2._renderTitle(page);

					// render the base tag.
					_this2._renderBase(page);

					_this2._renderMetaTags(page);

					_this2._renderLinkTags(page);
				}

				cssHelper.ensureCss(routeName, page).then(function () {
					return page.getBodyClasses().then(function (classes) {
						classes.push('route-' + routeName);
						document.body.className = classes.join(' ');
					});
				}).then(function () {
					return _this2._render(page);
				}).catch(function (err) {
					logger.error("Error during client transition render", err);
				}).then(function () {

					// We're responsible for letting the navigator
					// know when we're more or less done stomping
					// around in the current request context
					// setting things up.
					//
					// We can't _guarantee_ that pages/middleware
					// haven't set timers to mess with things in
					// the future, so we need to wait a bit before
					// letting the navigator yank our context if
					// an immediate subsequent navigation is
					// scheduled.
					//
					// I don't like this magic delay here, but it
					// gives us a better shot at falling after
					// things like lazy load images do their
					// post-render wire-up.
					//
					// Anything that the current page does in the
					// request context _after_ this timeout has
					// elapsed and we've started a subsequent
					// navigation is pure corruption. :p
					//
					setTimeout(function () {
						return context.navigator.finishRoute();
					}, 200);
				}).done();
			});
		}
	}, {
		key: '_handleDebugParams',
		value: function _handleDebugParams(page) {
			if (!page) return;

			DebugUtil.setRequest(page.getRequest());

			var params = DebugUtil.getAllDebugValues();

			// Allow adjustment of log levels.
			_.forEach({
				_react_server_log_level: 'main',
				_react_server_log_level_main: 'main',
				_react_server_log_level_time: 'time',
				_react_server_log_level_gauge: 'gauge'
			}, function (type, param) {
				if (params[param]) {
					logging.setLevel(type, params[param]);
				}
			});
		}
	}, {
		key: '_renderTitle',
		value: function _renderTitle(page) {
			var _this3 = this;

			page.getTitle().then(function (newTitle) {
				if (newTitle && newTitle !== document.title) {
					document.title = newTitle;
				}

				// This is the earliest we have everything we need for
				// an analytics pageview event.
				_this3.emit("pageview", {
					page: getHistoryPathname(),
					title: newTitle
				});
			}).catch(function (err) {
				logger.error("Error while setting the document title", err);
			}).done();
		}
	}, {
		key: '_renderBase',
		value: function _renderBase(page) {
			page.getBase().then(function (base) {
				var currentBaseTag = document.head.querySelector("head base");
				if (base === null) {
					// get rid of the current base tag.
					if (currentBaseTag) currentBaseTag.parentNode.removeChild(currentBaseTag);
				} else {
					// we need a base tag. add one if it's not there yet.
					if (!currentBaseTag) {
						currentBaseTag = document.createElement("base");
						document.head.appendChild(currentBaseTag);
					}
					if (base.href) currentBaseTag.href = base.href;
					if (base.target) currentBaseTag.target = base.target;
				}
			}).catch(function (err) {
				logger.error("Error rendering <base>", err);
			}).done();
		}
	}, {
		key: '_renderMetaTags',
		value: function _renderMetaTags(page) {
			// first, remove all the current meta tags.
			var currentMetaTags = document.head.querySelectorAll("meta");
			for (var i = 0; i < currentMetaTags.length; i++) {
				currentMetaTags[i].parentNode.removeChild(currentMetaTags[i]);
			}

			// now add all the meta tags for the new page.
			page.getMetaTags().forEach(function (metaTagPromise) {
				metaTagPromise.then(function (metaTag) {
					var parent = document.head;
					if (metaTag.noscript) {
						var noscript = document.createElement("noscript");
						parent.appendChild(noscript);
						parent = noscript;
					}

					var meta = document.createElement("meta");
					["name", "httpEquiv", "charset", "content"].forEach(function (name) {
						if (metaTag[name]) meta[name] = metaTag[name];
					});

					parent.appendChild(meta);
				}).catch(function (err) {
					logger.error("Error rendering meta tags", err);
				}).done();
			});
		}
	}, {
		key: '_renderLinkTags',
		value: function _renderLinkTags(page) {

			// First, remove all the current link tags.
			;[].slice.call(document.head.querySelectorAll('link[' + PAGE_LINK_NODE_ID + ']')).forEach(function (tag) {
				return tag.parentNode.removeChild(tag);
			});

			// Then add all the link tags for the new page.
			page.getLinkTags().forEach(function (promise) {
				return promise.then(PageUtil.makeArray).then(function (tags) {
					return tags.forEach(function (tag) {
						document.head.appendChild([document.createElement('link'), PAGE_LINK_NODE_ID].concat(Object.keys(tag)).reduce(function (link, attr) {
							return link.setAttribute(attr, tag[attr] || ''), link;
						}));
					});
				}).catch(function (err) {
					return logger.error("Error rendering link tags", err);
				}).done();
			});
		}
	}, {
		key: '_render',
		value: function _render(page) {
			var _this4 = this;

			var tStart = window.__reactServerTimingStart;
			var t0 = new Date();
			var retval = Q.defer();

			logger.debug('React Rendering');

			// We keep track of the _total_ time we spent rendering during
			// each request so we can keep track of that overhead.
			var totalRenderTime = 0;

			// These resolve with React elements when their data
			// dependencies are fulfilled.
			var elementPromises = PageUtil.standardizeElements(page.getElements());
			var timeoutDfd = [];
			var elementPromisesOr = elementPromises.map(function (promise, index) {
				var orPromise = Q.defer();
				timeoutDfd[index] = Q.defer();

				promise.then(orPromise.resolve);
				promise.catch(orPromise.reject);
				timeoutDfd[index].promise.catch(orPromise.reject);

				return orPromise.promise;
			});

			// These resolve with DOM mount points for the elements.
			//
			// Our behavior is different here for the _first_ render vs
			// during a client transition.
			var rootNodePromises;
			if (this._previouslyRendered) {

				// On a client transition we've just blown away all of
				// our mount points from the previous page, and we'll
				// create a fresh set.  We'll defer creating them
				// until we've actually got our elements, since some
				// items in the elements array may be container
				// control.
				rootNodePromises = elementPromises.map(function () {
					return Q();
				});
			} else {

				// On our _first_ render we want to mount to the DOM
				// nodes produced during the _server-side_ render.
				//
				// We're awake and doing our thing while these
				// server-rendered elements are streaming down, so we
				// need to wait to render a given element until its
				// mount point arrives.
				//
				// The server will tell us when each mount point is
				// ready by calling `nodeArrival`, which triggers
				// resolution of the corresponding `rootNodePromise`.
				elementPromises.forEach(function (promise, index) {
					_this4._ensureRootNodeDfd(index);
				});
				rootNodePromises = this._rootNodeDfds.map(function (dfd) {
					return dfd.promise;
				});
			}

			var mountNode = this.mountNode;

			// These are only used if we're going to try to re-use the
			// existing DOM structure.
			var oldRootElement, oldRootContainer;

			// Once we've got an element and a root DOM node to mount it
			// in we can finally render.
			var renderElement = function renderElement(element, root, index) {

				// During client transitions we create our root
				// elements as we go.
				if (!root && _this4._previouslyRendered) {

					// If the _previous_ render had elements that
					// we can re-use we'll render into them.
					//
					// DOM re-use is currently opt-in.
					//
					if (_this4._reuseDom) {
						oldRootElement = document.querySelector('div[' + REACT_SERVER_DATA_ATTRIBUTE + '="' + index + '"]');
						oldRootContainer = document.querySelector('div[' + PAGE_CONTAINER_NODE_ID + '="' + index + '"]');
					}

					// The current strategy for re-use is: So long
					// as the _shape_ of the root structure is the
					// same, we'll re-use.  Once the new page's
					// shape diverges, we'll blow away the
					// remaining elements left over from the
					// previous page and create everything for the
					// new page as we go.
					//
					if (_this4._reuseDom && element.containerOpen && oldRootContainer) {
						mountNode = oldRootContainer;
						_this4._updateContainerNodeAttributes(mountNode, element.containerOpen);
					} else if (_this4._reuseDom && element.containerClose && !oldRootContainer && !oldRootElement) {
						mountNode = mountNode.parentNode;
					} else if (_this4._reuseDom && oldRootElement) {
						root = oldRootElement;
					} else {
						_this4._cleanupPreviousRender(index);
						if (element.containerOpen) {

							// If we're opening a container that's
							// our new mountNode.
							mountNode = _this4._createContainerNode(mountNode, element.containerOpen, index);
						} else if (element.containerClose) {

							// If we're closing a container its
							// parent is once again our mountNode.
							mountNode = mountNode.parentNode;
						} else if (!element.isTheFold) {

							// Need a new root element in our
							// current mountNode.
							root = _this4._createReactServerRootNode(mountNode, index);
						}
					}
				}

				if (element.containerOpen || element.containerClose) {
					return; // Nothing left to do.
				} else if (element.isTheFold) {
					if (!_this4._previouslyRendered) {
						logTimingData('renderAboveTheFold.fromStart', tStart);
						logTimingData('renderAboveTheFold.individual', 0, totalRenderTime);
						logTimingData('renderAboveTheFold.elementCount', 0, index + 1);

						performanceMark('renderAboveTheFold');
					}
					return; // Again, this isn't a real root element.
				}

				var name = PageUtil.getElementDisplayName(element),
				    timer = logger.timer('renderElement.individual.' + name);

				element = React.cloneElement(element, { context: _this4.context });
				var renderFunc = ReactDOM.hydrate || ReactDOM.render;
				renderFunc(element, root);

				_.forEach(getRootElementAttributes(element), function (v, k) {
					return root.setAttribute(k, v);
				});

				totalRenderTime += timer.stop();

				if (!_this4._previouslyRendered) {
					var tDisplay = root.getAttribute('data-react-server-timing-offset');
					logTimingData('displayElement.fromStart.' + name, 0, +tDisplay);
					logTimingData('renderElement.fromStart.' + name, tStart);
				}
			};

			var renderOne = function renderOne(promise, index) {
				return promise.then(function (element) {
					return rootNodePromises[index].then(function (root) {
						return renderElement(element, root, index);
					}).catch(function (e) {
						// The only case where this should evaluate to false is
						// when `element` is a containerClose/containerOpen object
						var componentType = typeof element.type === 'function' ? element.props.children.type.name : 'element';
						logger.error('Error with element ' + componentType + '\'s lifecycle methods at index ' + index, e);
					});
				}).catch(function (e) {
					return logger.error('Error with element promise ' + index, e);
				});
			};

			if (this._previouslyRendered) {

				// On client transitions the root structure is laid out using a
				// state machine that requires us to render in order.
				elementPromisesOr.reduce(function (chain, promise, index) {
					return chain.then(function () {
						return renderOne(promise, index);
					});
				}, Q()).then(retval.resolve);
			} else {

				// On the first render we can go out of order because the server
				// has already laid out the root structure for us.
				Q.all(elementPromisesOr.map(renderOne)).then(retval.resolve);

				// Look out for a failsafe timeout from the server on our
				// first render.
				this._failDfd.promise.then(function () {
					elementPromises.forEach(function (promise, index) {
						//Reject any elements that have failed to render
						if (promise.isPending()) {
							timeoutDfd[index].reject('Error with element ' + index + ', it failed to render within timeout time');
						}
					});
				});
			}

			return retval.promise.then(function () {

				if (_this4._reuseDom) {

					// Clean up any dangling nodes if the previous page had more
					// than we do.
					_this4._cleanupPreviousRender(elementPromises.length);
				}

				// This first one is just for historical continuity.
				logTimingData('render', t0);

				// These are more interesting.
				logTimingData('renderCPUTime', 0, totalRenderTime);

				// Don't track this on client transitions.
				if (!_this4._previouslyRendered) {
					logTimingData('renderFromStart', tStart);

					performanceMark('renderComplete');
				}

				// Some things are just different on our first pass.
				_this4._previouslyRendered = true;

				_this4.emit('render');
			});
		}

		/**
   * Cleans up a previous React render in the document. Unmounts all the components and destoys the mounting
   * DOM node(s) that were created.
   */

	}, {
		key: '_cleanupPreviousRender',
		value: function _cleanupPreviousRender(index) {

			index = index || 0; // Default to everything.

			if (this._previouslyRendered && !RLS().haveCleanedPreviousRender) {

				// Only need to do this once per request.
				RLS().haveCleanedPreviousRender = true;

				logger.debug("Removing previous page's React components");

				[].slice.call(document.querySelectorAll('div[' + REACT_SERVER_DATA_ATTRIBUTE + ']')).forEach(function (root, i) {
					if (i >= index) {
						// Since this node has a "data-react-server-root-id"
						// attribute, we can assume that we created it
						// and should destroy it. Destruction means
						// first unmounting from React and then
						// destroying the DOM node.
						ReactDOM.unmountComponentAtNode(root);
						root.parentNode.removeChild(root);
					}
				});

				[].slice.call(document.querySelectorAll('div[' + PAGE_CONTAINER_NODE_ID + ']')).forEach(function (root, i) {
					if (i >= index) {
						// Gotta get rid of our containers,
						// too.  Need to do this _after_
						// killing the elements, since they
						// might live within these containers.
						root.parentNode.removeChild(root);
					}
				});
			}
		}

		/**
   * This method creates a new div to render a ReactElement in to at the end of the mount node.
   */

	}, {
		key: '_createReactServerRootNode',
		value: function _createReactServerRootNode(mountNode, index) {
			var root = document.createElement("div");
			root.setAttribute(REACT_SERVER_DATA_ATTRIBUTE, index);
			mountNode.appendChild(root);
			return root;
		}
	}, {
		key: '_createContainerNode',
		value: function _createContainerNode(mountNode, attrs, i) {
			var node = document.createElement("div");
			node.setAttribute(PAGE_CONTAINER_NODE_ID, i);
			_.forEach(attrs, function (v, k) {
				return node.setAttribute(k, v);
			});
			mountNode.appendChild(node);
			return node;
		}
	}, {
		key: '_updateContainerNodeAttributes',
		value: function _updateContainerNodeAttributes(node, attrs) {
			_.forEach(attrs, function (v, k) {
				return node.setAttribute(k, v);
			});
		}
	}, {
		key: 'init',
		value: function init() {
			var _this5 = this;

			var unloadHandler = function unloadHandler() {
				_this5.terminate();
			};

			if (window && window.addEventListener) {
				window.addEventListener("unload", unloadHandler);
			} else if (window && window.attachEvent) {
				window.attachEvent("onunload", unloadHandler);
			}

			this._initializeHistoryListener(this.context);

			// If this is a _refresh_ there may be some request options
			// stashed in the history navigation stack frame we're sitting
			// on.
			var state = this._history.canClientNavigate() && history.state;

			this._navigateWithHistoryState({
				state: state,
				path: getHistoryPathname(),
				type: History.events.PAGELOAD
			});
		}
	}, {
		key: '_navigateWithHistoryState',
		value: function _navigateWithHistoryState(_ref3) {
			var path = _ref3.path,
			    state = _ref3.state,
			    type = _ref3.type,
			    check = _ref3.check;

			var opts = (state || {}).reactServerFrame;

			if (check && !opts) return; // Not our frame.

			this.context.navigate(new ClientRequest(path, opts || {}), type);
		}

		/**
   * Initializes us to listen to back button events. When the user presses the back button, the history
   * listener will be called and cause a navigate() event.
   */

	}, {
		key: '_initializeHistoryListener',
		value: function _initializeHistoryListener() {
			var _this6 = this;

			this._historyListener = function (_ref4) {
				var state = _ref4.state;

				_this6._navigateWithHistoryState({
					state: state,
					path: _this6._history.getPath(),
					type: History.events.POPSTATE, // Forward/back.
					check: true // Only navigate if frame is ours.
				});
			};

			this._history = new History();
			var init = function init() {
				return _this6._history.on(_this6._historyListener);
			};

			// Need to go _after_ 'load' callbacks complete.
			// Safari fires a 'popstate' on load (RED-67600).
			// https://developer.mozilla.org/en-US/docs/Web/Events/popstate
			if (document.readyState === 'complete') {
				init();
			} else {
				window.addEventListener('load', function () {
					return setTimeout(init, 0);
				});
			}
		}
	}, {
		key: '_setupArrivalHandlers',
		value: function _setupArrivalHandlers() {
			// used by <script> callbacks to register data sent down on the
			// initial connection after initial render
			window.__reactServerClientController = this;
		}
	}, {
		key: '_ensureRootNodeDfd',
		value: function _ensureRootNodeDfd(index) {
			if (!this._rootNodeDfds[index]) {
				this._rootNodeDfds[index] = Q.defer();
			}
			return this._rootNodeDfds[index];
		}
	}, {
		key: 'dataArrival',
		value: function dataArrival(url, dehydratedEntry) {
			ReactServerAgent.cache().lateArrival(url, dehydratedEntry);
		}
	}, {
		key: 'nodeArrival',
		value: function nodeArrival(startIndex, endIndex) {

			// The server has just let us know that a pre-rendered root
			// element has arrived.  We'll grab a reference to its DOM
			// node and un-block client-side rendering of the element that
			// we're going to mount into it.
			for (var i = startIndex; i <= endIndex; i++) {
				this._ensureRootNodeDfd(i).resolve(this.mountNode.querySelector('div[' + REACT_SERVER_DATA_ATTRIBUTE + '="' + i + '"]'));
			}
		}
	}, {
		key: 'failArrival',
		value: function failArrival() {
			this._failDfd.resolve();
		}
	}]);

	return ClientController;
}(EventEmitter);

function checkNotEmpty(state, key) {
	if (typeof state[key] === 'undefined') {
		var msg = key + ' not defined in dehydrated state';
		logger.error(msg);
		throw new Error(msg);
	}
}

function buildConfig(dehydratedConfig) {
	// rehydrate the config object
	var config = require("./config")();
	config.rehydrate(dehydratedConfig);
	return config;
}

function buildContext(routes) {
	var context = new RequestContext.Builder().setRoutes(routes).create();

	return context;
}

// Create a "user timing" in WebPageTest.
function performanceMark(name) {
	if (window.performance && performance.mark) {
		performance.mark('react-server.' + name);
	}
}

function logTimingData(bucket, start) {
	var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Date();

	if (start === undefined) {
		//don't send timing data if start timing is undefined
		return;
	}

	logger.time(bucket, end - start);
}

module.exports = ClientController;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkNsaWVudENvbnRyb2xsZXIuanMiXSwibmFtZXMiOlsicmVxdWlyZSIsIlJlYWN0RE9NIiwibG9nZ2luZyIsIlJlcXVlc3RDb250ZXh0IiwiUmVxdWVzdExvY2FsU3RvcmFnZSIsIkRlYnVnVXRpbCIsIlEiLCJjc3NIZWxwZXIiLCJFdmVudEVtaXR0ZXIiLCJDbGllbnRSZXF1ZXN0IiwiSGlzdG9yeSIsIlBhZ2VVdGlsIiwiUmVhY3RTZXJ2ZXJBZ2VudCIsImdldFJvb3RFbGVtZW50QXR0cmlidXRlcyIsIlBBR0VfTElOS19OT0RFX0lEIiwiUEFHRV9DT05UQUlORVJfTk9ERV9JRCIsIl8iLCJmb3JFYWNoIiwiYXNzaWduIiwiUkxTIiwiZ2V0TmFtZXNwYWNlIiwibG9nZ2VyIiwiZ2V0TG9nZ2VyIiwid2luZG93IiwiUmVhY3QiLCJSRUFDVF9TRVJWRVJfREFUQV9BVFRSSUJVVEUiLCJvbmVycm9yIiwiZXJyIiwiZXJyb3IiLCJnZXRIaXN0b3J5U3RhdGVGcmFtZSIsInJlcXVlc3QiLCJyZWFjdFNlcnZlckZyYW1lIiwiZ2V0T3B0cyIsImdldEhpc3RvcnlQYXRobmFtZSIsImxvY2F0aW9uIiwicGF0aG5hbWUiLCJzZWFyY2giLCJoYXNoIiwiQ2xpZW50Q29udHJvbGxlciIsInJvdXRlcyIsIl9fcmVhY3RTZXJ2ZXJUaW1pbmdTdGFydCIsInBlcmZvcm1hbmNlIiwidGltaW5nIiwibmF2aWdhdGlvblN0YXJ0IiwidW5kZWZpbmVkIiwiZGVoeWRyYXRlZFN0YXRlIiwiX19yZWFjdFNlcnZlclN0YXRlIiwiY2hlY2tOb3RFbXB0eSIsInN0YXJ0UmVxdWVzdCIsImNvbmZpZyIsImJ1aWxkQ29uZmlnIiwiQ29uZmlnIiwib25DbGllbnRDb25maWdMb2FkZWQiLCJjYWxsIiwiY29udGV4dCIsImJ1aWxkQ29udGV4dCIsInNldERldmljZVR5cGUiLCJJbml0aWFsQ29udGV4dCIsImRldmljZVR5cGUiLCJjYWNoZSIsInJlaHlkcmF0ZSIsIm1vdW50Tm9kZSIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJfc2V0dXBOYXZpZ2F0ZUxpc3RlbmVyIiwiX3NldHVwQXJyaXZhbEhhbmRsZXJzIiwiX3ByZXZpb3VzbHlSZW5kZXJlZCIsIl9yb290Tm9kZURmZHMiLCJfZmFpbERmZCIsImRlZmVyIiwibG9nVGltaW5nRGF0YSIsInBlcmZvcm1hbmNlTWFyayIsIl9fZGlzcGxheUFib3ZlVGhlRm9sZCIsIl9oaXN0b3J5Iiwib2ZmIiwiX2hpc3RvcnlMaXN0ZW5lciIsInR5cGUiLCJ0MCIsImV2ZW50cyIsIlBBR0VMT0FEIiwiRGF0ZSIsInVybCIsImdldFVybCIsImlzUHVzaCIsIlBVU0hTVEFURSIsIm5hdmlnYXRpb25UaW1pbmdBdXRob3JpdHkiLCJuYXZpZ2F0b3IiLCJfcmV1c2VEb20iLCJnZXRSZXVzZURvbSIsIl9jbGVhbnVwUHJldmlvdXNSZW5kZXIiLCJyZWdpc3RlclJlcXVlc3RMb2NhbCIsImNhbkNsaWVudE5hdmlnYXRlIiwiaGlzdG9yeSIsInN0YXRlIiwicmVwbGFjZVN0YXRlIiwiX3NldEhpc3RvcnlSZXF1ZXN0T3B0cyIsInJldXNlRG9tIiwicHVzaFN0YXRlIiwib25jZSIsImJhcyIsInR5cCIsInZhbCIsImtleSIsIm9wdCIsIl9sYXN0U3RhdGUiLCJvcHRzIiwib25OYXZpZ2F0ZVN0YXJ0IiwiX3N0YXJ0UmVxdWVzdCIsImJpbmQiLCJvbk5hdmlnYXRlIiwicGFnZSIsImRlYnVnIiwiX2hhbmRsZURlYnVnUGFyYW1zIiwic3RhdHVzIiwicmVkaXJlY3RVcmwiLCJjb25zb2xlIiwic2V0VGltZW91dCIsImZpbmlzaFJvdXRlIiwibmF2aWdhdGUiLCJyb3V0ZU5hbWUiLCJnZXRDdXJyZW50Um91dGUiLCJuYW1lIiwicmVnaXN0ZXJQYWdlTG9hZCIsIl9yZW5kZXJUaXRsZSIsIl9yZW5kZXJCYXNlIiwiX3JlbmRlck1ldGFUYWdzIiwiX3JlbmRlckxpbmtUYWdzIiwiZW5zdXJlQ3NzIiwidGhlbiIsImdldEJvZHlDbGFzc2VzIiwiY2xhc3NlcyIsInB1c2giLCJib2R5IiwiY2xhc3NOYW1lIiwiam9pbiIsIl9yZW5kZXIiLCJjYXRjaCIsImRvbmUiLCJzZXRSZXF1ZXN0IiwiZ2V0UmVxdWVzdCIsInBhcmFtcyIsImdldEFsbERlYnVnVmFsdWVzIiwiX3JlYWN0X3NlcnZlcl9sb2dfbGV2ZWwiLCJfcmVhY3Rfc2VydmVyX2xvZ19sZXZlbF9tYWluIiwiX3JlYWN0X3NlcnZlcl9sb2dfbGV2ZWxfdGltZSIsIl9yZWFjdF9zZXJ2ZXJfbG9nX2xldmVsX2dhdWdlIiwicGFyYW0iLCJzZXRMZXZlbCIsImdldFRpdGxlIiwibmV3VGl0bGUiLCJ0aXRsZSIsImVtaXQiLCJnZXRCYXNlIiwiY3VycmVudEJhc2VUYWciLCJoZWFkIiwicXVlcnlTZWxlY3RvciIsImJhc2UiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJocmVmIiwidGFyZ2V0IiwiY3VycmVudE1ldGFUYWdzIiwicXVlcnlTZWxlY3RvckFsbCIsImkiLCJsZW5ndGgiLCJnZXRNZXRhVGFncyIsIm1ldGFUYWdQcm9taXNlIiwibWV0YVRhZyIsInBhcmVudCIsIm5vc2NyaXB0IiwibWV0YSIsInNsaWNlIiwidGFnIiwiZ2V0TGlua1RhZ3MiLCJwcm9taXNlIiwibWFrZUFycmF5IiwidGFncyIsImNvbmNhdCIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJsaW5rIiwiYXR0ciIsInNldEF0dHJpYnV0ZSIsInRTdGFydCIsInJldHZhbCIsInRvdGFsUmVuZGVyVGltZSIsImVsZW1lbnRQcm9taXNlcyIsInN0YW5kYXJkaXplRWxlbWVudHMiLCJnZXRFbGVtZW50cyIsInRpbWVvdXREZmQiLCJlbGVtZW50UHJvbWlzZXNPciIsIm1hcCIsImluZGV4Iiwib3JQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJvb3ROb2RlUHJvbWlzZXMiLCJfZW5zdXJlUm9vdE5vZGVEZmQiLCJkZmQiLCJvbGRSb290RWxlbWVudCIsIm9sZFJvb3RDb250YWluZXIiLCJyZW5kZXJFbGVtZW50IiwiZWxlbWVudCIsInJvb3QiLCJjb250YWluZXJPcGVuIiwiX3VwZGF0ZUNvbnRhaW5lck5vZGVBdHRyaWJ1dGVzIiwiY29udGFpbmVyQ2xvc2UiLCJfY3JlYXRlQ29udGFpbmVyTm9kZSIsImlzVGhlRm9sZCIsIl9jcmVhdGVSZWFjdFNlcnZlclJvb3ROb2RlIiwiZ2V0RWxlbWVudERpc3BsYXlOYW1lIiwidGltZXIiLCJjbG9uZUVsZW1lbnQiLCJyZW5kZXJGdW5jIiwiaHlkcmF0ZSIsInJlbmRlciIsInYiLCJrIiwic3RvcCIsInREaXNwbGF5IiwiZ2V0QXR0cmlidXRlIiwicmVuZGVyT25lIiwiY29tcG9uZW50VHlwZSIsInByb3BzIiwiY2hpbGRyZW4iLCJlIiwiY2hhaW4iLCJhbGwiLCJpc1BlbmRpbmciLCJoYXZlQ2xlYW5lZFByZXZpb3VzUmVuZGVyIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsImF0dHJzIiwibm9kZSIsInVubG9hZEhhbmRsZXIiLCJ0ZXJtaW5hdGUiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJfaW5pdGlhbGl6ZUhpc3RvcnlMaXN0ZW5lciIsIl9uYXZpZ2F0ZVdpdGhIaXN0b3J5U3RhdGUiLCJwYXRoIiwiY2hlY2siLCJnZXRQYXRoIiwiUE9QU1RBVEUiLCJpbml0Iiwib24iLCJyZWFkeVN0YXRlIiwiX19yZWFjdFNlcnZlckNsaWVudENvbnRyb2xsZXIiLCJkZWh5ZHJhdGVkRW50cnkiLCJsYXRlQXJyaXZhbCIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsIm1zZyIsIkVycm9yIiwiZGVoeWRyYXRlZENvbmZpZyIsIkJ1aWxkZXIiLCJzZXRSb3V0ZXMiLCJjcmVhdGUiLCJtYXJrIiwiYnVja2V0Iiwic3RhcnQiLCJlbmQiLCJ0aW1lIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNJLFlBQVFBLFFBQVEsT0FBUixDQUFSO0FBQUEsSUFDSEMsUUFERyxHQUNRRCxRQUFRLFdB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LFNBQVM1TSxXQUFULENBQXFCOE0sZ0JBQXJCLEVBQXVDO0FBQ3RDO0FBQ0EsS0FBSS9NLFNBQVNqRCxRQUFRLFVBQVIsR0FBYjtBQUNBaUQsUUFBT1csU0FBUCxDQUFpQm9NLGdCQUFqQjtBQUNBLFFBQU8vTSxNQUFQO0FBQ0E7O0FBRUQsU0FBU00sWUFBVCxDQUFzQmhCLE1BQXRCLEVBQThCO0FBQzdCLEtBQUllLFVBQVUsSUFBSW5ELGVBQWU4UCxPQUFuQixHQUNaQyxTQURZLENBQ0YzTixNQURFLEVBRVo0TixNQUZZLEVBQWQ7O0FBSUEsUUFBTzdNLE9BQVA7QUFDQTs7QUFFRDtBQUNBLFNBQVNpQixlQUFULENBQXlCa0QsSUFBekIsRUFBK0I7QUFDOUIsS0FBSWxHLE9BQU9rQixXQUFQLElBQXNCQSxZQUFZMk4sSUFBdEMsRUFBNEM7QUFDM0MzTixjQUFZMk4sSUFBWixtQkFBaUMzSSxJQUFqQztBQUNBO0FBQ0Q7O0FBRUQsU0FBU25ELGFBQVQsQ0FBdUIrTCxNQUF2QixFQUErQkMsS0FBL0IsRUFBc0Q7QUFBQSxLQUFoQkMsR0FBZ0IsdUVBQVYsSUFBSXZMLElBQUosRUFBVTs7QUFDckQsS0FBSXNMLFVBQVUxTixTQUFkLEVBQXlCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFRHZCLFFBQU9tUCxJQUFQLENBQVlILE1BQVosRUFBb0JFLE1BQU1ELEtBQTFCO0FBQ0E7O0FBRURHLE9BQU9DLE9BQVAsR0FBaUJwTyxnQkFBakIiLCJmaWxlIjoiQ2xpZW50Q29udHJvbGxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKSxcblx0UmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKSxcblx0bG9nZ2luZyA9IHJlcXVpcmUoJy4vbG9nZ2luZycpLFxuXHRSZXF1ZXN0Q29udGV4dCA9IHJlcXVpcmUoJy4vY29udGV4dC9SZXF1ZXN0Q29udGV4dCcpLFxuXHRSZXF1ZXN0TG9jYWxTdG9yYWdlID0gcmVxdWlyZSgnLi91dGlsL1JlcXVlc3RMb2NhbFN0b3JhZ2UnKSxcblx0RGVidWdVdGlsID0gcmVxdWlyZSgnLi91dGlsL0RlYnVnVXRpbCcpLFxuXHRRID0gcmVxdWlyZSgncScpLFxuXHRjc3NIZWxwZXIgPSByZXF1aXJlKCcuL3V0aWwvQ2xpZW50Q3NzSGVscGVyJyksXG5cdEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudHNcIikuRXZlbnRFbWl0dGVyLFxuXHRDbGllbnRSZXF1ZXN0ID0gcmVxdWlyZShcIi4vQ2xpZW50UmVxdWVzdFwiKSxcblx0SGlzdG9yeSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9IaXN0b3J5JyksXG5cdFBhZ2VVdGlsID0gcmVxdWlyZShcIi4vdXRpbC9QYWdlVXRpbFwiKSxcblx0UmVhY3RTZXJ2ZXJBZ2VudCA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJBZ2VudCcpLFxuXHR7Z2V0Um9vdEVsZW1lbnRBdHRyaWJ1dGVzfSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9Sb290RWxlbWVudCcpLFxuXHR7UEFHRV9MSU5LX05PREVfSUQsIFBBR0VfQ09OVEFJTkVSX05PREVfSUR9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxudmFyIF8gPSB7XG5cdGZvckVhY2g6IHJlcXVpcmUoJ2xvZGFzaC9mb3JFYWNoJyksXG5cdGFzc2lnbjogcmVxdWlyZSgnbG9kYXNoL2Fzc2lnbicpLFxufTtcblxudmFyIFJMUyA9IFJlcXVlc3RMb2NhbFN0b3JhZ2UuZ2V0TmFtZXNwYWNlKCk7XG5cbnZhciBsb2dnZXIgPSBsb2dnaW5nLmdldExvZ2dlcih7XCJuYW1lXCI6XCJyZWFjdC1zZXJ2ZXIuY29yZS5DbGllbnRDb250cm9sbGVyXCIsXCJjb2xvclwiOntcInNlcnZlclwiOjYzLFwiY2xpZW50XCI6XCJyZ2IoNDIsNDIsMjEyKVwifX0pO1xuXG4vLyBmb3IgZGV2IHRvb2xzXG53aW5kb3cuUmVhY3QgPSBSZWFjdDtcblxudmFyIFJFQUNUX1NFUlZFUl9EQVRBX0FUVFJJQlVURSA9IFwiZGF0YS1yZWFjdC1zZXJ2ZXItcm9vdC1pZFwiO1xuXG4vKipcbiAqIFNldCB1cCBhIFEgZXJyb3IgaGFuZGxlciB0byBtYWtlIHN1cmUgdGhhdCBlcnJvcnMgdGhhdCBidWJibGVcbiAqIHVwIGFyZSBsb2dnZWQgdmlhIG91ciBsb2dnZXIuIE5vdGU6IFRoaXMgd2lsbCBhZmZlY3QgYWxsIHVuaGFuZGxlZFxuICogUSBwcm9taXNlIHJlamVjdGlvbnMsIG5vdCBqdXN0IHRoZSBvbmVzIGluIHRoaXMgZmlsZS5cbiAqL1xuUS5vbmVycm9yID0gKGVycikgPT4ge1xuXHRsb2dnZXIuZXJyb3IoXCJVbmhhbmRsZWQgZXhjZXB0aW9uIGluIFEgcHJvbWlzZVwiLCBlcnIpO1xufVxuXG5mdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGVGcmFtZShyZXF1ZXN0KSB7XG5cblx0Ly8gTWFyayB0aGUgZnJhbWUgYXMgb3Vycy5cblx0Ly8gU3Rhc2ggdGhlIHJlcXVlc3Qgb3B0cyB0aGF0IHdlcmUgdXNlZCB0byBuYXZpZ2F0ZSB0byB0aGlzIGZyYW1lLlxuXHRyZXR1cm4geyByZWFjdFNlcnZlckZyYW1lOiByZXF1ZXN0P3JlcXVlc3QuZ2V0T3B0cygpOnt9IH1cbn1cblxuZnVuY3Rpb24gZ2V0SGlzdG9yeVBhdGhuYW1lKCkge1xuXHRyZXR1cm4gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoO1xufVxuXG5jbGFzcyBDbGllbnRDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuXHRjb25zdHJ1Y3RvciAoe3JvdXRlc30pIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0d2luZG93Ll9fcmVhY3RTZXJ2ZXJUaW1pbmdTdGFydCA9IHdpbmRvdy5wZXJmb3JtYW5jZSA/IHdpbmRvdy5wZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0IDogdW5kZWZpbmVkO1xuXG5cdFx0dmFyIGRlaHlkcmF0ZWRTdGF0ZSA9IHdpbmRvdy5fX3JlYWN0U2VydmVyU3RhdGU7XG5cblx0XHRjaGVja05vdEVtcHR5KGRlaHlkcmF0ZWRTdGF0ZSwgJ0luaXRpYWxDb250ZXh0Jyk7XG5cdFx0Y2hlY2tOb3RFbXB0eShkZWh5ZHJhdGVkU3RhdGUsICdDb25maWcnKTtcblxuXHRcdFJlcXVlc3RMb2NhbFN0b3JhZ2Uuc3RhcnRSZXF1ZXN0KCk7XG5cblx0XHR0aGlzLmNvbmZpZyA9IGJ1aWxkQ29uZmlnKGRlaHlkcmF0ZWRTdGF0ZS5Db25maWcpO1xuXG5cdFx0aWYgKHJvdXRlcy5vbkNsaWVudENvbmZpZ0xvYWRlZCkge1xuXHRcdFx0cm91dGVzLm9uQ2xpZW50Q29uZmlnTG9hZGVkLmNhbGwodGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jb250ZXh0ID0gYnVpbGRDb250ZXh0KHJvdXRlcyk7XG5cdFx0dGhpcy5jb250ZXh0LnNldERldmljZVR5cGUoZGVoeWRyYXRlZFN0YXRlLkluaXRpYWxDb250ZXh0LmRldmljZVR5cGUpO1xuXHRcdFJlYWN0U2VydmVyQWdlbnQuY2FjaGUoKS5yZWh5ZHJhdGUoZGVoeWRyYXRlZFN0YXRlLkluaXRpYWxDb250ZXh0WydSZWFjdFNlcnZlckFnZW50LmNhY2hlJ10pO1xuXHRcdHRoaXMubW91bnROb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRlbnQnKTtcblxuXHRcdHRoaXMuX3NldHVwTmF2aWdhdGVMaXN0ZW5lcigpO1xuXHRcdHRoaXMuX3NldHVwQXJyaXZhbEhhbmRsZXJzKCk7XG5cblx0XHR0aGlzLl9wcmV2aW91c2x5UmVuZGVyZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9yb290Tm9kZURmZHMgPSBbXTtcblx0XHR0aGlzLl9mYWlsRGZkID0gUS5kZWZlcigpO1xuXG5cdFx0Ly8gTG9nIHRoaXMgYWZ0ZXIgbG9nbGV2ZWwgaXMgc2V0LlxuXHRcdGxvZ1RpbWluZ0RhdGEoJ3dha2VGcm9tU3RhcnQnLCB3aW5kb3cuX19yZWFjdFNlcnZlclRpbWluZ1N0YXJ0KTtcblxuXHRcdHBlcmZvcm1hbmNlTWFyaygnd2FrZScpO1xuXG5cdFx0Ly8gdGhpcyBpcyBhIHByb3h5IGZvciB3aGVuIGFib3ZlIHRoZSBmb2xkIGNvbnRlbnQgZ2V0cyBwYWludGVkIChkaXNwbGF5ZWQpIG9uIHRoZSBicm93c2VyXG5cdFx0bG9nVGltaW5nRGF0YSgnZGlzcGxheUFib3ZlVGhlRm9sZC5mcm9tU3RhcnQnLCB3aW5kb3cuX19yZWFjdFNlcnZlclRpbWluZ1N0YXJ0LCB3aW5kb3cuX19kaXNwbGF5QWJvdmVUaGVGb2xkKTtcblx0fVxuXG5cdHRlcm1pbmF0ZSgpIHtcblx0XHQvLyBXZSBtYXkgbm90IGhhdmUgc2V0IHVwIGFueSBoaXN0b3J5IHN0dWZmLi4uXG5cdFx0aWYgKCF0aGlzLl9oaXN0b3J5KSByZXR1cm47XG5cdFx0dGhpcy5faGlzdG9yeS5vZmYodGhpcy5faGlzdG9yeUxpc3RlbmVyKTtcblx0XHR0aGlzLl9oaXN0b3J5TGlzdGVuZXIgPSBudWxsO1xuXHRcdHRoaXMuX2hpc3RvcnkgPSBudWxsO1xuXHR9XG5cblx0X3N0YXJ0UmVxdWVzdCh7cmVxdWVzdCwgdHlwZX0pIHtcblxuXHRcdGNvbnN0IHQwID0gdHlwZSA9PT0gSGlzdG9yeS5ldmVudHMuUEFHRUxPQURcblx0XHRcdD93aW5kb3cuX19yZWFjdFNlcnZlclRpbWluZ1N0YXJ0IC8vIFRyeSB0byB1c2UgbmF2aWdhdGlvbiB0aW1pbmcuXG5cdFx0XHQ6bmV3IERhdGU7ICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSdzIG5vIG5hdmlhZ2F0aW9uLiAgV2UncmUgaXQuXG5cblx0XHRjb25zdCB1cmwgPSByZXF1ZXN0LmdldFVybCgpO1xuXHRcdGNvbnN0IGlzUHVzaCA9IHR5cGUgPT09IEhpc3RvcnkuZXZlbnRzLlBVU0hTVEFURTtcblxuXHRcdC8vIFRoaXMgaXMgdGhlIG5hdmlnYXRvciB3ZSdyZSBnb2luZyB0byBsaXN0ZW4gdG8gcmVnYXJkaW5nIHdoZW4gbmF2aWdhdGlvblxuXHRcdC8vIGlzIGNvbXBsZXRlIGZvciB0aW1pbmcgcHVycG9zZXMuXG5cdFx0bGV0IG5hdmlnYXRpb25UaW1pbmdBdXRob3JpdHkgPSB0aGlzLmNvbnRleHQubmF2aWdhdG9yO1xuXG5cdFx0dGhpcy5fcmV1c2VEb20gPSByZXF1ZXN0LmdldFJldXNlRG9tKCk7XG5cblx0XHRpZiAodGhpcy5fcHJldmlvdXNseVJlbmRlcmVkKSB7XG5cblx0XHRcdC8vIFRoaXMgaXMgYSBzZWNvbmRhcnkgcmVxdWVzdCAoY2xpZW50IHRyYW5zaXRpb24pXG5cdFx0XHQvLyB3aXRoaW4gYSBzZXNzaW9uLCBzbyB3ZSdsbCBnZXQgYSBmcmVzaFxuXHRcdFx0Ly8gUmVxdWVzdExvY2FsU3RvcmFnZSBjb250YWluZXIuXG5cdFx0XHRSZXF1ZXN0TG9jYWxTdG9yYWdlLnN0YXJ0UmVxdWVzdCgpO1xuXG5cdFx0XHQvLyBJZiB3ZSdyZSBub3QgZ29pbmcgdG8gcmV1c2UgdGhlIERPTSwgbGV0J3Ncblx0XHRcdC8vIGNsZWFuIHVwIHJpZ2h0IGF3YXkgdG8gYmxhbmsgdGhlIHNjcmVlbi5cblx0XHRcdGlmICghdGhpcy5fcmV1c2VEb20pIHtcblx0XHRcdFx0dGhpcy5fY2xlYW51cFByZXZpb3VzUmVuZGVyKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHdlIG5lZWQgdG8gcmUtcmVnaXN0ZXIgdGhlIHJlcXVlc3QgY29udGV4dFxuXHRcdFx0Ly8gYXMgYSBSZXF1ZXN0TG9jYWwuXG5cdFx0XHR0aGlzLmNvbnRleHQucmVnaXN0ZXJSZXF1ZXN0TG9jYWwoKTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGlzIGlzIGEgSGlzdG9yeS5ldmVudHMuUFVTSFNUQVRFIG5hdmlnYXRpb24sXG5cdFx0Ly8gYW5kIHdlIGhhdmUgY29udHJvbCBvZiB0aGUgbmF2aWdhdGlvbiBiYXIgd2Ugc2hvdWxkXG5cdFx0Ly8gY2hhbmdlIHRoZSBVUkwgaW4gdGhlIGxvY2F0aW9uIGJhciBiZWZvcmUgcmVuZGVyaW5nLlxuXHRcdC8vXG5cdFx0Ly8gTm90ZSB0aGF0IGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBoYXZlIHB1c2hTdGF0ZSxcblx0XHQvLyB0aGlzIHdpbGwgcmVzdWx0IGluIGEgd2luZG93LmxvY2F0aW9uIGNoYW5nZSBhbmRcblx0XHQvLyBmdWxsIGJyb3dzZXIgbG9hZC5cblx0XHQvL1xuXHRcdGlmICh0aGlzLl9oaXN0b3J5KSB7XG5cblx0XHRcdGlmIChpc1B1c2gpIHtcblxuXHRcdFx0XHQvLyBTb3JyeSBmb2xrcy4gIElmIHdlIG5lZWQgdG8gZG8gYSBjbGllbnRcblx0XHRcdFx0Ly8gdHJhbnNpdGlvbiwgdGhlbiB3ZSdyZSBnb2luZyB0byBjbG9iYmVyXG5cdFx0XHRcdC8vIHlvdXIgc3RhdGUuICBZb3UgbXVzdCBiZSBhYmxlIHRvIHJlbmRlclxuXHRcdFx0XHQvLyBmcm9tIFVSTCwgYW55d2F5LCBzbyBpZiB5b3UncmUgc2V0IHVwIHJpZ2h0XG5cdFx0XHRcdC8vIGl0IHdvbid0IGFmZmVjdCB1c2VyIGV4cGVyaWVuY2UuICBJdCBtZWFucyxcblx0XHRcdFx0Ly8gdGhvdWdoLCB0aGF0IHRoZXJlIGV4aXN0cyBhIG5hdmlnYXRpb24gcGF0aFxuXHRcdFx0XHQvLyB0byBhbiBleHRyYW5lb3VzIGZ1bGwtcGFnZSByZWJ1aWxkLlxuXHRcdFx0XHQvLyBTdWNoIGlzIGxpZmUuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQvLyBEb24ndCByZXBsYWNlIHN0YXRlIHVubGVzcyB3ZSd2ZVxuXHRcdFx0XHRcdC8vIGdvdCBhIHJlYWwgaGlzdG9yeSBBUEkuXG5cdFx0XHRcdFx0dGhpcy5faGlzdG9yeS5jYW5DbGllbnROYXZpZ2F0ZSgpICYmXG5cdFx0XHRcdFx0IShoaXN0b3J5LnN0YXRlfHx7fSkucmVhY3RTZXJ2ZXJGcmFtZVxuXHRcdFx0XHQpe1xuXHRcdFx0XHRcdHRoaXMuX2hpc3RvcnkucmVwbGFjZVN0YXRlKFxuXHRcdFx0XHRcdFx0Z2V0SGlzdG9yeVN0YXRlRnJhbWUoKSxcblx0XHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0XHRnZXRIaXN0b3J5UGF0aG5hbWUoKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9zZXRIaXN0b3J5UmVxdWVzdE9wdHMoe1xuXHRcdFx0XHRcdC8vIElmIHdlJ3JlIHJldXNpbmcgdGhlIERPTSBvbiB0aGUgd2F5XG5cdFx0XHRcdFx0Ly8gZm9yd2FyZCwgdGhlbiB3ZSBjYW4gYWxzbyByZXVzZSBvblxuXHRcdFx0XHRcdC8vIHRoZSB3YXkgYmFjay5cblx0XHRcdFx0XHRyZXVzZURvbTogcmVxdWVzdC5nZXRSZXVzZURvbSgpLFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0aGlzLl9oaXN0b3J5LnB1c2hTdGF0ZShcblx0XHRcdFx0XHRnZXRIaXN0b3J5U3RhdGVGcmFtZShyZXF1ZXN0KSxcblx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdHVybFxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSBIaXN0b3J5LmV2ZW50cy5QQUdFTE9BRCkge1xuXG5cdFx0XHRcdC8vIFRoaXMgX3NlZW1zXyByZWR1bmRhbnQgd2l0aCB0aGVcblx0XHRcdFx0Ly8gYHJlcGxhY2VTdGF0ZWAgYWJvdmUsIGJ1dCBrZWVwIGluIG1pbmQgdGhhdFxuXHRcdFx0XHQvLyBhbiBpbml0aWFsIGBwdXNoU3RhdGVgIG1pZ2h0IG5vdCBiZSBhXG5cdFx0XHRcdC8vIGNsaWVudCB0cmFuc2l0aW9uLiAgSXQgY291bGQgYmUgYVxuXHRcdFx0XHQvLyBub24tYHJlYWN0LXNlcnZlcmAgdXNlIG9mIHRoZSBoaXN0b3J5IEFQSS5cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gVGhpcyBhbHNvIF9yZXBsYWNlc18gc3RhdGUgd2l0aCB0aGUgcmVxdWVzdFxuXHRcdFx0XHQvLyBVUkwsIHdoaWNoIGhhbmRsZXMgY2xpZW50LXNpZGUgcmVkaXJlY3RzLlxuXHRcdFx0XHR0aGlzLl9oaXN0b3J5LnJlcGxhY2VTdGF0ZShcblx0XHRcdFx0XHRnZXRIaXN0b3J5U3RhdGVGcmFtZShyZXF1ZXN0KSxcblx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdHVybFxuXHRcdFx0XHQpXG5cblx0XHRcdFx0dGhpcy5fc2V0SGlzdG9yeVJlcXVlc3RPcHRzKHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIHdpbmQgdXAgYmFjayBoZXJlIHdpdGhvdXRcblx0XHRcdFx0XHQvLyBmaXJzdCBjbGllbnQtdHJhbnNpdGlvbmluZyBhd2F5XG5cdFx0XHRcdFx0Ly8gdGhlbiBwcmVzdW1hYmx5IHdlJ3JlIHN0aWxsIG9uIHRoZVxuXHRcdFx0XHRcdC8vIHNhbWUgcGFnZSB0aGF0IGp1c3QgaGFkIHNvbWVcblx0XHRcdFx0XHQvLyBoaXN0b3J5IG1hbmlwdHVsYXRpb24gb3V0c2lkZSBvZlxuXHRcdFx0XHRcdC8vIGByZWFjdC1zZXJ2ZXJgLiAgSW4gdGhhdCBjYXNlIHdlJ3JlXG5cdFx0XHRcdFx0Ly8gb3Vyc2VsdmVzIGFuZCB3ZSBzaG91bGQgYmUgYWJsZSB0b1xuXHRcdFx0XHRcdC8vIHJlLXVzZSB0aGUgRE9NLiAgTWF5YmVcblx0XHRcdFx0XHQvLyBwcmVzdW1wdHVvdXMsIGJ1dCBhIG5pY2VyXG5cdFx0XHRcdFx0Ly8gZXhwZXJpZW5jZSB0aGFuIGNsb2JiZXJpbmcuXG5cdFx0XHRcdFx0cmV1c2VEb206IHRydWUsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGxvZ2dpbmcgaG93IGxvbmcgdGhlIHJlcXVlc3QgdG9vayBpbiBhIHZhcmlldHkgb2Ygd2F5czpcblx0XHQvLyAtIFJlcXVlc3QgdHlwZSAocGFnZWxvYWQsIHB1c2hzdGF0ZSwgcG9wc3RhdGUpXG5cdFx0Ly8gLSBSZXF1ZXN0IG9wdGlvbnMgKHJldXNlRG9tLCBidW5kbGVEYXRhLCBldGMpXG5cdFx0bmF2aWdhdGlvblRpbWluZ0F1dGhvcml0eS5vbmNlKCdsb2FkQ29tcGxldGUnLCAoKSA9PiB7XG5cdFx0XHRjb25zdCBiYXMgPSBgaGFuZGxlUmVxdWVzdGA7XG5cdFx0XHRjb25zdCB0eXAgPSBgdHlwZS4ke3R5cGV8fCdQQUdFTE9BRCd9YDtcblx0XHRcdGxvZ1RpbWluZ0RhdGEoYCR7YmFzfS5hbGxgLCB0MCk7XG5cdFx0XHRsb2dUaW1pbmdEYXRhKGAke2Jhc30uJHt0eXB9LmFsbGAsIHQwKTtcblx0XHRcdF8uZm9yRWFjaChyZXF1ZXN0LmdldE9wdHMoKSwgKHZhbCwga2V5KSA9PiB7XG5cdFx0XHRcdGlmICh2YWwpIHtcblx0XHRcdFx0XHRjb25zdCBvcHQgPSBgb3B0LiR7a2V5fWA7XG5cdFx0XHRcdFx0bG9nVGltaW5nRGF0YShgJHtiYXN9LiR7b3B0fWAsIHQwKTtcblx0XHRcdFx0XHRsb2dUaW1pbmdEYXRhKGAke2Jhc30uJHt0eXB9LiR7b3B0fWAsIHQwKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9sYXN0U3RhdGUgPSBoaXN0b3J5LnN0YXRlO1xuXHR9XG5cblx0Ly8gVXBkYXRlIHRoZSByZXF1ZXN0IG9wdGlvbnMgZm9yIHRoZSBfY3VycmVudF8gaGlzdG9yeSBuYXZpZ2F0aW9uXG5cdC8vIHN0YXRlIGZyYW1lIHByaW9yIHRvIHB1c2hpbmcgYSBuZXcgZnJhbWUuXG5cdF9zZXRIaXN0b3J5UmVxdWVzdE9wdHMob3B0cykge1xuXG5cdFx0Ly8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHJlYWwgaGlzdG9yeSBBUEkgdGhlbiB3ZSBkb24ndCB3YW50IHRvXG5cdFx0Ly8gbWVzcyB3aXRoIHN0YXRlIHNpbmNlIGl0IHJlc3VsdHMgaW4gZnVsbCBuYXZpZ2F0aW9uLlxuXHRcdGlmICghdGhpcy5faGlzdG9yeS5jYW5DbGllbnROYXZpZ2F0ZSgpKSByZXR1cm47XG5cblx0XHRjb25zdCBzdGF0ZSA9IF8uYXNzaWduKHt9LCBoaXN0b3J5LnN0YXRlKTtcblx0XHRzdGF0ZS5yZWFjdFNlcnZlckZyYW1lID0gXy5hc3NpZ24oc3RhdGUucmVhY3RTZXJ2ZXJGcmFtZXx8e30sIG9wdHMpO1xuXHRcdHRoaXMuX2hpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCBudWxsLCBnZXRIaXN0b3J5UGF0aG5hbWUoKSk7XG5cdH1cblxuXHRfc2V0dXBOYXZpZ2F0ZUxpc3RlbmVyICgpIHtcblx0XHR2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHRcdGNvbnRleHQub25OYXZpZ2F0ZVN0YXJ0KHRoaXMuX3N0YXJ0UmVxdWVzdC5iaW5kKHRoaXMpKTtcblxuXHRcdC8qKlxuXHRcdCAqIHR5cGUgaXMgb25lIG9mXG5cdFx0ICogICAgSGlzdG9yeS5ldmVudHMuUFVTSFNUQVRFOiB1c2VyIGNsaWNrZWQgc29tZXRoaW5nIHRvIGdvIGZvcndhcmQgYnV0IGJyb3dzZXIgZGlkbid0IGRvIGFcblx0XHQgKiBmdWxsIHBhZ2UgbG9hZFxuXHRcdCAqICAgIEhpc3RvcnkuZXZlbnRzLlBPUFNUQVRFOiB1c2VyIGNsaWNrZWQgYmFjayBidXR0b24gYnV0IGJyb3dzZXIgZGlkbid0IGRvIGEgZnVsbCBwYWdlIGxvYWRcblx0XHQgKiAgICBIaXN0b3J5LmV2ZW50cy5QQUdFTE9BRDogZnVsbCBicm93c2VyIHBhZ2UgbG9hZCwgbm90IHVzaW5nIEhpc3RvcnkgQVBJLlxuXHRcdCAqL1xuXHRcdGNvbnRleHQub25OYXZpZ2F0ZSggKGVyciwgcGFnZSkgPT4ge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdFeGVjdXRpbmcgbmF2aWdhdGUgYWN0aW9uJyk7XG5cblx0XHRcdHRoaXMuX2hhbmRsZURlYnVnUGFyYW1zKHBhZ2UpO1xuXG5cdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdC8vIHJlZGlyZWN0cyBhcmUgc2VudCBhcyBlcnJvcnMsIHNvIGxldCdzIGhhbmRsZSBpdCBpZiB0aGF0J3MgdGhlIGNhc2UuXG5cdFx0XHRcdGlmIChlcnIuc3RhdHVzICYmIChlcnIuc3RhdHVzID09PSAzMDEgfHwgZXJyLnN0YXR1cyA9PT0gMzAyKSkge1xuXHRcdFx0XHRcdGlmICghZXJyLnJlZGlyZWN0VXJsKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiQSByZWRpcmVjdCBzdGF0dXMgd2FzIHNlbnQgd2l0aG91dCBhIGNvcnJlc3BvbmRpbmcgcmVkaXJlY3QgcmVkaXJlY3RVcmwuXCIsIGVycik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHQvLyB3ZSdyZSBhYm91dCB0byBsb2FkIHRoZSBfbmV4dF8gcGFnZSwgc28gd2Ugc2hvdWxkIG1hcmsgdGhlXG5cdFx0XHRcdFx0XHRcdC8vIHJlZGlyZWN0IG5hdmlnYXRpb24gZmluaXNoZWRcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5uYXZpZ2F0b3IuZmluaXNoUm91dGUoKTtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5uYXZpZ2F0ZShuZXcgQ2xpZW50UmVxdWVzdChlcnIucmVkaXJlY3RVcmwpKTtcblx0XHRcdFx0XHRcdH0sIDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoXCJvbk5hdmlnYXRlIGVycm9yXCIsIGVycik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcm91dGVOYW1lID0gY29udGV4dC5uYXZpZ2F0b3IuZ2V0Q3VycmVudFJvdXRlKCkubmFtZTtcblxuXHRcdFx0aWYgKCF0aGlzLl9wcmV2aW91c2x5UmVuZGVyZWQpIHtcblx0XHRcdFx0Y3NzSGVscGVyLnJlZ2lzdGVyUGFnZUxvYWQocm91dGVOYW1lKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHJlbmRlciB0aGUgZG9jdW1lbnQgdGl0bGUuXG5cdFx0XHRcdHRoaXMuX3JlbmRlclRpdGxlKHBhZ2UpO1xuXG5cdFx0XHRcdC8vIHJlbmRlciB0aGUgYmFzZSB0YWcuXG5cdFx0XHRcdHRoaXMuX3JlbmRlckJhc2UocGFnZSk7XG5cblx0XHRcdFx0dGhpcy5fcmVuZGVyTWV0YVRhZ3MocGFnZSk7XG5cblx0XHRcdFx0dGhpcy5fcmVuZGVyTGlua1RhZ3MocGFnZSk7XG5cdFx0XHR9XG5cblx0XHRcdGNzc0hlbHBlci5lbnN1cmVDc3Mocm91dGVOYW1lLCBwYWdlKVxuXHRcdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0XHRcdHBhZ2UuZ2V0Qm9keUNsYXNzZXMoKS50aGVuKChjbGFzc2VzKSA9PiB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goYHJvdXRlLSR7cm91dGVOYW1lfWApO1xuXHRcdFx0XHRcdFx0ZG9jdW1lbnQuYm9keS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcblx0XHRcdFx0XHR9KSlcblx0XHRcdFx0LnRoZW4oKCkgPT4gdGhpcy5fcmVuZGVyKHBhZ2UpKS5jYXRjaCgoZXJyKSA9PiB7XG5cdFx0XHRcdFx0bG9nZ2VyLmVycm9yKFwiRXJyb3IgZHVyaW5nIGNsaWVudCB0cmFuc2l0aW9uIHJlbmRlclwiLCBlcnIpO1xuXHRcdFx0XHR9KS50aGVuKCgpID0+IHtcblxuXHRcdFx0XHRcdC8vIFdlJ3JlIHJlc3BvbnNpYmxlIGZvciBsZXR0aW5nIHRoZSBuYXZpZ2F0b3Jcblx0XHRcdFx0XHQvLyBrbm93IHdoZW4gd2UncmUgbW9yZSBvciBsZXNzIGRvbmUgc3RvbXBpbmdcblx0XHRcdFx0XHQvLyBhcm91bmQgaW4gdGhlIGN1cnJlbnQgcmVxdWVzdCBjb250ZXh0XG5cdFx0XHRcdFx0Ly8gc2V0dGluZyB0aGluZ3MgdXAuXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyBXZSBjYW4ndCBfZ3VhcmFudGVlXyB0aGF0IHBhZ2VzL21pZGRsZXdhcmVcblx0XHRcdFx0XHQvLyBoYXZlbid0IHNldCB0aW1lcnMgdG8gbWVzcyB3aXRoIHRoaW5ncyBpblxuXHRcdFx0XHRcdC8vIHRoZSBmdXR1cmUsIHNvIHdlIG5lZWQgdG8gd2FpdCBhIGJpdCBiZWZvcmVcblx0XHRcdFx0XHQvLyBsZXR0aW5nIHRoZSBuYXZpZ2F0b3IgeWFuayBvdXIgY29udGV4dCBpZlxuXHRcdFx0XHRcdC8vIGFuIGltbWVkaWF0ZSBzdWJzZXF1ZW50IG5hdmlnYXRpb24gaXNcblx0XHRcdFx0XHQvLyBzY2hlZHVsZWQuXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyBJIGRvbid0IGxpa2UgdGhpcyBtYWdpYyBkZWxheSBoZXJlLCBidXQgaXRcblx0XHRcdFx0XHQvLyBnaXZlcyB1cyBhIGJldHRlciBzaG90IGF0IGZhbGxpbmcgYWZ0ZXJcblx0XHRcdFx0XHQvLyB0aGluZ3MgbGlrZSBsYXp5IGxvYWQgaW1hZ2VzIGRvIHRoZWlyXG5cdFx0XHRcdFx0Ly8gcG9zdC1yZW5kZXIgd2lyZS11cC5cblx0XHRcdFx0XHQvL1xuXHRcdFx0XHRcdC8vIEFueXRoaW5nIHRoYXQgdGhlIGN1cnJlbnQgcGFnZSBkb2VzIGluIHRoZVxuXHRcdFx0XHRcdC8vIHJlcXVlc3QgY29udGV4dCBfYWZ0ZXJfIHRoaXMgdGltZW91dCBoYXNcblx0XHRcdFx0XHQvLyBlbGFwc2VkIGFuZCB3ZSd2ZSBzdGFydGVkIGEgc3Vic2VxdWVudFxuXHRcdFx0XHRcdC8vIG5hdmlnYXRpb24gaXMgcHVyZSBjb3JydXB0aW9uLiA6cFxuXHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiBjb250ZXh0Lm5hdmlnYXRvci5maW5pc2hSb3V0ZSgpLCAyMDApO1xuXHRcdFx0XHR9KS5kb25lKCk7XG5cblx0XHR9KTtcblxuXHR9XG5cblx0X2hhbmRsZURlYnVnUGFyYW1zKHBhZ2UpIHtcblx0XHRpZiAoIXBhZ2UpIHJldHVybjtcblxuXHRcdERlYnVnVXRpbC5zZXRSZXF1ZXN0KHBhZ2UuZ2V0UmVxdWVzdCgpKTtcblxuXHRcdGNvbnN0IHBhcmFtcyA9IERlYnVnVXRpbC5nZXRBbGxEZWJ1Z1ZhbHVlcygpO1xuXG5cdFx0Ly8gQWxsb3cgYWRqdXN0bWVudCBvZiBsb2cgbGV2ZWxzLlxuXHRcdF8uZm9yRWFjaCh7XG5cdFx0XHRfcmVhY3Rfc2VydmVyX2xvZ19sZXZlbCAgICAgICA6ICdtYWluJyxcblx0XHRcdF9yZWFjdF9zZXJ2ZXJfbG9nX2xldmVsX21haW4gIDogJ21haW4nLFxuXHRcdFx0X3JlYWN0X3NlcnZlcl9sb2dfbGV2ZWxfdGltZSAgOiAndGltZScsXG5cdFx0XHRfcmVhY3Rfc2VydmVyX2xvZ19sZXZlbF9nYXVnZSA6ICdnYXVnZScsXG5cdFx0fSwgKHR5cGUsIHBhcmFtKSA9PiB7XG5cdFx0XHRpZiAocGFyYW1zW3BhcmFtXSkge1xuXHRcdFx0XHRsb2dnaW5nLnNldExldmVsKHR5cGUsICBwYXJhbXNbcGFyYW1dKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdF9yZW5kZXJUaXRsZShwYWdlKSB7XG5cdFx0cGFnZS5nZXRUaXRsZSgpLnRoZW4obmV3VGl0bGUgPT4ge1xuXHRcdFx0aWYgKG5ld1RpdGxlICYmIG5ld1RpdGxlICE9PSBkb2N1bWVudC50aXRsZSkge1xuXHRcdFx0XHRkb2N1bWVudC50aXRsZSA9IG5ld1RpdGxlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGlzIGlzIHRoZSBlYXJsaWVzdCB3ZSBoYXZlIGV2ZXJ5dGhpbmcgd2UgbmVlZCBmb3Jcblx0XHRcdC8vIGFuIGFuYWx5dGljcyBwYWdldmlldyBldmVudC5cblx0XHRcdHRoaXMuZW1pdChcInBhZ2V2aWV3XCIsIHtcblx0XHRcdFx0cGFnZSAgOiBnZXRIaXN0b3J5UGF0aG5hbWUoKSxcblx0XHRcdFx0dGl0bGUgOiBuZXdUaXRsZSxcblx0XHRcdH0pO1xuXHRcdH0pXG5cdFx0LmNhdGNoKGVyciA9PiB7IGxvZ2dlci5lcnJvcihcIkVycm9yIHdoaWxlIHNldHRpbmcgdGhlIGRvY3VtZW50IHRpdGxlXCIsIGVycikgfSlcblx0XHQuZG9uZSgpO1xuXHR9XG5cblx0X3JlbmRlckJhc2UocGFnZSkge1xuXHRcdHBhZ2UuZ2V0QmFzZSgpLnRoZW4oYmFzZSA9PiB7XG5cdFx0XHR2YXIgY3VycmVudEJhc2VUYWcgPSBkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoXCJoZWFkIGJhc2VcIik7XG5cdFx0XHRpZiAoYmFzZSA9PT0gbnVsbCkge1xuXHRcdFx0XHQvLyBnZXQgcmlkIG9mIHRoZSBjdXJyZW50IGJhc2UgdGFnLlxuXHRcdFx0XHRpZiAoY3VycmVudEJhc2VUYWcpIGN1cnJlbnRCYXNlVGFnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY3VycmVudEJhc2VUYWcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gd2UgbmVlZCBhIGJhc2UgdGFnLiBhZGQgb25lIGlmIGl0J3Mgbm90IHRoZXJlIHlldC5cblx0XHRcdFx0aWYgKCFjdXJyZW50QmFzZVRhZykge1xuXHRcdFx0XHRcdGN1cnJlbnRCYXNlVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJhc2VcIik7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChjdXJyZW50QmFzZVRhZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGJhc2UuaHJlZikgY3VycmVudEJhc2VUYWcuaHJlZiA9IGJhc2UuaHJlZjtcblx0XHRcdFx0aWYgKGJhc2UudGFyZ2V0KSBjdXJyZW50QmFzZVRhZy50YXJnZXQgPSBiYXNlLnRhcmdldDtcblx0XHRcdH1cblxuXHRcdH0pLmNhdGNoKGVyciA9PiB7XG5cdFx0XHRsb2dnZXIuZXJyb3IoXCJFcnJvciByZW5kZXJpbmcgPGJhc2U+XCIsIGVycik7XG5cdFx0fSkuZG9uZSgpO1xuXHR9XG5cblx0X3JlbmRlck1ldGFUYWdzKHBhZ2UpIHtcblx0XHQvLyBmaXJzdCwgcmVtb3ZlIGFsbCB0aGUgY3VycmVudCBtZXRhIHRhZ3MuXG5cdFx0dmFyIGN1cnJlbnRNZXRhVGFncyA9IGRvY3VtZW50LmhlYWQucXVlcnlTZWxlY3RvckFsbChcIm1ldGFcIik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyZW50TWV0YVRhZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGN1cnJlbnRNZXRhVGFnc1tpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGN1cnJlbnRNZXRhVGFnc1tpXSk7XG5cdFx0fVxuXG5cdFx0Ly8gbm93IGFkZCBhbGwgdGhlIG1ldGEgdGFncyBmb3IgdGhlIG5ldyBwYWdlLlxuXHRcdHBhZ2UuZ2V0TWV0YVRhZ3MoKS5mb3JFYWNoKChtZXRhVGFnUHJvbWlzZSkgPT4ge1xuXHRcdFx0bWV0YVRhZ1Byb21pc2UudGhlbigobWV0YVRhZykgPT4ge1xuXHRcdFx0XHR2YXIgcGFyZW50ID0gZG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0aWYgKG1ldGFUYWcubm9zY3JpcHQpIHtcblx0XHRcdFx0XHR2YXIgbm9zY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibm9zY3JpcHRcIik7XG5cdFx0XHRcdFx0cGFyZW50LmFwcGVuZENoaWxkKG5vc2NyaXB0KTtcblx0XHRcdFx0XHRwYXJlbnQgPSBub3NjcmlwdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtZXRhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm1ldGFcIik7XG5cdFx0XHRcdFtcIm5hbWVcIiwgXCJodHRwRXF1aXZcIiwgXCJjaGFyc2V0XCIsIFwiY29udGVudFwiXS5mb3JFYWNoKChuYW1lKSA9PiB7XG5cdFx0XHRcdFx0aWYgKG1ldGFUYWdbbmFtZV0pIG1ldGFbbmFtZV0gPSBtZXRhVGFnW25hbWVdO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQobWV0YSk7XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKCBlcnIgPT4geyBsb2dnZXIuZXJyb3IoXCJFcnJvciByZW5kZXJpbmcgbWV0YSB0YWdzXCIsIGVycik7IH0pXG5cdFx0XHQuZG9uZSgpO1xuXHRcdH0pO1xuXHR9XG5cblx0X3JlbmRlckxpbmtUYWdzKHBhZ2UpIHtcblxuXHRcdC8vIEZpcnN0LCByZW1vdmUgYWxsIHRoZSBjdXJyZW50IGxpbmsgdGFncy5cblx0XHQ7W10uc2xpY2UuY2FsbChkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3JBbGwoYGxpbmtbJHtQQUdFX0xJTktfTk9ERV9JRH1dYCkpXG5cdFx0XHQuZm9yRWFjaCh0YWcgPT4gdGFnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFnKSk7XG5cblx0XHQvLyBUaGVuIGFkZCBhbGwgdGhlIGxpbmsgdGFncyBmb3IgdGhlIG5ldyBwYWdlLlxuXHRcdHBhZ2UuZ2V0TGlua1RhZ3MoKVxuXHRcdC5mb3JFYWNoKHByb21pc2UgPT4gcHJvbWlzZS50aGVuKFBhZ2VVdGlsLm1ha2VBcnJheSkudGhlbih0YWdzID0+IHRhZ3MuZm9yRWFjaCh0YWcgPT4ge1xuXHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChcblx0XHRcdFx0W2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKSwgUEFHRV9MSU5LX05PREVfSURdXG5cdFx0XHRcdC5jb25jYXQoT2JqZWN0LmtleXModGFnKSlcblx0XHRcdFx0LnJlZHVjZSgobGluaywgYXR0cikgPT4gKGxpbmsuc2V0QXR0cmlidXRlKGF0dHIsIHRhZ1thdHRyXSB8fCAnJyksIGxpbmspKVxuXHRcdFx0KTtcblx0XHR9KSkuY2F0Y2goZXJyID0+IGxvZ2dlci5lcnJvcihcIkVycm9yIHJlbmRlcmluZyBsaW5rIHRhZ3NcIiwgZXJyKSkuZG9uZSgpKTtcblx0fVxuXG5cdF9yZW5kZXIgKHBhZ2UpIHtcblx0XHR2YXIgdFN0YXJ0ID0gd2luZG93Ll9fcmVhY3RTZXJ2ZXJUaW1pbmdTdGFydDtcblx0XHR2YXIgdDAgPSBuZXcgRGF0ZTtcblx0XHR2YXIgcmV0dmFsID0gUS5kZWZlcigpO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKCdSZWFjdCBSZW5kZXJpbmcnKTtcblxuXHRcdC8vIFdlIGtlZXAgdHJhY2sgb2YgdGhlIF90b3RhbF8gdGltZSB3ZSBzcGVudCByZW5kZXJpbmcgZHVyaW5nXG5cdFx0Ly8gZWFjaCByZXF1ZXN0IHNvIHdlIGNhbiBrZWVwIHRyYWNrIG9mIHRoYXQgb3ZlcmhlYWQuXG5cdFx0dmFyIHRvdGFsUmVuZGVyVGltZSA9IDA7XG5cblx0XHQvLyBUaGVzZSByZXNvbHZlIHdpdGggUmVhY3QgZWxlbWVudHMgd2hlbiB0aGVpciBkYXRhXG5cdFx0Ly8gZGVwZW5kZW5jaWVzIGFyZSBmdWxmaWxsZWQuXG5cdFx0dmFyIGVsZW1lbnRQcm9taXNlcyA9IFBhZ2VVdGlsLnN0YW5kYXJkaXplRWxlbWVudHMocGFnZS5nZXRFbGVtZW50cygpKTtcblx0XHR2YXIgdGltZW91dERmZCA9IFtdO1xuXHRcdHZhciBlbGVtZW50UHJvbWlzZXNPciA9IGVsZW1lbnRQcm9taXNlcy5tYXAoKHByb21pc2UsIGluZGV4KSA9PiB7XG5cdFx0XHR2YXIgb3JQcm9taXNlID0gUS5kZWZlcigpO1xuXHRcdFx0dGltZW91dERmZFtpbmRleF0gPSBRLmRlZmVyKCk7XG5cblx0XHRcdHByb21pc2UudGhlbihvclByb21pc2UucmVzb2x2ZSk7XG5cdFx0XHRwcm9taXNlLmNhdGNoKG9yUHJvbWlzZS5yZWplY3QpO1xuXHRcdFx0dGltZW91dERmZFtpbmRleF0ucHJvbWlzZS5jYXRjaChvclByb21pc2UucmVqZWN0KTtcblxuXHRcdFx0cmV0dXJuIG9yUHJvbWlzZS5wcm9taXNlO1xuXHRcdH0pO1xuXG5cdFx0Ly8gVGhlc2UgcmVzb2x2ZSB3aXRoIERPTSBtb3VudCBwb2ludHMgZm9yIHRoZSBlbGVtZW50cy5cblx0XHQvL1xuXHRcdC8vIE91ciBiZWhhdmlvciBpcyBkaWZmZXJlbnQgaGVyZSBmb3IgdGhlIF9maXJzdF8gcmVuZGVyIHZzXG5cdFx0Ly8gZHVyaW5nIGEgY2xpZW50IHRyYW5zaXRpb24uXG5cdFx0dmFyIHJvb3ROb2RlUHJvbWlzZXM7XG5cdFx0aWYgKHRoaXMuX3ByZXZpb3VzbHlSZW5kZXJlZCl7XG5cblx0XHRcdC8vIE9uIGEgY2xpZW50IHRyYW5zaXRpb24gd2UndmUganVzdCBibG93biBhd2F5IGFsbCBvZlxuXHRcdFx0Ly8gb3VyIG1vdW50IHBvaW50cyBmcm9tIHRoZSBwcmV2aW91cyBwYWdlLCBhbmQgd2UnbGxcblx0XHRcdC8vIGNyZWF0ZSBhIGZyZXNoIHNldC4gIFdlJ2xsIGRlZmVyIGNyZWF0aW5nIHRoZW1cblx0XHRcdC8vIHVudGlsIHdlJ3ZlIGFjdHVhbGx5IGdvdCBvdXIgZWxlbWVudHMsIHNpbmNlIHNvbWVcblx0XHRcdC8vIGl0ZW1zIGluIHRoZSBlbGVtZW50cyBhcnJheSBtYXkgYmUgY29udGFpbmVyXG5cdFx0XHQvLyBjb250cm9sLlxuXHRcdFx0cm9vdE5vZGVQcm9taXNlcyA9IGVsZW1lbnRQcm9taXNlcy5tYXAoKCkgPT4gUSgpKVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIE9uIG91ciBfZmlyc3RfIHJlbmRlciB3ZSB3YW50IHRvIG1vdW50IHRvIHRoZSBET01cblx0XHRcdC8vIG5vZGVzIHByb2R1Y2VkIGR1cmluZyB0aGUgX3NlcnZlci1zaWRlXyByZW5kZXIuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gV2UncmUgYXdha2UgYW5kIGRvaW5nIG91ciB0aGluZyB3aGlsZSB0aGVzZVxuXHRcdFx0Ly8gc2VydmVyLXJlbmRlcmVkIGVsZW1lbnRzIGFyZSBzdHJlYW1pbmcgZG93biwgc28gd2Vcblx0XHRcdC8vIG5lZWQgdG8gd2FpdCB0byByZW5kZXIgYSBnaXZlbiBlbGVtZW50IHVudGlsIGl0c1xuXHRcdFx0Ly8gbW91bnQgcG9pbnQgYXJyaXZlcy5cblx0XHRcdC8vXG5cdFx0XHQvLyBUaGUgc2VydmVyIHdpbGwgdGVsbCB1cyB3aGVuIGVhY2ggbW91bnQgcG9pbnQgaXNcblx0XHRcdC8vIHJlYWR5IGJ5IGNhbGxpbmcgYG5vZGVBcnJpdmFsYCwgd2hpY2ggdHJpZ2dlcnNcblx0XHRcdC8vIHJlc29sdXRpb24gb2YgdGhlIGNvcnJlc3BvbmRpbmcgYHJvb3ROb2RlUHJvbWlzZWAuXG5cdFx0XHRlbGVtZW50UHJvbWlzZXMuZm9yRWFjaCgocHJvbWlzZSwgaW5kZXgpID0+IHtcblx0XHRcdFx0dGhpcy5fZW5zdXJlUm9vdE5vZGVEZmQoaW5kZXgpO1xuXHRcdFx0fSk7XG5cdFx0XHRyb290Tm9kZVByb21pc2VzID0gdGhpcy5fcm9vdE5vZGVEZmRzLm1hcChkZmQgPT4gZGZkLnByb21pc2UpO1xuXHRcdH1cblxuXHRcdHZhciBtb3VudE5vZGUgPSB0aGlzLm1vdW50Tm9kZTtcblxuXHRcdC8vIFRoZXNlIGFyZSBvbmx5IHVzZWQgaWYgd2UncmUgZ29pbmcgdG8gdHJ5IHRvIHJlLXVzZSB0aGVcblx0XHQvLyBleGlzdGluZyBET00gc3RydWN0dXJlLlxuXHRcdHZhciBvbGRSb290RWxlbWVudCwgb2xkUm9vdENvbnRhaW5lcjtcblxuXHRcdC8vIE9uY2Ugd2UndmUgZ290IGFuIGVsZW1lbnQgYW5kIGEgcm9vdCBET00gbm9kZSB0byBtb3VudCBpdFxuXHRcdC8vIGluIHdlIGNhbiBmaW5hbGx5IHJlbmRlci5cblx0XHR2YXIgcmVuZGVyRWxlbWVudCA9IChlbGVtZW50LCByb290LCBpbmRleCkgPT4ge1xuXG5cdFx0XHQvLyBEdXJpbmcgY2xpZW50IHRyYW5zaXRpb25zIHdlIGNyZWF0ZSBvdXIgcm9vdFxuXHRcdFx0Ly8gZWxlbWVudHMgYXMgd2UgZ28uXG5cdFx0XHRpZiAoIXJvb3QgJiYgdGhpcy5fcHJldmlvdXNseVJlbmRlcmVkKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIF9wcmV2aW91c18gcmVuZGVyIGhhZCBlbGVtZW50cyB0aGF0XG5cdFx0XHRcdC8vIHdlIGNhbiByZS11c2Ugd2UnbGwgcmVuZGVyIGludG8gdGhlbS5cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gRE9NIHJlLXVzZSBpcyBjdXJyZW50bHkgb3B0LWluLlxuXHRcdFx0XHQvL1xuXHRcdFx0XHRpZiAodGhpcy5fcmV1c2VEb20pIHtcblx0XHRcdFx0XHRvbGRSb290RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG5cdFx0XHRcdFx0XHRgZGl2WyR7UkVBQ1RfU0VSVkVSX0RBVEFfQVRUUklCVVRFfT1cIiR7aW5kZXh9XCJdYFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0b2xkUm9vdENvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG5cdFx0XHRcdFx0XHRgZGl2WyR7UEFHRV9DT05UQUlORVJfTk9ERV9JRH09XCIke2luZGV4fVwiXWBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVGhlIGN1cnJlbnQgc3RyYXRlZ3kgZm9yIHJlLXVzZSBpczogU28gbG9uZ1xuXHRcdFx0XHQvLyBhcyB0aGUgX3NoYXBlXyBvZiB0aGUgcm9vdCBzdHJ1Y3R1cmUgaXMgdGhlXG5cdFx0XHRcdC8vIHNhbWUsIHdlJ2xsIHJlLXVzZS4gIE9uY2UgdGhlIG5ldyBwYWdlJ3Ncblx0XHRcdFx0Ly8gc2hhcGUgZGl2ZXJnZXMsIHdlJ2xsIGJsb3cgYXdheSB0aGVcblx0XHRcdFx0Ly8gcmVtYWluaW5nIGVsZW1lbnRzIGxlZnQgb3ZlciBmcm9tIHRoZVxuXHRcdFx0XHQvLyBwcmV2aW91cyBwYWdlIGFuZCBjcmVhdGUgZXZlcnl0aGluZyBmb3IgdGhlXG5cdFx0XHRcdC8vIG5ldyBwYWdlIGFzIHdlIGdvLlxuXHRcdFx0XHQvL1xuXHRcdFx0XHRpZiAodGhpcy5fcmV1c2VEb20gJiYgZWxlbWVudC5jb250YWluZXJPcGVuICYmIG9sZFJvb3RDb250YWluZXIpIHtcblx0XHRcdFx0XHRtb3VudE5vZGUgPSBvbGRSb290Q29udGFpbmVyO1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZUNvbnRhaW5lck5vZGVBdHRyaWJ1dGVzKFxuXHRcdFx0XHRcdFx0bW91bnROb2RlLFxuXHRcdFx0XHRcdFx0ZWxlbWVudC5jb250YWluZXJPcGVuXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9yZXVzZURvbSAmJiBlbGVtZW50LmNvbnRhaW5lckNsb3NlICYmICFvbGRSb290Q29udGFpbmVyICYmICFvbGRSb290RWxlbWVudCkge1xuXHRcdFx0XHRcdG1vdW50Tm9kZSA9IG1vdW50Tm9kZS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3JldXNlRG9tICYmIG9sZFJvb3RFbGVtZW50KSB7XG5cdFx0XHRcdFx0cm9vdCA9IG9sZFJvb3RFbGVtZW50O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2NsZWFudXBQcmV2aW91c1JlbmRlcihpbmRleCk7XG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQuY29udGFpbmVyT3Blbil7XG5cblx0XHRcdFx0XHRcdC8vIElmIHdlJ3JlIG9wZW5pbmcgYSBjb250YWluZXIgdGhhdCdzXG5cdFx0XHRcdFx0XHQvLyBvdXIgbmV3IG1vdW50Tm9kZS5cblx0XHRcdFx0XHRcdG1vdW50Tm9kZSA9IHRoaXMuX2NyZWF0ZUNvbnRhaW5lck5vZGUoXG5cdFx0XHRcdFx0XHRcdG1vdW50Tm9kZSxcblx0XHRcdFx0XHRcdFx0ZWxlbWVudC5jb250YWluZXJPcGVuLFxuXHRcdFx0XHRcdFx0XHRpbmRleFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGVsZW1lbnQuY29udGFpbmVyQ2xvc2UpIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgd2UncmUgY2xvc2luZyBhIGNvbnRhaW5lciBpdHNcblx0XHRcdFx0XHRcdC8vIHBhcmVudCBpcyBvbmNlIGFnYWluIG91ciBtb3VudE5vZGUuXG5cdFx0XHRcdFx0XHRtb3VudE5vZGUgPSBtb3VudE5vZGUucGFyZW50Tm9kZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFlbGVtZW50LmlzVGhlRm9sZCkge1xuXG5cdFx0XHRcdFx0XHQvLyBOZWVkIGEgbmV3IHJvb3QgZWxlbWVudCBpbiBvdXJcblx0XHRcdFx0XHRcdC8vIGN1cnJlbnQgbW91bnROb2RlLlxuXHRcdFx0XHRcdFx0cm9vdCA9IHRoaXMuX2NyZWF0ZVJlYWN0U2VydmVyUm9vdE5vZGUobW91bnROb2RlLCBpbmRleClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZWxlbWVudC5jb250YWluZXJPcGVuIHx8IGVsZW1lbnQuY29udGFpbmVyQ2xvc2Upe1xuXHRcdFx0XHRyZXR1cm47IC8vIE5vdGhpbmcgbGVmdCB0byBkby5cblx0XHRcdH0gZWxzZSBpZiAoZWxlbWVudC5pc1RoZUZvbGQpIHtcblx0XHRcdFx0aWYgKCF0aGlzLl9wcmV2aW91c2x5UmVuZGVyZWQpe1xuXHRcdFx0XHRcdGxvZ1RpbWluZ0RhdGEoYHJlbmRlckFib3ZlVGhlRm9sZC5mcm9tU3RhcnRgLCB0U3RhcnQpO1xuXHRcdFx0XHRcdGxvZ1RpbWluZ0RhdGEoYHJlbmRlckFib3ZlVGhlRm9sZC5pbmRpdmlkdWFsYCwgMCwgdG90YWxSZW5kZXJUaW1lKTtcblx0XHRcdFx0XHRsb2dUaW1pbmdEYXRhKGByZW5kZXJBYm92ZVRoZUZvbGQuZWxlbWVudENvdW50YCwgMCwgaW5kZXggKyAxKTtcblxuXHRcdFx0XHRcdHBlcmZvcm1hbmNlTWFyaygncmVuZGVyQWJvdmVUaGVGb2xkJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuOyAvLyBBZ2FpbiwgdGhpcyBpc24ndCBhIHJlYWwgcm9vdCBlbGVtZW50LlxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbmFtZSAgPSBQYWdlVXRpbC5nZXRFbGVtZW50RGlzcGxheU5hbWUoZWxlbWVudClcblx0XHRcdCwgICB0aW1lciA9IGxvZ2dlci50aW1lcihgcmVuZGVyRWxlbWVudC5pbmRpdmlkdWFsLiR7bmFtZX1gKVxuXG5cdFx0XHRlbGVtZW50ID0gUmVhY3QuY2xvbmVFbGVtZW50KGVsZW1lbnQsIHsgY29udGV4dDogdGhpcy5jb250ZXh0IH0pO1xuXHRcdFx0dmFyIHJlbmRlckZ1bmMgPSBSZWFjdERPTS5oeWRyYXRlIHx8IFJlYWN0RE9NLnJlbmRlcjtcblx0XHRcdHJlbmRlckZ1bmMoZWxlbWVudCwgcm9vdCk7XG5cblx0XHRcdF8uZm9yRWFjaChcblx0XHRcdFx0Z2V0Um9vdEVsZW1lbnRBdHRyaWJ1dGVzKGVsZW1lbnQpLFxuXHRcdFx0XHQodiwgaykgPT4gcm9vdC5zZXRBdHRyaWJ1dGUoaywgdilcblx0XHRcdCk7XG5cblx0XHRcdHRvdGFsUmVuZGVyVGltZSArPSB0aW1lci5zdG9wKCk7XG5cblx0XHRcdGlmICghdGhpcy5fcHJldmlvdXNseVJlbmRlcmVkKXtcblx0XHRcdFx0dmFyIHREaXNwbGF5ID0gcm9vdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmVhY3Qtc2VydmVyLXRpbWluZy1vZmZzZXQnKTtcblx0XHRcdFx0bG9nVGltaW5nRGF0YShgZGlzcGxheUVsZW1lbnQuZnJvbVN0YXJ0LiR7bmFtZX1gLCAwLCArdERpc3BsYXkpO1xuXHRcdFx0XHRsb2dUaW1pbmdEYXRhKGByZW5kZXJFbGVtZW50LmZyb21TdGFydC4ke25hbWV9YCwgdFN0YXJ0KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3QgcmVuZGVyT25lID0gKHByb21pc2UsIGluZGV4KSA9PiBwcm9taXNlLnRoZW4oXG5cdFx0XHRlbGVtZW50ID0+IHJvb3ROb2RlUHJvbWlzZXNbaW5kZXhdXG5cdFx0XHRcdC50aGVuKHJvb3QgPT4gcmVuZGVyRWxlbWVudChlbGVtZW50LCByb290LCBpbmRleCkpXG5cdFx0XHRcdC5jYXRjaChlID0+IHtcblx0XHRcdFx0XHQvLyBUaGUgb25seSBjYXNlIHdoZXJlIHRoaXMgc2hvdWxkIGV2YWx1YXRlIHRvIGZhbHNlIGlzXG5cdFx0XHRcdFx0Ly8gd2hlbiBgZWxlbWVudGAgaXMgYSBjb250YWluZXJDbG9zZS9jb250YWluZXJPcGVuIG9iamVjdFxuXHRcdFx0XHRcdGNvbnN0IGNvbXBvbmVudFR5cGUgPSB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0XHQ/IGVsZW1lbnQucHJvcHMuY2hpbGRyZW4udHlwZS5uYW1lXG5cdFx0XHRcdFx0XHQ6ICdlbGVtZW50Jztcblx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoYEVycm9yIHdpdGggZWxlbWVudCAke2NvbXBvbmVudFR5cGV9J3MgbGlmZWN5Y2xlIG1ldGhvZHMgYXQgaW5kZXggJHtpbmRleH1gLCBlKTtcblx0XHRcdFx0fSlcblx0XHQpLmNhdGNoKGUgPT4gbG9nZ2VyLmVycm9yKGBFcnJvciB3aXRoIGVsZW1lbnQgcHJvbWlzZSAke2luZGV4fWAsIGUpKVxuXG5cdFx0aWYgKHRoaXMuX3ByZXZpb3VzbHlSZW5kZXJlZCl7XG5cblx0XHRcdC8vIE9uIGNsaWVudCB0cmFuc2l0aW9ucyB0aGUgcm9vdCBzdHJ1Y3R1cmUgaXMgbGFpZCBvdXQgdXNpbmcgYVxuXHRcdFx0Ly8gc3RhdGUgbWFjaGluZSB0aGF0IHJlcXVpcmVzIHVzIHRvIHJlbmRlciBpbiBvcmRlci5cblx0XHRcdGVsZW1lbnRQcm9taXNlc09yLnJlZHVjZShcblx0XHRcdFx0KGNoYWluLCBwcm9taXNlLCBpbmRleCkgPT4gY2hhaW4udGhlbigoKSA9PiByZW5kZXJPbmUocHJvbWlzZSwgaW5kZXgpKSxcblx0XHRcdFx0USgpXG5cdFx0XHQpLnRoZW4ocmV0dmFsLnJlc29sdmUpO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIE9uIHRoZSBmaXJzdCByZW5kZXIgd2UgY2FuIGdvIG91dCBvZiBvcmRlciBiZWNhdXNlIHRoZSBzZXJ2ZXJcblx0XHRcdC8vIGhhcyBhbHJlYWR5IGxhaWQgb3V0IHRoZSByb290IHN0cnVjdHVyZSBmb3IgdXMuXG5cdFx0XHRRLmFsbChlbGVtZW50UHJvbWlzZXNPci5tYXAocmVuZGVyT25lKSkudGhlbihyZXR2YWwucmVzb2x2ZSk7XG5cblx0XHRcdC8vIExvb2sgb3V0IGZvciBhIGZhaWxzYWZlIHRpbWVvdXQgZnJvbSB0aGUgc2VydmVyIG9uIG91clxuXHRcdFx0Ly8gZmlyc3QgcmVuZGVyLlxuXHRcdFx0dGhpcy5fZmFpbERmZC5wcm9taXNlLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRlbGVtZW50UHJvbWlzZXMuZm9yRWFjaCgocHJvbWlzZSwgaW5kZXgpID0+IHtcblx0XHRcdFx0XHQvL1JlamVjdCBhbnkgZWxlbWVudHMgdGhhdCBoYXZlIGZhaWxlZCB0byByZW5kZXJcblx0XHRcdFx0XHRpZiAocHJvbWlzZS5pc1BlbmRpbmcoKSkge1xuXHRcdFx0XHRcdFx0dGltZW91dERmZFtpbmRleF0ucmVqZWN0KGBFcnJvciB3aXRoIGVsZW1lbnQgJHtpbmRleH0sIGl0IGZhaWxlZCB0byByZW5kZXIgd2l0aGluIHRpbWVvdXQgdGltZWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0dmFsLnByb21pc2UudGhlbigoKSA9PiB7XG5cblx0XHRcdGlmICh0aGlzLl9yZXVzZURvbSkge1xuXG5cdFx0XHRcdC8vIENsZWFuIHVwIGFueSBkYW5nbGluZyBub2RlcyBpZiB0aGUgcHJldmlvdXMgcGFnZSBoYWQgbW9yZVxuXHRcdFx0XHQvLyB0aGFuIHdlIGRvLlxuXHRcdFx0XHR0aGlzLl9jbGVhbnVwUHJldmlvdXNSZW5kZXIoZWxlbWVudFByb21pc2VzLmxlbmd0aCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoaXMgZmlyc3Qgb25lIGlzIGp1c3QgZm9yIGhpc3RvcmljYWwgY29udGludWl0eS5cblx0XHRcdGxvZ1RpbWluZ0RhdGEoJ3JlbmRlcicsIHQwKTtcblxuXHRcdFx0Ly8gVGhlc2UgYXJlIG1vcmUgaW50ZXJlc3RpbmcuXG5cdFx0XHRsb2dUaW1pbmdEYXRhKCdyZW5kZXJDUFVUaW1lJywgMCwgdG90YWxSZW5kZXJUaW1lKTtcblxuXHRcdFx0Ly8gRG9uJ3QgdHJhY2sgdGhpcyBvbiBjbGllbnQgdHJhbnNpdGlvbnMuXG5cdFx0XHRpZiAoIXRoaXMuX3ByZXZpb3VzbHlSZW5kZXJlZCl7XG5cdFx0XHRcdGxvZ1RpbWluZ0RhdGEoJ3JlbmRlckZyb21TdGFydCcsIHRTdGFydCk7XG5cblx0XHRcdFx0cGVyZm9ybWFuY2VNYXJrKCdyZW5kZXJDb21wbGV0ZScpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTb21lIHRoaW5ncyBhcmUganVzdCBkaWZmZXJlbnQgb24gb3VyIGZpcnN0IHBhc3MuXG5cdFx0XHR0aGlzLl9wcmV2aW91c2x5UmVuZGVyZWQgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLmVtaXQoJ3JlbmRlcicpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFucyB1cCBhIHByZXZpb3VzIFJlYWN0IHJlbmRlciBpbiB0aGUgZG9jdW1lbnQuIFVubW91bnRzIGFsbCB0aGUgY29tcG9uZW50cyBhbmQgZGVzdG95cyB0aGUgbW91bnRpbmdcblx0ICogRE9NIG5vZGUocykgdGhhdCB3ZXJlIGNyZWF0ZWQuXG5cdCAqL1xuXHRfY2xlYW51cFByZXZpb3VzUmVuZGVyKGluZGV4KSB7XG5cblx0XHRpbmRleCA9IGluZGV4IHx8IDA7IC8vIERlZmF1bHQgdG8gZXZlcnl0aGluZy5cblxuXHRcdGlmICh0aGlzLl9wcmV2aW91c2x5UmVuZGVyZWQgJiYgIVJMUygpLmhhdmVDbGVhbmVkUHJldmlvdXNSZW5kZXIpIHtcblxuXHRcdFx0Ly8gT25seSBuZWVkIHRvIGRvIHRoaXMgb25jZSBwZXIgcmVxdWVzdC5cblx0XHRcdFJMUygpLmhhdmVDbGVhbmVkUHJldmlvdXNSZW5kZXIgPSB0cnVlO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoXCJSZW1vdmluZyBwcmV2aW91cyBwYWdlJ3MgUmVhY3QgY29tcG9uZW50c1wiKTtcblxuXHRcdFx0W10uc2xpY2UuY2FsbChcblx0XHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgZGl2WyR7UkVBQ1RfU0VSVkVSX0RBVEFfQVRUUklCVVRFfV1gKVxuXHRcdFx0KS5mb3JFYWNoKChyb290LCBpKSA9PiB7XG5cdFx0XHRcdGlmIChpID49IGluZGV4KSB7XG5cdFx0XHRcdFx0Ly8gU2luY2UgdGhpcyBub2RlIGhhcyBhIFwiZGF0YS1yZWFjdC1zZXJ2ZXItcm9vdC1pZFwiXG5cdFx0XHRcdFx0Ly8gYXR0cmlidXRlLCB3ZSBjYW4gYXNzdW1lIHRoYXQgd2UgY3JlYXRlZCBpdFxuXHRcdFx0XHRcdC8vIGFuZCBzaG91bGQgZGVzdHJveSBpdC4gRGVzdHJ1Y3Rpb24gbWVhbnNcblx0XHRcdFx0XHQvLyBmaXJzdCB1bm1vdW50aW5nIGZyb20gUmVhY3QgYW5kIHRoZW5cblx0XHRcdFx0XHQvLyBkZXN0cm95aW5nIHRoZSBET00gbm9kZS5cblx0XHRcdFx0XHRSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKHJvb3QpO1xuXHRcdFx0XHRcdHJvb3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyb290KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdFtdLnNsaWNlLmNhbGwoXG5cdFx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYGRpdlske1BBR0VfQ09OVEFJTkVSX05PREVfSUR9XWApXG5cdFx0XHQpLmZvckVhY2goKHJvb3QsIGkpID0+IHtcblx0XHRcdFx0aWYgKGkgPj0gaW5kZXgpIHtcblx0XHRcdFx0XHQvLyBHb3R0YSBnZXQgcmlkIG9mIG91ciBjb250YWluZXJzLFxuXHRcdFx0XHRcdC8vIHRvby4gIE5lZWQgdG8gZG8gdGhpcyBfYWZ0ZXJfXG5cdFx0XHRcdFx0Ly8ga2lsbGluZyB0aGUgZWxlbWVudHMsIHNpbmNlIHRoZXlcblx0XHRcdFx0XHQvLyBtaWdodCBsaXZlIHdpdGhpbiB0aGVzZSBjb250YWluZXJzLlxuXHRcdFx0XHRcdHJvb3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyb290KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgZGl2IHRvIHJlbmRlciBhIFJlYWN0RWxlbWVudCBpbiB0byBhdCB0aGUgZW5kIG9mIHRoZSBtb3VudCBub2RlLlxuXHQgKi9cblx0X2NyZWF0ZVJlYWN0U2VydmVyUm9vdE5vZGUobW91bnROb2RlLCBpbmRleCkge1xuXHRcdHZhciByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRyb290LnNldEF0dHJpYnV0ZShSRUFDVF9TRVJWRVJfREFUQV9BVFRSSUJVVEUsIGluZGV4KTtcblx0XHRtb3VudE5vZGUuYXBwZW5kQ2hpbGQocm9vdCk7XG5cdFx0cmV0dXJuIHJvb3Q7XG5cdH1cblxuXHRfY3JlYXRlQ29udGFpbmVyTm9kZShtb3VudE5vZGUsIGF0dHJzLCBpKSB7XG5cdFx0dmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdG5vZGUuc2V0QXR0cmlidXRlKFBBR0VfQ09OVEFJTkVSX05PREVfSUQsIGkpO1xuXHRcdF8uZm9yRWFjaChhdHRycywgKHYsIGspID0+IG5vZGUuc2V0QXR0cmlidXRlKGssIHYpKTtcblx0XHRtb3VudE5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblxuXHRfdXBkYXRlQ29udGFpbmVyTm9kZUF0dHJpYnV0ZXMobm9kZSwgYXR0cnMpIHtcblx0XHRfLmZvckVhY2goYXR0cnMsICh2LCBrKSA9PiBub2RlLnNldEF0dHJpYnV0ZShrLCB2KSk7XG5cdH1cblxuXHRpbml0ICgpIHtcblxuXHRcdHZhciB1bmxvYWRIYW5kbGVyID0gKCkgPT4ge3RoaXMudGVybWluYXRlKCk7IH07XG5cblx0XHRpZiAod2luZG93ICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAod2luZG93ICYmIHdpbmRvdy5hdHRhY2hFdmVudCkge1xuXHRcdFx0d2luZG93LmF0dGFjaEV2ZW50KFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlcik7XG5cdFx0fVxuXG5cdFx0dGhpcy5faW5pdGlhbGl6ZUhpc3RvcnlMaXN0ZW5lcih0aGlzLmNvbnRleHQpO1xuXG5cdFx0Ly8gSWYgdGhpcyBpcyBhIF9yZWZyZXNoXyB0aGVyZSBtYXkgYmUgc29tZSByZXF1ZXN0IG9wdGlvbnNcblx0XHQvLyBzdGFzaGVkIGluIHRoZSBoaXN0b3J5IG5hdmlnYXRpb24gc3RhY2sgZnJhbWUgd2UncmUgc2l0dGluZ1xuXHRcdC8vIG9uLlxuXHRcdGNvbnN0IHN0YXRlID0gdGhpcy5faGlzdG9yeS5jYW5DbGllbnROYXZpZ2F0ZSgpICYmIGhpc3Rvcnkuc3RhdGU7XG5cblx0XHR0aGlzLl9uYXZpZ2F0ZVdpdGhIaXN0b3J5U3RhdGUoe1xuXHRcdFx0c3RhdGUsXG5cdFx0XHRwYXRoOiBnZXRIaXN0b3J5UGF0aG5hbWUoKSxcblx0XHRcdHR5cGU6IEhpc3RvcnkuZXZlbnRzLlBBR0VMT0FELFxuXHRcdH0pO1xuXHR9XG5cblx0X25hdmlnYXRlV2l0aEhpc3RvcnlTdGF0ZSh7cGF0aCwgc3RhdGUsIHR5cGUsIGNoZWNrfSkge1xuXHRcdGNvbnN0IG9wdHMgPSAoc3RhdGV8fHt9KS5yZWFjdFNlcnZlckZyYW1lO1xuXG5cdFx0aWYgKGNoZWNrICYmICFvcHRzKSByZXR1cm47IC8vIE5vdCBvdXIgZnJhbWUuXG5cblx0XHR0aGlzLmNvbnRleHQubmF2aWdhdGUobmV3IENsaWVudFJlcXVlc3QocGF0aCwgb3B0c3x8e30pLCB0eXBlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB1cyB0byBsaXN0ZW4gdG8gYmFjayBidXR0b24gZXZlbnRzLiBXaGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlIGJhY2sgYnV0dG9uLCB0aGUgaGlzdG9yeVxuXHQgKiBsaXN0ZW5lciB3aWxsIGJlIGNhbGxlZCBhbmQgY2F1c2UgYSBuYXZpZ2F0ZSgpIGV2ZW50LlxuXHQgKi9cblx0X2luaXRpYWxpemVIaXN0b3J5TGlzdGVuZXIoKSB7XG5cblx0XHR0aGlzLl9oaXN0b3J5TGlzdGVuZXIgPSAoe3N0YXRlfSkgPT4ge1xuXHRcdFx0dGhpcy5fbmF2aWdhdGVXaXRoSGlzdG9yeVN0YXRlKHtcblx0XHRcdFx0c3RhdGUsXG5cdFx0XHRcdHBhdGggIDogdGhpcy5faGlzdG9yeS5nZXRQYXRoKCksXG5cdFx0XHRcdHR5cGUgIDogSGlzdG9yeS5ldmVudHMuUE9QU1RBVEUsIC8vIEZvcndhcmQvYmFjay5cblx0XHRcdFx0Y2hlY2sgOiB0cnVlLCAvLyBPbmx5IG5hdmlnYXRlIGlmIGZyYW1lIGlzIG91cnMuXG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0dGhpcy5faGlzdG9yeSA9IG5ldyBIaXN0b3J5KCk7XG5cdFx0dmFyIGluaXQgPSAoKSA9PiB0aGlzLl9oaXN0b3J5Lm9uKHRoaXMuX2hpc3RvcnlMaXN0ZW5lcik7XG5cblx0XHQvLyBOZWVkIHRvIGdvIF9hZnRlcl8gJ2xvYWQnIGNhbGxiYWNrcyBjb21wbGV0ZS5cblx0XHQvLyBTYWZhcmkgZmlyZXMgYSAncG9wc3RhdGUnIG9uIGxvYWQgKFJFRC02NzYwMCkuXG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL3BvcHN0YXRlXG5cdFx0aWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpe1xuXHRcdFx0aW5pdCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpPT5zZXRUaW1lb3V0KGluaXQsMCkpO1xuXHRcdH1cblx0fVxuXG5cdF9zZXR1cEFycml2YWxIYW5kbGVycyAoKSB7XG5cdFx0Ly8gdXNlZCBieSA8c2NyaXB0PiBjYWxsYmFja3MgdG8gcmVnaXN0ZXIgZGF0YSBzZW50IGRvd24gb24gdGhlXG5cdFx0Ly8gaW5pdGlhbCBjb25uZWN0aW9uIGFmdGVyIGluaXRpYWwgcmVuZGVyXG5cdFx0d2luZG93Ll9fcmVhY3RTZXJ2ZXJDbGllbnRDb250cm9sbGVyID0gdGhpcztcblx0fVxuXG5cdF9lbnN1cmVSb290Tm9kZURmZCAoaW5kZXgpIHtcblx0XHRpZiAoIXRoaXMuX3Jvb3ROb2RlRGZkc1tpbmRleF0pe1xuXHRcdFx0dGhpcy5fcm9vdE5vZGVEZmRzW2luZGV4XSA9IFEuZGVmZXIoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3Jvb3ROb2RlRGZkc1tpbmRleF07XG5cdH1cblxuXHRkYXRhQXJyaXZhbCAodXJsLCBkZWh5ZHJhdGVkRW50cnkpIHtcblx0XHRSZWFjdFNlcnZlckFnZW50LmNhY2hlKCkubGF0ZUFycml2YWwodXJsLCBkZWh5ZHJhdGVkRW50cnkpO1xuXHR9XG5cblx0bm9kZUFycml2YWwgKHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG5cblx0XHQvLyBUaGUgc2VydmVyIGhhcyBqdXN0IGxldCB1cyBrbm93IHRoYXQgYSBwcmUtcmVuZGVyZWQgcm9vdFxuXHRcdC8vIGVsZW1lbnQgaGFzIGFycml2ZWQuICBXZSdsbCBncmFiIGEgcmVmZXJlbmNlIHRvIGl0cyBET01cblx0XHQvLyBub2RlIGFuZCB1bi1ibG9jayBjbGllbnQtc2lkZSByZW5kZXJpbmcgb2YgdGhlIGVsZW1lbnQgdGhhdFxuXHRcdC8vIHdlJ3JlIGdvaW5nIHRvIG1vdW50IGludG8gaXQuXG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPD0gZW5kSW5kZXg7IGkrKykge1xuXHRcdFx0dGhpcy5fZW5zdXJlUm9vdE5vZGVEZmQoaSkucmVzb2x2ZShcblx0XHRcdFx0dGhpcy5tb3VudE5vZGUucXVlcnlTZWxlY3Rvcihcblx0XHRcdFx0XHRgZGl2WyR7UkVBQ1RfU0VSVkVSX0RBVEFfQVRUUklCVVRFfT1cIiR7aX1cIl1gXG5cdFx0XHRcdClcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0ZmFpbEFycml2YWwgKCkge1xuXHRcdHRoaXMuX2ZhaWxEZmQucmVzb2x2ZSgpO1xuXHR9XG5cbn1cblxuZnVuY3Rpb24gY2hlY2tOb3RFbXB0eShzdGF0ZSwga2V5KSB7XG5cdGlmICh0eXBlb2Ygc3RhdGVba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgbXNnID0ga2V5ICsgJyBub3QgZGVmaW5lZCBpbiBkZWh5ZHJhdGVkIHN0YXRlJztcblx0XHRsb2dnZXIuZXJyb3IobXNnKVxuXHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQ29uZmlnKGRlaHlkcmF0ZWRDb25maWcpIHtcblx0Ly8gcmVoeWRyYXRlIHRoZSBjb25maWcgb2JqZWN0XG5cdHZhciBjb25maWcgPSByZXF1aXJlKFwiLi9jb25maWdcIikoKTtcblx0Y29uZmlnLnJlaHlkcmF0ZShkZWh5ZHJhdGVkQ29uZmlnKTtcblx0cmV0dXJuIGNvbmZpZztcbn1cblxuZnVuY3Rpb24gYnVpbGRDb250ZXh0KHJvdXRlcykge1xuXHR2YXIgY29udGV4dCA9IG5ldyBSZXF1ZXN0Q29udGV4dC5CdWlsZGVyKClcblx0XHQuc2V0Um91dGVzKHJvdXRlcylcblx0XHQuY3JlYXRlKCk7XG5cblx0cmV0dXJuIGNvbnRleHQ7XG59XG5cbi8vIENyZWF0ZSBhIFwidXNlciB0aW1pbmdcIiBpbiBXZWJQYWdlVGVzdC5cbmZ1bmN0aW9uIHBlcmZvcm1hbmNlTWFyayhuYW1lKSB7XG5cdGlmICh3aW5kb3cucGVyZm9ybWFuY2UgJiYgcGVyZm9ybWFuY2UubWFyaykge1xuXHRcdHBlcmZvcm1hbmNlLm1hcmsoYHJlYWN0LXNlcnZlci4ke25hbWV9YCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gbG9nVGltaW5nRGF0YShidWNrZXQsIHN0YXJ0LCBlbmQgPSBuZXcgRGF0ZSkge1xuXHRpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vZG9uJ3Qgc2VuZCB0aW1pbmcgZGF0YSBpZiBzdGFydCB0aW1pbmcgaXMgdW5kZWZpbmVkXG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0bG9nZ2VyLnRpbWUoYnVja2V0LCBlbmQgLSBzdGFydCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50Q29udHJvbGxlcjtcbiJdfQ==
