'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = require('react');
var PropTypes = require('prop-types');
var Q = require('q');

var _require = require('./TheFold'),
    isTheFold = _require.isTheFold;

var _ = {
	assign: require('lodash/assign')
};

var logger = require('../logging').getLogger({ "name": "react-server.core.components.RootElement", "color": { "server": 75, "client": "rgb(42,127,212)" } });

var RootElement = function (_React$Component) {
	_inherits(RootElement, _React$Component);

	function RootElement(props) {
		_classCallCheck(this, RootElement);

		var _this = _possibleConstructorReturn(this, (RootElement.__proto__ || Object.getPrototypeOf(RootElement)).call(this, props));

		_this.state = {
			childProps: props.childProps
		};
		return _this;
	}

	_createClass(RootElement, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var _this2 = this;

			if (this.props.subscribe) {
				this.props.subscribe(function (childProps) {
					var now = new Date();
					var name = _this2.getChildName();
					var count = ++_this2._changeCount;
					var fromMount = now - _this2._t0;
					var fromLastChange = now - _this2._t1;
					_this2._t1 = now;

					// Log some stuff about the change.
					['byName.' + name, 'all'].forEach(function (tag) {
						logger.time('change.fromMount.' + tag, fromMount);
						logger.time('change.fromLastChange.' + tag, fromLastChange);
						logger.gauge('change.count.' + tag, count);
					});

					// Okay, now we've complained about it
					// sufficiently, let's go ahead and update.
					var newChildProps = _.assign({}, _this2.state.childProps, childProps);
					_this2.setState({
						childProps: newChildProps
					});
				});
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			if (this.props.unsubscribe) this.props.unsubscribe();
		}
	}, {
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps(nextProps) {
			// Incase we receive new props such as during client transitions
			// We will want to update our state's childProp with any new childProps
			// that may have been passed in. This still respects props as the ultimate source of truth
			var newChildProps = _.assign({}, this.state.childProps, nextProps.childProps);
			this.setState({
				childProps: newChildProps
			});
		}
	}, {
		key: 'render',
		value: function render() {

			// We'll use these to log stuff about re-renders.
			if (!this._t0) {
				this._t0 = this._t1 = new Date();
				this._changeCount = 0;
			}

			if (typeof this.props.children === 'string') {

				logger.error("Root elements cannot be raw text", { text: this.props.children });

				// Don't keep choking on it.  Just gut it.
				return React.createElement('div', null);
			}

			return React.cloneElement(React.Children.only(this.props.children), this.state.childProps);
		}
	}, {
		key: 'getChildName',
		value: function getChildName() {
			if (!this._childName) {
				this._childName = (React.Children.only(this.props.children).type.displayName || 'Unknown').split('.').pop();
			}
			return this._childName;
		}
	}]);

	return RootElement;
}(React.Component);

module.exports = RootElement;

RootElement.propTypes = {
	listen: PropTypes.func,
	when: PropTypes.object, // A promise.
	childProps: PropTypes.object,
	_isRootElement: PropTypes.bool
};

RootElement.defaultProps = {
	_isRootElement: true
};

RootElement.isRootElement = function (element) {
	return element && element.props && element.props._isRootElement;
};

RootElement.getRootElementAttributes = function (element) {
	var props = element.props;
	var attrs = {};

	if (props.className) attrs.class = props.className;

	// TODO: Others?
	['id', 'style'].forEach(function (k) {
		return props[k] && (attrs[k] = props[k]);
	});

	return attrs;
};

RootElement.ensureRootElementWithContainer = function (element, container) {

	// If it's _already_ a root element (or the fold), pass it along.
	if (RootElement.isRootElement(element) || isTheFold(element) ||

	// Alternatively, if it's a control object pass it along.
	//
	// We exclude strings here since we already gripe about them
	// at render time.
	//
	!React.isValidElement(element) && typeof element !== 'string') {
		return element;
	}

	var _container$props = container.props,
	    listen = _container$props.listen,
	    when = _container$props.when;


	return React.createElement(
		RootElement,
		{ listen: listen, when: when },
		element
	);
};

RootElement.ensureRootElement = function (element) {
	return RootElement.ensureRootElementWithContainer(element, { props: {} });
};

RootElement.installListener = function (element, listen) {
	var dfd = Q.defer(),
	    updater,
	    subscribe = function subscribe(callback) {
		updater = callback;
	},
	    unsubscribe = listen(function (childProps) {
		// Once the component has mounted it will provide an updater.
		// After that we can just short-circuit here and let it handle
		// updating itself.
		if (updater) {
			updater(childProps);
		}

		// The promise itself will only resolve once, but we don't
		// want to _clone_ multiple times.
		else if (dfd.promise.isPending()) {
				dfd.resolve(React.cloneElement(element, {
					childProps: childProps,
					subscribe: subscribe,
					unsubscribe: unsubscribe
				}));
			}
	});
	return dfd.promise;
};

RootElement.scheduleRender = function (element) {
	var _ref = (element || {}).props || {},
	    listen = _ref.listen,
	    when = _ref.when,
	    componentLoader = _ref.componentLoader,
	    childProps = _ref.childProps;

	if (!(listen || when || componentLoader || childProps)) {
		return Q(element).then(RootElement.ensureRootElement);
	}

	// This is what we'll ultimately resolve our return promise with.
	// It may be changed by the output of `listen` or `when`.
	var rendered = element;
	var componentLoaderDeferred = componentLoader ? componentLoader() : null;

	// Install the listener right away to start gathering props.
	// It may be a gated emitter, but we want to make sure we squeeze
	// props out of it from the beginning if it's not.
	// Finally gate on the `when`.
	return Q(listen && RootElement.installListener(element, listen)).then(function (el) {
		return el && (rendered = el);
	}).then(function () {
		return Q.allSettled([when, componentLoaderDeferred]);
	}).then(function (results) {
		var _results = _slicedToArray(results, 2),
		    whenResult = _results[0],
		    loadedComponent = _results[1];

		if (whenResult.value || loadedComponent.value || childProps) {
			// merge in child props from listen, when, and childProps
			var clonedChildProps = _.assign({}, rendered.props.childProps, whenResult.value, childProps);

			// if we have a component loader specified, copy the resolved component
			// and render that with the current child as a child of that component
			var currentChild = rendered.props.children;
			var childToRender = componentLoaderDeferred ? React.createElement(loadedComponent.value, null, currentChild) : currentChild;

			return React.cloneElement(rendered, { childProps: clonedChildProps }, childToRender);
		}
		return rendered;
	});
};
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHMvUm9vdEVsZW1lbnQuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJyZXF1aXJlIiwiUHJvcFR5cGVzIiwiUSIsImlzVGhlRm9sZCIsIl8iLCJhc3NpZ24iLCJsb2dnZXIiLCJnZXRMb2dnZXIiLCJSb290RWxlbWVudCIsInByb3BzIiwic3RhdGUiLCJjaGlsZFByb3BzIiwic3Vic2NyaWJlIiwibm93IiwiRGF0ZSIsIm5hbWUiLCJnZXRDaGlsZE5hbWUiLCJjb3VudCIsIl9jaGFuZ2VDb3VudCIsImZyb21Nb3VudCIsIl90MCIsImZyb21MYXN0Q2hhbmdlIiwiX3QxIiwiZm9yRWFjaCIsInRpbWUiLCJ0YWciLCJnYXVnZSIsIm5ld0NoaWxkUHJvcHMiLCJzZXRTdGF0ZSIsInVuc3Vic2NyaWJlIiwibmV4dFByb3BzIiwiY2hpbGRyZW4iLCJlcnJvciIsInRleHQiLCJjbG9uZUVsZW1lbnQiLCJDaGlsZHJlbiIsIm9ubHkiLCJfY2hpbGROYW1lIiwidHlwZSIsImRpc3BsYXlOYW1lIiwic3BsaXQiLCJwb3AiLCJDb21wb25lbnQiLCJtb2R1bGUiLCJleHBvcnRzIiwicHJvcFR5cGVzIiwibGlzdGVuIiwiZnVuYyIsIndoZW4iLCJvYmplY3QiLCJfaXNSb290RWxlbWVudCIsImJvb2wiLCJkZWZhdWx0UHJvcHMiLCJpc1Jvb3RFbGVtZW50IiwiZWxlbWVudCIsImdldFJvb3RFbGVtZW50QXR0cmlidXRlcyIsImF0dHJzIiwiY2xhc3NOYW1lIiwiY2xhc3MiLCJrIiwiZW5zdXJlUm9vdEVsZW1lbnRXaXRoQ29udGFpbmVyIiwiY29udGFpbmVyIiwiaXNWYWxpZEVsZW1lbnQiLCJlbnN1cmVSb290RWxlbWVudCIsImluc3RhbGxMaXN0ZW5lciIsImRmZCIsImRlZmVyIiwidXBkYXRlciIsImNhbGxiYWNrIiwicHJvbWlzZSIsImlzUGVuZGluZyIsInJlc29sdmUiLCJzY2hlZHVsZVJlbmRlciIsImNvbXBvbmVudExvYWRlciIsInRoZW4iLCJyZW5kZXJlZCIsImNvbXBvbmVudExvYWRlckRlZmVycmVkIiwiZWwiLCJhbGxTZXR0bGVkIiwicmVzdWx0cyIsIndoZW5SZXN1bHQiLCJsb2FkZWRDb21wb25lbnQiLCJ2YWx1ZSIsImNsb25lZENoaWxkUHJvcHMiLCJjdXJyZW50Q2hpbGQiLCJjaGlsZFRvUmVuZGVyIiwiY3JlYXRlRWxlbWVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsUUFBUUMsUUFBUSxPQUFSLENBQVo7QUFDQSxJQUFNQyxZQUFZRCxRQUFRLFlBQVIsQ0FBbEI7QUFDQSxJQUFJRSxJQUFJRixRQUFRLEdBQVIsQ0FBUjs7ZUFFb0JBLFFBQVEsV0FBUixDO0lBQWJHLFMsWUFBQUEsUzs7QUFFUCxJQUFNQyxJQUFJO0FBQ1RDLFNBQVFMLFFBQVEsZUFBUjtBQURDLENBQVY7O0FBSUEsSUFBSU0sU0FBU04sUUFBUSxZQUFSLEVBQXNCTyxTQUF0QixDQUFnQyxFQUFDLFFBQU8sMENBQVIsRUFBbUQsU0FBUSxFQUFDLFVBQVMsRUFBVixFQUFhLFVBQVMsaUJBQXRCLEVBQTNELEVBQWhDLENBQWI7O0lBRU1DLFc7OztBQUNMLHNCQUFZQyxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsd0hBQ1pBLEtBRFk7O0FBRWxCLFFBQUtDLEtBQUwsR0FBYTtBQUNaQyxlQUFZRixNQUFNRTtBQUROLEdBQWI7QUFGa0I7QUFLbEI7Ozs7c0NBRW1CO0FBQUE7O0FBQ25CLE9BQUksS0FBS0YsS0FBTCxDQUFXRyxTQUFmLEVBQTBCO0FBQ3pCLFNBQUtILEtBQUwsQ0FBV0csU0FBWCxDQUFxQixzQkFBYztBQUNsQyxTQUFJQyxNQUFpQixJQUFJQyxJQUFKLEVBQXJCO0FBQ0EsU0FBSUMsT0FBaUIsT0FBS0MsWUFBTCxFQUFyQjtBQUNBLFNBQUlDLFFBQWlCLEVBQUUsT0FBS0MsWUFBNUI7QUFDQSxTQUFJQyxZQUFpQk4sTUFBTSxPQUFLTyxHQUFoQztBQUNBLFNBQUlDLGlCQUFpQlIsTUFBTSxPQUFLUyxHQUFoQztBQUNBLFlBQUtBLEdBQUws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QVdFLEVBQWxCLENBQU47QUFBQSxFQURBLEVBRUxILElBRkssQ0FFQTtBQUFBLFNBQU14RSxFQUFFNEUsVUFBRixDQUFhLENBQUM5QixJQUFELEVBQU80Qix1QkFBUCxDQUFiLENBQU47QUFBQSxFQUZBLEVBR0xGLElBSEssQ0FHQSxtQkFBVztBQUFBLGdDQUNvQkssT0FEcEI7QUFBQSxNQUNYQyxVQURXO0FBQUEsTUFDQ0MsZUFERDs7QUFFaEIsTUFBSUQsV0FBV0UsS0FBWCxJQUFvQkQsZ0JBQWdCQyxLQUFwQyxJQUE2Q3ZFLFVBQWpELEVBQTZEO0FBQzVEO0FBQ0EsT0FBTXdFLG1CQUFtQi9FLEVBQUVDLE1BQUYsQ0FBUyxFQUFULEVBQWFzRSxTQUFTbEUsS0FBVCxDQUFlRSxVQUE1QixFQUF3Q3FFLFdBQVdFLEtBQW5ELEVBQTBEdkUsVUFBMUQsQ0FBekI7O0FBRUE7QUFDQTtBQUNBLE9BQU15RSxlQUFlVCxTQUFTbEUsS0FBVCxDQUFlc0IsUUFBcEM7QUFDQSxPQUFNc0QsZ0JBQWdCVCwwQkFBMEI3RSxNQUFNdUYsYUFBTixDQUFvQkwsZ0JBQWdCQyxLQUFwQyxFQUEyQyxJQUEzQyxFQUFpREUsWUFBakQsQ0FBMUIsR0FBMkZBLFlBQWpIOztBQUVBLFVBQU9yRixNQUFNbUMsWUFBTixDQUFtQnlDLFFBQW5CLEVBQTZCLEVBQUNoRSxZQUFZd0UsZ0JBQWIsRUFBN0IsRUFBNkRFLGFBQTdELENBQVA7QUFDQTtBQUNELFNBQU9WLFFBQVA7QUFDQSxFQWpCSyxDQUFQO0FBa0JBLENBakNEIiwiZmlsZSI6ImNvbXBvbmVudHMvUm9vdEVsZW1lbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xudmFyIFEgPSByZXF1aXJlKCdxJyk7XG5cbmNvbnN0IHtpc1RoZUZvbGR9ID0gcmVxdWlyZSgnLi9UaGVGb2xkJyk7XG5cbmNvbnN0IF8gPSB7XG5cdGFzc2lnbjogcmVxdWlyZSgnbG9kYXNoL2Fzc2lnbicpLFxufTtcblxudmFyIGxvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dpbmcnKS5nZXRMb2dnZXIoe1wibmFtZVwiOlwicmVhY3Qtc2VydmVyLmNvcmUuY29tcG9uZW50cy5Sb290RWxlbWVudFwiLFwiY29sb3JcIjp7XCJzZXJ2ZXJcIjo3NSxcImNsaWVudFwiOlwicmdiKDQyLDEyNywyMTIpXCJ9fSk7XG5cbmNsYXNzIFJvb3RFbGVtZW50IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cdFx0dGhpcy5zdGF0ZSA9IHtcblx0XHRcdGNoaWxkUHJvcHM6IHByb3BzLmNoaWxkUHJvcHMsXG5cdFx0fTtcblx0fVxuXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnN1YnNjcmliZSkge1xuXHRcdFx0dGhpcy5wcm9wcy5zdWJzY3JpYmUoY2hpbGRQcm9wcyA9PiB7XG5cdFx0XHRcdHZhciBub3cgICAgICAgICAgICA9IG5ldyBEYXRlO1xuXHRcdFx0XHR2YXIgbmFtZSAgICAgICAgICAgPSB0aGlzLmdldENoaWxkTmFtZSgpO1xuXHRcdFx0XHR2YXIgY291bnQgICAgICAgICAgPSArK3RoaXMuX2NoYW5nZUNvdW50O1xuXHRcdFx0XHR2YXIgZnJvbU1vdW50ICAgICAgPSBub3cgLSB0aGlzLl90MDtcblx0XHRcdFx0dmFyIGZyb21MYXN0Q2hhbmdlID0gbm93IC0gdGhpcy5fdDE7XG5cdFx0XHRcdHRoaXMuX3QxICAgICAgICAgICA9IG5vdztcblxuXHRcdFx0XHQvLyBMb2cgc29tZSBzdHVmZiBhYm91dCB0aGUgY2hhbmdlLlxuXHRcdFx0XHRbYGJ5TmFtZS4ke25hbWV9YCwgJ2FsbCddLmZvckVhY2godGFnID0+IHtcblx0XHRcdFx0XHRsb2dnZXIudGltZShgY2hhbmdlLmZyb21Nb3VudC4ke3RhZ31gLCBmcm9tTW91bnQpO1xuXHRcdFx0XHRcdGxvZ2dlci50aW1lKGBjaGFuZ2UuZnJvbUxhc3RDaGFuZ2UuJHt0YWd9YCwgZnJvbUxhc3RDaGFuZ2UpO1xuXHRcdFx0XHRcdGxvZ2dlci5nYXVnZShgY2hhbmdlLmNvdW50LiR7dGFnfWAsIGNvdW50KTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gT2theSwgbm93IHdlJ3ZlIGNvbXBsYWluZWQgYWJvdXQgaXRcblx0XHRcdFx0Ly8gc3VmZmljaWVudGx5LCBsZXQncyBnbyBhaGVhZCBhbmQgdXBkYXRlLlxuXHRcdFx0XHRjb25zdCBuZXdDaGlsZFByb3BzID0gXy5hc3NpZ24oe30sIHRoaXMuc3RhdGUuY2hpbGRQcm9wcywgY2hpbGRQcm9wcyk7XG5cdFx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRcdGNoaWxkUHJvcHM6IG5ld0NoaWxkUHJvcHMsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0Y29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0aWYgKHRoaXMucHJvcHMudW5zdWJzY3JpYmUpIHRoaXMucHJvcHMudW5zdWJzY3JpYmUoKTtcblx0fVxuXG5cdGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG5cdFx0Ly8gSW5jYXNlIHdlIHJlY2VpdmUgbmV3IHByb3BzIHN1Y2ggYXMgZHVyaW5nIGNsaWVudCB0cmFuc2l0aW9uc1xuXHRcdC8vIFdlIHdpbGwgd2FudCB0byB1cGRhdGUgb3VyIHN0YXRlJ3MgY2hpbGRQcm9wIHdpdGggYW55IG5ldyBjaGlsZFByb3BzXG5cdFx0Ly8gdGhhdCBtYXkgaGF2ZSBiZWVuIHBhc3NlZCBpbi4gVGhpcyBzdGlsbCByZXNwZWN0cyBwcm9wcyBhcyB0aGUgdWx0aW1hdGUgc291cmNlIG9mIHRydXRoXG5cdFx0Y29uc3QgbmV3Q2hpbGRQcm9wcyA9IF8uYXNzaWduKHt9LCB0aGlzLnN0YXRlLmNoaWxkUHJvcHMsIG5leHRQcm9wcy5jaGlsZFByb3BzKTtcblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdGNoaWxkUHJvcHM6IG5ld0NoaWxkUHJvcHMsXG5cdFx0fSk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cblx0XHQvLyBXZSdsbCB1c2UgdGhlc2UgdG8gbG9nIHN0dWZmIGFib3V0IHJlLXJlbmRlcnMuXG5cdFx0aWYgKCF0aGlzLl90MCkge1xuXHRcdFx0dGhpcy5fdDAgPSB0aGlzLl90MSA9IG5ldyBEYXRlO1xuXHRcdFx0dGhpcy5fY2hhbmdlQ291bnQgPSAwO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgdGhpcy5wcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycpIHtcblxuXHRcdFx0bG9nZ2VyLmVycm9yKFxuXHRcdFx0XHRcIlJvb3QgZWxlbWVudHMgY2Fubm90IGJlIHJhdyB0ZXh0XCIsXG5cdFx0XHRcdHsgdGV4dDogdGhpcy5wcm9wcy5jaGlsZHJlbiB9XG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBEb24ndCBrZWVwIGNob2tpbmcgb24gaXQuICBKdXN0IGd1dCBpdC5cblx0XHRcdHJldHVybiA8ZGl2IC8+O1xuXHRcdH1cblxuXHRcdHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoXG5cdFx0XHRSZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pLFxuXHRcdFx0dGhpcy5zdGF0ZS5jaGlsZFByb3BzXG5cdFx0KTtcblx0fVxuXG5cdGdldENoaWxkTmFtZSgpIHtcblx0XHRpZiAoIXRoaXMuX2NoaWxkTmFtZSl7XG5cdFx0XHR0aGlzLl9jaGlsZE5hbWUgPSAoUmVhY3QuQ2hpbGRyZW4ub25seShcblx0XHRcdFx0dGhpcy5wcm9wcy5jaGlsZHJlblxuXHRcdFx0KS50eXBlLmRpc3BsYXlOYW1lfHwnVW5rbm93bicpLnNwbGl0KCcuJykucG9wKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jaGlsZE5hbWU7XG5cdH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJvb3RFbGVtZW50O1xuXG5Sb290RWxlbWVudC5wcm9wVHlwZXMgPSB7XG5cdGxpc3RlbjogUHJvcFR5cGVzLmZ1bmMsXG5cdHdoZW46IFByb3BUeXBlcy5vYmplY3QsIC8vIEEgcHJvbWlzZS5cblx0Y2hpbGRQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblx0X2lzUm9vdEVsZW1lbnQ6IFByb3BUeXBlcy5ib29sLFxufVxuXG5Sb290RWxlbWVudC5kZWZhdWx0UHJvcHMgPSB7XG5cdF9pc1Jvb3RFbGVtZW50OiB0cnVlLFxufVxuXG5Sb290RWxlbWVudC5pc1Jvb3RFbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXHRyZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LnByb3BzICYmIGVsZW1lbnQucHJvcHMuX2lzUm9vdEVsZW1lbnQ7XG59XG5cblJvb3RFbGVtZW50LmdldFJvb3RFbGVtZW50QXR0cmlidXRlcyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0dmFyIHByb3BzID0gZWxlbWVudC5wcm9wcztcblx0dmFyIGF0dHJzID0ge307XG5cblx0aWYgKHByb3BzLmNsYXNzTmFtZSkgYXR0cnMuY2xhc3MgPSBwcm9wcy5jbGFzc05hbWU7XG5cblx0Ly8gVE9ETzogT3RoZXJzP1xuXHRbXG5cdFx0J2lkJyxcblx0XHQnc3R5bGUnLFxuXHRdLmZvckVhY2goayA9PiBwcm9wc1trXSAmJiAoYXR0cnNba10gPSBwcm9wc1trXSkpO1xuXG5cdHJldHVybiBhdHRycztcbn1cblxuUm9vdEVsZW1lbnQuZW5zdXJlUm9vdEVsZW1lbnRXaXRoQ29udGFpbmVyID0gZnVuY3Rpb24oZWxlbWVudCwgY29udGFpbmVyKSB7XG5cblx0Ly8gSWYgaXQncyBfYWxyZWFkeV8gYSByb290IGVsZW1lbnQgKG9yIHRoZSBmb2xkKSwgcGFzcyBpdCBhbG9uZy5cblx0aWYgKFJvb3RFbGVtZW50LmlzUm9vdEVsZW1lbnQoZWxlbWVudCkgfHwgaXNUaGVGb2xkKGVsZW1lbnQpIHx8IChcblxuXHRcdC8vIEFsdGVybmF0aXZlbHksIGlmIGl0J3MgYSBjb250cm9sIG9iamVjdCBwYXNzIGl0IGFsb25nLlxuXHRcdC8vXG5cdFx0Ly8gV2UgZXhjbHVkZSBzdHJpbmdzIGhlcmUgc2luY2Ugd2UgYWxyZWFkeSBncmlwZSBhYm91dCB0aGVtXG5cdFx0Ly8gYXQgcmVuZGVyIHRpbWUuXG5cdFx0Ly9cblx0XHQhUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkgJiYgdHlwZW9mIGVsZW1lbnQgIT09ICdzdHJpbmcnXG5cdCkpe1xuXHRcdHJldHVybiBlbGVtZW50O1xuXHR9XG5cblx0Y29uc3Qge2xpc3Rlbiwgd2hlbn0gPSBjb250YWluZXIucHJvcHM7XG5cblx0cmV0dXJuIDxSb290RWxlbWVudCBsaXN0ZW49e2xpc3Rlbn0gd2hlbj17d2hlbn0+e2VsZW1lbnR9PC9Sb290RWxlbWVudD47XG59XG5cblJvb3RFbGVtZW50LmVuc3VyZVJvb3RFbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCl7XG5cdHJldHVybiBSb290RWxlbWVudC5lbnN1cmVSb290RWxlbWVudFdpdGhDb250YWluZXIoZWxlbWVudCwge3Byb3BzOnt9fSk7XG59XG5cblJvb3RFbGVtZW50Lmluc3RhbGxMaXN0ZW5lciA9IGZ1bmN0aW9uKGVsZW1lbnQsIGxpc3Rlbikge1xuXHR2YXIgZGZkID0gUS5kZWZlcigpLFxuXHRcdHVwZGF0ZXIsXG5cdFx0c3Vic2NyaWJlID0gY2FsbGJhY2sgPT4ge3VwZGF0ZXIgPSBjYWxsYmFja30sXG5cdFx0dW5zdWJzY3JpYmUgPSBsaXN0ZW4oY2hpbGRQcm9wcyA9PiB7XG5cdFx0XHQvLyBPbmNlIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQgaXQgd2lsbCBwcm92aWRlIGFuIHVwZGF0ZXIuXG5cdFx0XHQvLyBBZnRlciB0aGF0IHdlIGNhbiBqdXN0IHNob3J0LWNpcmN1aXQgaGVyZSBhbmQgbGV0IGl0IGhhbmRsZVxuXHRcdFx0Ly8gdXBkYXRpbmcgaXRzZWxmLlxuXHRcdFx0aWYgKHVwZGF0ZXIpIHtcblx0XHRcdFx0dXBkYXRlcihjaGlsZFByb3BzKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIHByb21pc2UgaXRzZWxmIHdpbGwgb25seSByZXNvbHZlIG9uY2UsIGJ1dCB3ZSBkb24ndFxuXHRcdFx0Ly8gd2FudCB0byBfY2xvbmVfIG11bHRpcGxlIHRpbWVzLlxuXHRcdFx0ZWxzZSBpZiAoZGZkLnByb21pc2UuaXNQZW5kaW5nKCkpIHtcblx0XHRcdFx0ZGZkLnJlc29sdmUoUmVhY3QuY2xvbmVFbGVtZW50KGVsZW1lbnQsIHtcblx0XHRcdFx0XHRjaGlsZFByb3BzLFxuXHRcdFx0XHRcdHN1YnNjcmliZSxcblx0XHRcdFx0XHR1bnN1YnNjcmliZSxcblx0XHRcdFx0fSkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRyZXR1cm4gZGZkLnByb21pc2Vcbn1cblxuUm9vdEVsZW1lbnQuc2NoZWR1bGVSZW5kZXIgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cdHZhciB7bGlzdGVuLCB3aGVuLCBjb21wb25lbnRMb2FkZXIsIGNoaWxkUHJvcHN9ID0gKGVsZW1lbnR8fHt9KS5wcm9wc3x8e307XG5cdGlmICghKGxpc3Rlbnx8d2hlbnx8Y29tcG9uZW50TG9hZGVyfHxjaGlsZFByb3BzKSkge1xuXHRcdHJldHVybiBRKGVsZW1lbnQpLnRoZW4oUm9vdEVsZW1lbnQuZW5zdXJlUm9vdEVsZW1lbnQpO1xuXHR9XG5cblx0Ly8gVGhpcyBpcyB3aGF0IHdlJ2xsIHVsdGltYXRlbHkgcmVzb2x2ZSBvdXIgcmV0dXJuIHByb21pc2Ugd2l0aC5cblx0Ly8gSXQgbWF5IGJlIGNoYW5nZWQgYnkgdGhlIG91dHB1dCBvZiBgbGlzdGVuYCBvciBgd2hlbmAuXG5cdHZhciByZW5kZXJlZCA9IGVsZW1lbnQ7XG5cdHZhciBjb21wb25lbnRMb2FkZXJEZWZlcnJlZCA9IGNvbXBvbmVudExvYWRlciA/IGNvbXBvbmVudExvYWRlcigpIDogbnVsbDtcblxuXHQvLyBJbnN0YWxsIHRoZSBsaXN0ZW5lciByaWdodCBhd2F5IHRvIHN0YXJ0IGdhdGhlcmluZyBwcm9wcy5cblx0Ly8gSXQgbWF5IGJlIGEgZ2F0ZWQgZW1pdHRlciwgYnV0IHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIHNxdWVlemVcblx0Ly8gcHJvcHMgb3V0IG9mIGl0IGZyb20gdGhlIGJlZ2lubmluZyBpZiBpdCdzIG5vdC5cblx0Ly8gRmluYWxseSBnYXRlIG9uIHRoZSBgd2hlbmAuXG5cdHJldHVybiBRKGxpc3RlbiAmJiBSb290RWxlbWVudC5pbnN0YWxsTGlzdGVuZXIoZWxlbWVudCwgbGlzdGVuKSlcblx0XHQudGhlbihlbCA9PiBlbCAmJiAocmVuZGVyZWQgPSBlbCkpXG5cdFx0LnRoZW4oKCkgPT4gUS5hbGxTZXR0bGVkKFt3aGVuLCBjb21wb25lbnRMb2FkZXJEZWZlcnJlZF0pKVxuXHRcdC50aGVuKHJlc3VsdHMgPT4ge1xuXHRcdFx0dmFyIFt3aGVuUmVzdWx0LCBsb2FkZWRDb21wb25lbnRdID0gcmVzdWx0cztcblx0XHRcdGlmICh3aGVuUmVzdWx0LnZhbHVlIHx8IGxvYWRlZENvbXBvbmVudC52YWx1ZSB8fCBjaGlsZFByb3BzKSB7XG5cdFx0XHRcdC8vIG1lcmdlIGluIGNoaWxkIHByb3BzIGZyb20gbGlzdGVuLCB3aGVuLCBhbmQgY2hpbGRQcm9wc1xuXHRcdFx0XHRjb25zdCBjbG9uZWRDaGlsZFByb3BzID0gXy5hc3NpZ24oe30sIHJlbmRlcmVkLnByb3BzLmNoaWxkUHJvcHMsIHdoZW5SZXN1bHQudmFsdWUsIGNoaWxkUHJvcHMpO1xuXG5cdFx0XHRcdC8vIGlmIHdlIGhhdmUgYSBjb21wb25lbnQgbG9hZGVyIHNwZWNpZmllZCwgY29weSB0aGUgcmVzb2x2ZWQgY29tcG9uZW50XG5cdFx0XHRcdC8vIGFuZCByZW5kZXIgdGhhdCB3aXRoIHRoZSBjdXJyZW50IGNoaWxkIGFzIGEgY2hpbGQgb2YgdGhhdCBjb21wb25lbnRcblx0XHRcdFx0Y29uc3QgY3VycmVudENoaWxkID0gcmVuZGVyZWQucHJvcHMuY2hpbGRyZW47XG5cdFx0XHRcdGNvbnN0IGNoaWxkVG9SZW5kZXIgPSBjb21wb25lbnRMb2FkZXJEZWZlcnJlZCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQobG9hZGVkQ29tcG9uZW50LnZhbHVlLCBudWxsLCBjdXJyZW50Q2hpbGQpIDogY3VycmVudENoaWxkO1xuXG5cdFx0XHRcdHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQocmVuZGVyZWQsIHtjaGlsZFByb3BzOiBjbG9uZWRDaGlsZFByb3BzfSwgY2hpbGRUb1JlbmRlcik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVuZGVyZWQ7XG5cdFx0fSk7XG59XG4iXX0=
