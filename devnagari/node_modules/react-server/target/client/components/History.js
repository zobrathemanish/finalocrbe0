"use strict";

/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
/*global window */

var events = {
	POPSTATE: 'popstate',
	// the constant really should be "pushstate" but the router made it "click". added PUSHSTATE
	// constant to make naming consistent, CLICK for backwards compat
	CLICK: "click",
	PUSHSTATE: "click",
	PAGELOAD: "pageload"
};

/**
 * This only supports pushState for the browsers with native pushState support.
 * For other browsers (mainly IE8 and IE9), it will refresh the page upon pushState()
 * and replaceState().
 * @class History
 * @constructor
 * @param {Object} [options]  The options object
 * @param {Window} [options.win=window]  The window object
 */
function History(options) {
	this.win = options && options.win || window;
	this._hasPushState = !!(this.win && this.win.history && this.win.history.pushState);
}

History.prototype = {
	/**
  * Add the given listener for 'popstate' event (nothing happens for browsers that
  * don't support popstate event).
  * @method on
  * @param {Function} listener
  */
	on: function on(listener) {
		if (this.canClientNavigate()) {
			this.win.addEventListener(History.events.POPSTATE, listener);
		}
	},

	/**
  * Remove the given listener for 'popstate' event (nothing happens for browsers that
  * don't support popstate event).
  * @method off
  * @param {Function} listener
  */
	off: function off(listener) {
		if (this.canClientNavigate()) {
			this.win.removeEventListener(History.events.POPSTATE, listener);
		}
	},

	/**
  * Gets the path string, including the pathname and search query (if it exists).
  * @method getPath
  * @return {String} The path string that denotes current route path
  */
	getPath: function getPath() {
		var location = this.win.location;
		return location.pathname + location.search;
	},

	/**
  * Same as HTML5 pushState API, but with old browser support
  * @method pushState
  * @param {Object} state The state object
  * @param {String} title The title string
  * @param {String} url The new url
  */
	pushState: function pushState(state, title, url) {
		var win = this.win;
		if (this.canClientNavigate()) {
			win.history.pushState(state, title, url);
		} else {
			this.navigationWindow().location.href = url;
		}
	},

	/**
  * Same as HTML5 replaceState API, but with old browser support
  * @method replaceState
  * @param {Object} state The state object
  * @param {String} title The title string
  * @param {String} url The new url
  */
	replaceState: function replaceState(state, title, url) {
		var win = this.win;
		if (this.canClientNavigate()) {
			win.history.replaceState(state, title, url);
		} else if (url !== this.currentUrl()) {

			// On browsers that don't support history navigation, only want to
			// replace state if the URL is actually changing.  Otherwise we're
			// in for a potential infinite refresh loop.
			this.navigationWindow().location.replace(url);
		}
	},

	canClientNavigate: function canClientNavigate() {
		return this._hasPushState;
	},

	navigationWindow: function navigationWindow() {
		return this.win;
	},

	// This is current URL for current window (not navigation window).
	currentUrl: function currentUrl() {
		return location.pathname + location.search;
	}
};

History.events = events;

module.exports = History;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHMvSGlzdG9yeS5qcyJdLCJuYW1lcyI6WyJldmVudHMiLCJQT1BTVEFURSIsIkNMSUNLIiwiUFVTSFNUQVRFIiwiUEFHRUxPQUQiLCJIaXN0b3J5Iiwib3B0aW9ucyIsIndpbiIsIndpbmRvdyIsIl9oYXNQdXNoU3RhdGUiLCJoaXN0b3J5IiwicHVzaFN0YXRlIiwicHJvdG90eXBlIiwib24iLCJsaXN0ZW5lciIsImNhbkNsaWVudE5hdmlnYXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9mZiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJnZXRQYXRoIiwibG9jYXRpb24iLCJwYXRobmFtZSIsInNlYXJjaCIsInN0YXRlIiwidGl0bGUiLCJ1cmwiLCJuYXZpZ2F0aW9uV2luZG93IiwiaHJlZiIsInJlcGxhY2VTdGF0ZSIsImN1cnJlbnRVcmwiLCJyZXBsYWNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7OztBQUlBOztBQUVBLElBQUlBLFNBQVM7QUFDWkMsV0FBVSxVQURFO0FBRVo7QUFDQTtBQUNBQyxRQUFPLE9BSks7QUFLWkMsWUFBVyxPQUxDO0FBTVpDLFdBQVU7QUFORSxDQUFiOztBQVNBOzs7Ozs7Ozs7QUFTQSxTQUFTQyxPQUFULENBQWlCQyxPQUFqQixFQUEwQjtBQUN6QixNQUFLQyxHQUFMLEdBQVlELFdBQVdBLFFBQVFDLEdBQXBCLElBQTRCQyxNQUF2QztBQUNBLE1BQUtDLGFBQUwsR0FBcUIsQ0FBQyxFQUFFLEtBQUtGLEdBQUwsSUFBWSxLQUFLQSxHQUFMLENBQVNHLE9BQXJCLElBQWdDLEtBQUtILEdBQUwsQ0FBU0csT0FBVCxDQUFpQkMsU0FBbkQsQ0FBdEI7QUFDQTs7QUFFRE4sUUFBUU8sU0FBUixHQUFvQjtBQUNuQjs7Ozs7O0FBTUFDLEtBQUksWUFBVUMsUUFBVixFQUFvQjtBQUN2QixNQUFJLEtBQUtDLGlCQUFMLEVBQUosRUFBOEI7QUFDN0IsUUFBS1IsR0FBTCxDQUFTUyxnQkFBVCxDQUEwQlgsUUFBUUwsTUFBUixDQUFlQyxRQUF6QyxFQUFtRGEsUUFBbkQ7QUFDQTtBQUNELEVBWGtCOztBQWFuQjs7Ozs7O0FBTUFHLE1BQUssYUFBVUgsUUFBVixFQUFvQjtBQUN4QixNQUFJLEtBQUtDLGlCQUFMLEVBQUosRUFBOEI7QUFDN0IsUUFBS1IsR0FBTCxDQUFTVyxtQkFBVCxDQUE2QmIsUUFBUUwsTUFBUixDQUFlQyxRQUE1QyxFQUFzRGEsUUFBdEQ7QUFDQTtBQUNELEVBdkJrQjs7QUF5Qm5COzs7OztBQUtBSyxVQUFTLG1CQUFZO0FBQ3BCLE1BQUlDLFdBQVcsS0FBS2IsR0FBTCxDQUFTYSxRQUF4QjtBQUNBLFNBQU9BLFNBQVNDLFFBQVQsR0FBb0JELFNBQVNFLE1BQXBDO0FBQ0EsRUFqQ2tCOztBQW1DbkI7Ozs7Ozs7QUFPQVgsWUFBVyxtQkFBVVksS0FBVixFQUFpQkMsS0FBakIsRUFBd0JDLEdBQXhCLEVBQTZCO0FBQ3ZDLE1BQUlsQixNQUFNLEtBQUtBLEdBQWY7QUFDQSxNQUFJLEtBQUtRLGlCQUFMLEVBQUosRUFBOEI7QUFDN0JSLE9BQUlHLE9BQUosQ0FBWUMsU0FBWixDQUFzQlksS0FBdEIsRUFBNkJDLEtBQTdCLEVBQW9DQyxHQUFwQztBQUNBLEdBRkQsTUFFTztBQUNOLFFBQUtDLGdCQUFMLEdBQXdCTixRQUF4QixDQUFpQ08sSUFBakMsR0FBd0NGLEdBQXhDO0FBQ0E7QUFDRCxFQWpEa0I7O0FBbURuQjs7Ozs7OztBQU9BRyxlQUFjLHNCQUFVTCxLQUFWLEVBQWlCQyxLQUFqQixFQUF3QkMsR0FBeEIsRUFBNkI7QUFDMUMsTUFBSWxCLE1BQU0sS0FBS0EsR0FBZjtBQUNBLE1BQUksS0FBS1EsaUJBQUwsRUFBSixFQUE4QjtBQUM3QlIsT0FBSUcsT0FBSixDQUFZa0IsWUFBWixDQUF5QkwsS0FBekIsRUFBZ0NDLEtBQWhDLEVBQXVDQyxHQUF2QztBQUNBLEdBRkQsTUFFTyxJQUFJQSxRQUFRLEtBQUtJLFVBQUwsRUFBWixFQUErQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0EsUUFBS0gsZ0JBQUwsR0FBd0JOLFFBQXhCLENBQWlDVSxPQUFqQyxDQUF5Q0wsR0FBekM7QUFDQTtBQUNELEVBckVrQjs7QUF1RW5CVixvQkFBbUIsNkJBQVc7QUFDN0IsU0FBTyxLQUFLTixhQUFaO0FBQ0EsRUF6RWtCOztBQTJFbkJpQixtQkFBa0IsNEJBQVc7QUFDNUIsU0FBTyxLQUFLbkIsR0FBWjtBQUNBLEVBN0VrQjs7QUErRW5CO0FBQ0FzQixhQUFZLHNCQUFXO0FBQ3RCLFNBQU9ULFNBQVNDLFFBQVQsR0FBb0JELFNBQVNFLE1BQXBDO0FBQ0E7QUFsRmtCLENBQXBCOztBQXFGQWpCLFFBQVFMLE1BQVIsR0FBaUJBLE1BQWpCOztBQUVBK0IsT0FBT0MsT0FBUCxHQUFpQjNCLE9BQWpCIiwiZmlsZSI6ImNvbXBvbmVudHMvSGlzdG9yeS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbi8qZ2xvYmFsIHdpbmRvdyAqL1xuXG52YXIgZXZlbnRzID0ge1xuXHRQT1BTVEFURTogJ3BvcHN0YXRlJyxcblx0Ly8gdGhlIGNvbnN0YW50IHJlYWxseSBzaG91bGQgYmUgXCJwdXNoc3RhdGVcIiBidXQgdGhlIHJvdXRlciBtYWRlIGl0IFwiY2xpY2tcIi4gYWRkZWQgUFVTSFNUQVRFXG5cdC8vIGNvbnN0YW50IHRvIG1ha2UgbmFtaW5nIGNvbnNpc3RlbnQsIENMSUNLIGZvciBiYWNrd2FyZHMgY29tcGF0XG5cdENMSUNLOiBcImNsaWNrXCIsXG5cdFBVU0hTVEFURTogXCJjbGlja1wiLFxuXHRQQUdFTE9BRDogXCJwYWdlbG9hZFwiLFxufTtcblxuLyoqXG4gKiBUaGlzIG9ubHkgc3VwcG9ydHMgcHVzaFN0YXRlIGZvciB0aGUgYnJvd3NlcnMgd2l0aCBuYXRpdmUgcHVzaFN0YXRlIHN1cHBvcnQuXG4gKiBGb3Igb3RoZXIgYnJvd3NlcnMgKG1haW5seSBJRTggYW5kIElFOSksIGl0IHdpbGwgcmVmcmVzaCB0aGUgcGFnZSB1cG9uIHB1c2hTdGF0ZSgpXG4gKiBhbmQgcmVwbGFjZVN0YXRlKCkuXG4gKiBAY2xhc3MgSGlzdG9yeVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBUaGUgb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7V2luZG93fSBbb3B0aW9ucy53aW49d2luZG93XSAgVGhlIHdpbmRvdyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gSGlzdG9yeShvcHRpb25zKSB7XG5cdHRoaXMud2luID0gKG9wdGlvbnMgJiYgb3B0aW9ucy53aW4pIHx8IHdpbmRvdztcblx0dGhpcy5faGFzUHVzaFN0YXRlID0gISEodGhpcy53aW4gJiYgdGhpcy53aW4uaGlzdG9yeSAmJiB0aGlzLndpbi5oaXN0b3J5LnB1c2hTdGF0ZSk7XG59XG5cbkhpc3RvcnkucHJvdG90eXBlID0ge1xuXHQvKipcblx0ICogQWRkIHRoZSBnaXZlbiBsaXN0ZW5lciBmb3IgJ3BvcHN0YXRlJyBldmVudCAobm90aGluZyBoYXBwZW5zIGZvciBicm93c2VycyB0aGF0XG5cdCAqIGRvbid0IHN1cHBvcnQgcG9wc3RhdGUgZXZlbnQpLlxuXHQgKiBAbWV0aG9kIG9uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG5cdCAqL1xuXHRvbjogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG5cdFx0aWYgKHRoaXMuY2FuQ2xpZW50TmF2aWdhdGUoKSkge1xuXHRcdFx0dGhpcy53aW4uYWRkRXZlbnRMaXN0ZW5lcihIaXN0b3J5LmV2ZW50cy5QT1BTVEFURSwgbGlzdGVuZXIpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlIHRoZSBnaXZlbiBsaXN0ZW5lciBmb3IgJ3BvcHN0YXRlJyBldmVudCAobm90aGluZyBoYXBwZW5zIGZvciBicm93c2VycyB0aGF0XG5cdCAqIGRvbid0IHN1cHBvcnQgcG9wc3RhdGUgZXZlbnQpLlxuXHQgKiBAbWV0aG9kIG9mZlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuXHQgKi9cblx0b2ZmOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcblx0XHRpZiAodGhpcy5jYW5DbGllbnROYXZpZ2F0ZSgpKSB7XG5cdFx0XHR0aGlzLndpbi5yZW1vdmVFdmVudExpc3RlbmVyKEhpc3RvcnkuZXZlbnRzLlBPUFNUQVRFLCBsaXN0ZW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwYXRoIHN0cmluZywgaW5jbHVkaW5nIHRoZSBwYXRobmFtZSBhbmQgc2VhcmNoIHF1ZXJ5IChpZiBpdCBleGlzdHMpLlxuXHQgKiBAbWV0aG9kIGdldFBhdGhcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgcGF0aCBzdHJpbmcgdGhhdCBkZW5vdGVzIGN1cnJlbnQgcm91dGUgcGF0aFxuXHQgKi9cblx0Z2V0UGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsb2NhdGlvbiA9IHRoaXMud2luLmxvY2F0aW9uO1xuXHRcdHJldHVybiBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaDtcblx0fSxcblxuXHQvKipcblx0ICogU2FtZSBhcyBIVE1MNSBwdXNoU3RhdGUgQVBJLCBidXQgd2l0aCBvbGQgYnJvd3NlciBzdXBwb3J0XG5cdCAqIEBtZXRob2QgcHVzaFN0YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBUaGUgc3RhdGUgb2JqZWN0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0aXRsZSBUaGUgdGl0bGUgc3RyaW5nXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIG5ldyB1cmxcblx0ICovXG5cdHB1c2hTdGF0ZTogZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgdXJsKSB7XG5cdFx0dmFyIHdpbiA9IHRoaXMud2luO1xuXHRcdGlmICh0aGlzLmNhbkNsaWVudE5hdmlnYXRlKCkpIHtcblx0XHRcdHdpbi5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubmF2aWdhdGlvbldpbmRvdygpLmxvY2F0aW9uLmhyZWYgPSB1cmw7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTYW1lIGFzIEhUTUw1IHJlcGxhY2VTdGF0ZSBBUEksIGJ1dCB3aXRoIG9sZCBicm93c2VyIHN1cHBvcnRcblx0ICogQG1ldGhvZCByZXBsYWNlU3RhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIFRoZSBzdGF0ZSBvYmplY3Rcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlIFRoZSB0aXRsZSBzdHJpbmdcblx0ICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgbmV3IHVybFxuXHQgKi9cblx0cmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwpIHtcblx0XHR2YXIgd2luID0gdGhpcy53aW47XG5cdFx0aWYgKHRoaXMuY2FuQ2xpZW50TmF2aWdhdGUoKSkge1xuXHRcdFx0d2luLmhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsKTtcblx0XHR9IGVsc2UgaWYgKHVybCAhPT0gdGhpcy5jdXJyZW50VXJsKCkpIHtcblxuXHRcdFx0Ly8gT24gYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGhpc3RvcnkgbmF2aWdhdGlvbiwgb25seSB3YW50IHRvXG5cdFx0XHQvLyByZXBsYWNlIHN0YXRlIGlmIHRoZSBVUkwgaXMgYWN0dWFsbHkgY2hhbmdpbmcuICBPdGhlcndpc2Ugd2UncmVcblx0XHRcdC8vIGluIGZvciBhIHBvdGVudGlhbCBpbmZpbml0ZSByZWZyZXNoIGxvb3AuXG5cdFx0XHR0aGlzLm5hdmlnYXRpb25XaW5kb3coKS5sb2NhdGlvbi5yZXBsYWNlKHVybCk7XG5cdFx0fVxuXHR9LFxuXG5cdGNhbkNsaWVudE5hdmlnYXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faGFzUHVzaFN0YXRlO1xuXHR9LFxuXG5cdG5hdmlnYXRpb25XaW5kb3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLndpbjtcblx0fSxcblxuXHQvLyBUaGlzIGlzIGN1cnJlbnQgVVJMIGZvciBjdXJyZW50IHdpbmRvdyAobm90IG5hdmlnYXRpb24gd2luZG93KS5cblx0Y3VycmVudFVybDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoO1xuXHR9LFxufTtcblxuSGlzdG9yeS5ldmVudHMgPSBldmVudHM7XG5cbm1vZHVsZS5leHBvcnRzID0gSGlzdG9yeTtcbiJdfQ==
