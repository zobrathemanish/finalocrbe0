'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EventEmitter = require('events').EventEmitter,
    logger = require('../logging').getLogger({ "name": "react-server.core.context.Navigator", "color": { "server": 85, "client": "rgb(42,212,127)" } }),
    Router = require('routr'),
    Q = require('q'),
    History = require("../components/History"),
    ReactServerAgent = require("../ReactServerAgent"),
    PageUtil = require("../util/PageUtil"),
    DebugUtil = require("../util/DebugUtil"),
    _ref = true ? require('../logging/response') : { setResponseLoggerPage: function setResponseLoggerPage() {} },
    setResponseLoggerPage = _ref.setResponseLoggerPage;

var Navigator = function (_EventEmitter) {
	_inherits(Navigator, _EventEmitter);

	function Navigator(context, routes) {
		_classCallCheck(this, Navigator);

		var _this = _possibleConstructorReturn(this, (Navigator.__proto__ || Object.getPrototypeOf(Navigator)).call(this));

		_this.router = new Router(routes.routes);
		_this.context = context;

		_this._globalMiddleware = routes.middleware;
		_this._loading = false;
		_this._currentRoute = null;
		_this._nextRoute = null;
		return _this;
	}

	/**
  * type is one of
  *    History.events.PUSHSTATE: user clicked something to go forward but browser didn't do a
  * full page load
  *    History.events.POPSTATE: user clicked back button but browser didn't do a full page load
  *    History.events.PAGELOAD: full browser page load, not using History API.
  *
  * Default is History.events.PAGELOAD.
  */


	_createClass(Navigator, [{
		key: 'navigate',
		value: function navigate(request, type) {
			var _this2 = this;

			logger.debug('Navigating to ' + request.getUrl());
			type = type || History.events.PAGELOAD;

			this._haveInitialized = true;

			// Pull debug parameters out of the query string and expose via a well
			// defined interface.
			DebugUtil.setRequest(request);

			var route = this.router.getRoute(request.getUrl(), { method: request.getMethod() });

			if (route) {
				logger.debug('Mapped ' + request.getUrl() + ' to route ' + route.name);
			} else {
				this.emit('navigateDone', { status: 404, message: "No Route!" }, null, request.getUrl(), type);
				return;
			}

			// We may or may not _actually_ start this route client side.
			//
			// If there's a flurry of navigation we skip any routes that
			// blow by while we're still working on a page, and only
			// finally start the _last_ one.
			//
			// The promise returned from `startRoute()` will be rejected
			// if we're not going to proceed, so resources will be freed.
			//
			this.startRoute(route, request, type)

			// We might have a data bundle on hand, or the request may
			// have asked us to fetch it one.
			.then(this._dealWithDataBundleLoading.bind(this, request)).then(function () {
				if (_this2._ignoreCurrentNavigation) {
					// This is a one-time deal.
					_this2._ignoreCurrentNavigation = false;
					return;
				}

				/* Breathe... */

				var loaders = route.config.page;

				var deviceType = _this2.context.getDeviceType();

				if (loaders[deviceType]) {
					route.name += "-" + deviceType;
				}

				// Our route may have multiple page implementations if
				// there are device-specific variations.
				//
				// We'll take one of those if the request device
				// matches, otherwise we'll use the default.
				//
				// Note that the page object may either directly be a
				// loader or it may be an object whose values are
				// loaders.
				(loaders[deviceType] || loaders.default || loaders)().done(function (pageConstructor) {
					if (request.setRoute) {
						request.setRoute(route);
					}
					_this2.handlePage(pageConstructor, request, type);
				}, function (err) {
					console.error("Error resolving page", err);
				});
			});
		}

		// If you call this you're responsible for calling `finishRoute()`
		// when you're done with whatever it is you're hiding from the
		// navigator.

	}, {
		key: 'ignoreCurrentNavigation',
		value: function ignoreCurrentNavigation() {
			this._ignoreCurrentNavigation = true;
		}
	}, {
		key: '_dealWithDataBundleLoading',
		value: function _dealWithDataBundleLoading(request) {

			// If we're managing a frame's navigation, we want _it_ to
			// use a data bundle.
			if (this._ignoreCurrentNavigation) return Q();

			// If this request doesn't use a data bundle, we're done.
			if (!request.getBundleData()) return Q();

			// If the request wants all of the data fetched as a bundle
			// we'll need to kick off the request for the bundle.
			return ReactServerAgent._fetchDataBundle(request.getUrl()).then(ReactServerAgent._rehydrateDataBundle).catch(function (err) {
				return logger.error('Data bundle error', err);
			});
		}
	}, {
		key: 'handlePage',
		value: function handlePage(pageConstructor, request, type) {
			var _this3 = this;

			// instantiate the pages we need to fulfill this request.
			var pageClasses = [];

			this._addPageMiddlewareToArray(this._globalMiddleware, pageClasses);
			this._addPageMiddlewareToArray([pageConstructor], pageClasses);

			var pages = pageClasses.map(function (pageClass) {
				if (Object.getOwnPropertyNames(pageClass).length === 0) {
					throw new Error("Tried to instantiate a page or middleware class that was an empty object. Did you forget to assign a class to module.exports?");
				}
				return new pageClass();
			});
			var page = PageUtil.createPageChain(pages);

			this.emit("page", page);

			page.setRequest(request);

			PageUtil.PageConfig.initFromPageWithDefaults(page, {
				isFragment: false,
				isRawResponse: false
			});

			// Set the page context on the response logger so it can figure
			// out whether to flush logs to the response document
			setResponseLoggerPage(page);

			// call page.handleRoute(), and use the resulting code to decide how to
			// respond.
			// We call it in a promise handler so any exception that
			// arises will get converted to a rejection that we can handle
			// below.
			Q().then(page.handleRoute).then(function (handleRouteResult) {

				page.setStatus(handleRouteResult.code);

				page.setHasDocument(handleRouteResult.hasDocument);

				page.setJsBelowTheFold(DebugUtil.getJsBelowTheFold() || handleRouteResult.jsBelowTheFold);
				page.setSplitJsLoad(DebugUtil.getSplitJsLoad() || handleRouteResult.splitJsLoad);

				// TODO: I think that 3xx/4xx/5xx shouldn't be considered "errors" in navigateDone, but that's
				// how the code is structured right now, and I'm changing too many things at once at the moment. -sra.
				if (handleRouteResult.code && (handleRouteResult.code / 100 | 0) !== 2) {
					_this3.emit("navigateDone", { status: handleRouteResult.code, redirectUrl: handleRouteResult.location }, page, request.getUrl(), type);
					return;
				}
				if (handleRouteResult.page) {
					// in this case, we should forward to a new page *without* changing the URL. Since we are already
					// in an async callback, we should schedule a new handlePage with the new page constructor and return
					// from this call.
					setTimeout(function () {
						return _this3.handlePage(handleRouteResult.page, request, type);
					}, 0);
					return;
				}

				_this3.emit('navigateDone', null, page, request.getUrl(), type);
			}).catch(function (err) {
				logger.error("Error while handling route", err);

				_this3.emit('navigateDone', { status: 500 }, page, request.getUrl(), type);
			});
		}

		/**
   * recursively adds the middleware in the pages array to array.
   */

	}, {
		key: '_addPageMiddlewareToArray',
		value: function _addPageMiddlewareToArray(pages, array) {
			var _this4 = this;

			if (!pages) return;
			pages.forEach(function (page) {
				if (page.middleware) {
					_this4._addPageMiddlewareToArray(page.middleware(), array);
				}
				array.push(page);
			});
		}
	}, {
		key: 'getState',
		value: function getState() {
			return {
				loading: this._loading,
				route: this._currentRoute
			};
		}
	}, {
		key: 'getCurrentRoute',
		value: function getCurrentRoute() {
			return this._currentRoute;
		}
	}, {
		key: 'getLoading',
		value: function getLoading() {
			return this._loading;
		}
	}, {
		key: 'startRoute',
		value: function startRoute(route, request, type) {

			// If we're being called with a requested route, we'll need to
			// tell the caller when they can proceed with their
			// navigation.
			var dfd, promise;

			// We need to handle the case where routes are requested while
			// we're handling the previous navigation.  This can happen if
			// the user furiously clicks the browser's forward/back
			// navigation buttons.
			//
			// We don't want a _queue_ here, because we're only ultimately
			// going to show the user the _final_ route that's requested,
			// so we'll just keep a single reference to the next route we
			// need to actually render once our current navigation is
			// complete.
			//
			if (request) {

				// We don't want to leave navigation detritus
				// laying around as we discard bypassed pages.
				if (this._nextRoute) this._nextRoute.dfd.reject();

				dfd = Q.defer(), promise = dfd.promise;

				this._nextRoute = { route: route, request: request, type: type, dfd: dfd };
			}

			// If we're _currently_ navigating, we'll wait to start the
			// next route until this navigation is complete.  Interleaved
			// navigation causes all kinds of havoc.
			if (!this._loading && this._nextRoute) {
				var _nextRoute = this._nextRoute,
				    _route = _nextRoute.route,
				    _request = _nextRoute.request,
				    _type = _nextRoute.type,
				    _dfd = _nextRoute.dfd;


				this._loading = true;
				this._currentRoute = _route;
				this._nextRoute = null;

				this.emit('navigateStart', { route: _route, request: _request, type: _type });

				// This allows the actual navigation to
				// proceed.
				_dfd.resolve();
			}

			return promise;
		}
	}, {
		key: 'finishRoute',
		value: function finishRoute() {
			this._loading = false;

			this.emit('loadComplete');

			// If other routes were queued while we were navigating, we'll
			// start the next one right off.
			//
			this.startRoute();
		}
	}]);

	return Navigator;
}(EventEmitter);

module.exports = Navigator;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbnRleHQvTmF2aWdhdG9yLmpzIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJFdmVudEVtaXR0ZXIiLCJsb2dnZXIiLCJnZXRMb2dnZXIiLCJSb3V0ZXIiLCJRIiwiSGlzdG9yeSIsIlJlYWN0U2VydmVyQWdlbnQiLCJQYWdlVXRpbCIsIkRlYnVnVXRpbCIsInNldFJlc3BvbnNlTG9nZ2VyUGFnZSIsIk5hdmlnYXRvciIsImNvbnRleHQiLCJyb3V0ZXMiLCJyb3V0ZXIiLCJfZ2xvYmFsTWlkZGxld2FyZSIsIm1pZGRsZXdhcmUiLCJfbG9hZGluZyIsIl9jdXJyZW50Um91dGUiLCJfbmV4dFJvdXRlIiwicmVxdWVzdCIsInR5cGUiLCJkZWJ1ZyIsImdldFVybCIsImV2ZW50cyIsIlBBR0VMT0FEIiwiX2hhdmVJbml0aWFsaXplZCIsInNldFJlcXVlc3QiLCJyb3V0ZSIsImdldFJvdXRlIiwibWV0aG9kIiwiZ2V0TWV0aG9kIiwibmFtZSIsImVtaXQiLCJzdGF0dXMiLCJtZXNzYWdlIiwic3RhcnRSb3V0ZSIsInRoZW4iLCJfZGVhbFdpdGhEYXRhQnVuZGxlTG9hZGluZyIsImJpbmQiLCJfaWdub3JlQ3VycmVudE5hdmlnYXRpb24iLCJsb2FkZXJzIiwiY29uZmlnIiwicGFnZSIsImRldmljZVR5cGUiLCJnZXREZXZpY2VUeXBlIiwiZGVmYXVsdCIsImRvbmUiLCJzZXRSb3V0ZSIsImhhbmRsZVBhZ2UiLCJwYWdlQ29uc3RydWN0b3IiLCJjb25zb2xlIiwiZXJyb3IiLCJlcnIiLCJnZXRCdW5kbGVEYXRhIiwiX2ZldGNoRGF0YUJ1bmRsZSIsIl9yZWh5ZHJhdGVEYXRhQnVuZGxlIiwiY2F0Y2giLCJwYWdlQ2xhc3NlcyIsIl9hZGRQYWdlTWlkZGxld2FyZVRvQXJyYXkiLCJwYWdlcyIsIm1hcCIsInBhZ2VDbGFzcyIsIk9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJsZW5ndGgiLCJFcnJvciIsImNyZWF0ZVBhZ2VDaGFpbiIsIlBhZ2VDb25maWciLCJpbml0RnJvbVBhZ2VXaXRoRGVmYXVsdHMiLCJpc0ZyYWdtZW50IiwiaXNSYXdSZXNwb25zZSIsImhhbmRsZVJvdXRlIiwic2V0U3RhdHVzIiwiaGFuZGxlUm91dGVSZXN1bHQiLCJjb2RlIiwic2V0SGFzRG9jdW1lbnQiLCJoYXNEb2N1bWVudCIsInNldEpzQmVsb3dUaGVGb2xkIiwiZ2V0SnNCZWxvd1RoZUZvbGQiLCJqc0JlbG93VGhlRm9sZCIsInNldFNwbGl0SnNMb2FkIiwiZ2V0U3BsaXRKc0xvYWQiLCJzcGxpdEpzTG9hZCIsInJlZGlyZWN0VXJsIiwibG9jYXRpb24iLCJzZXRUaW1lb3V0IiwiYXJyYXkiLCJmb3JFYWNoIiwicHVzaCIsImxvYWRpbmciLCJkZmQiLCJwcm9taXNlIiwicmVqZWN0IiwiZGVmZXIiLCJyZXNvbHZlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNJLG1CQUFlQSxRQUFRLFFBQVIsRUFBa0JDLFlBQWpDO0FBQUEsSUFDSEMsTUFERyxHQUNNRixRQUFRLFlBQVIsRUFBc0JHLFNBQXRCLENBQWdDLEVBQUMsUUFBTyxxQ0FBUixFQUE4QyxTQUFRLEVBQUMsVUFBUyxFQUFWLEVBQWEsVUFBUyxpQkFBdEIsRUFBdEQsRUFBaEMsQ0FETjtBQUFBLElBRUhDLE1BRkcsR0FFTUosUUFBUSxPQUFSLENBRk47QUFBQSxJQUdISyxDQUhHLEdBR0NMLFFBQVEsR0FBUixDQUhEO0FBQUEsSUFJSE0sT0FKRyxHQUlPTixRQUFRLHVCQUFSLENBSlA7QUFBQSxJQUtITyxnQkFMRyxHQUtnQlAsUUFBUSxxQkFBUixDQUxoQjtBQUFBLElBTUhRLFFBTkcsR0FNUVIsUUFBUSxrQkFBUixDQU5SO0FBQUEsSUFPSFMsU0FQRyxHQU9TVCxRQUFRLG1CQUFSLENBUFQ7QUFBQSxXQVF1QixPQUFPQSxRQUFRLHFCQUFSLENBQVAsR0FBd0MsRUFBRVUsdUJBQXVCLGlDQUFNLENBQUUsQ0FBakMsRUFSL0Q7QUFBQSxJQVFGQSxxQkFSRSxRQVFGQSxxQkFSRTs7SUFV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LGNBRTlCQSxLQUY4QjtBQUFBLFFBRXZCUixRQUZ1QixjQUV2QkEsT0FGdUI7QUFBQSxRQUVkQyxLQUZjLGNBRWRBLElBRmM7QUFBQSxRQUVSc0UsSUFGUSxjQUVSQSxHQUZROzs7QUFJckMsU0FBSzFFLFFBQUwsR0FBcUIsSUFBckI7QUFDQSxTQUFLQyxhQUFMLEdBQXFCVSxNQUFyQjtBQUNBLFNBQUtULFVBQUwsR0FBcUIsSUFBckI7O0FBRUEsU0FBS2MsSUFBTCxDQUFVLGVBQVYsRUFBMkIsRUFBQ0wsYUFBRCxFQUFRUixpQkFBUixFQUFpQkMsV0FBakIsRUFBM0I7O0FBRUE7QUFDQTtBQUNBc0UsU0FBSUksT0FBSjtBQUNBOztBQUVELFVBQU9ILE9BQVA7QUFDQTs7O2dDQUVjO0FBQ2QsUUFBSzNFLFFBQUwsR0FBZ0IsS0FBaEI7O0FBRUEsUUFBS2dCLElBQUwsQ0FBVSxjQUFWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQUtHLFVBQUw7QUFDQTs7OztFQXRSc0JuQyxZOztBQXlSeEIrRixPQUFPQyxPQUFQLEdBQWlCdEYsU0FBakIiLCJmaWxlIjoiY29udGV4dC9OYXZpZ2F0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXIsXG5cdGxvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dpbmcnKS5nZXRMb2dnZXIoe1wibmFtZVwiOlwicmVhY3Qtc2VydmVyLmNvcmUuY29udGV4dC5OYXZpZ2F0b3JcIixcImNvbG9yXCI6e1wic2VydmVyXCI6ODUsXCJjbGllbnRcIjpcInJnYig0MiwyMTIsMTI3KVwifX0pLFxuXHRSb3V0ZXIgPSByZXF1aXJlKCdyb3V0cicpLFxuXHRRID0gcmVxdWlyZSgncScpLFxuXHRIaXN0b3J5ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvSGlzdG9yeVwiKSxcblx0UmVhY3RTZXJ2ZXJBZ2VudCA9IHJlcXVpcmUoXCIuLi9SZWFjdFNlcnZlckFnZW50XCIpLFxuXHRQYWdlVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL1BhZ2VVdGlsXCIpLFxuXHREZWJ1Z1V0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9EZWJ1Z1V0aWxcIiksXG5cdHtzZXRSZXNwb25zZUxvZ2dlclBhZ2V9ID0gdHJ1ZSA/IHJlcXVpcmUoJy4uL2xvZ2dpbmcvcmVzcG9uc2UnKSA6IHsgc2V0UmVzcG9uc2VMb2dnZXJQYWdlOiAoKSA9PiB7fSB9O1xuXG5jbGFzcyBOYXZpZ2F0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG5cdGNvbnN0cnVjdG9yIChjb250ZXh0LCByb3V0ZXMpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5yb3V0ZXIgPSBuZXcgUm91dGVyKHJvdXRlcy5yb3V0ZXMpO1xuXHRcdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cblx0XHR0aGlzLl9nbG9iYWxNaWRkbGV3YXJlID0gcm91dGVzLm1pZGRsZXdhcmU7XG5cdFx0dGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuXHRcdHRoaXMuX2N1cnJlbnRSb3V0ZSA9IG51bGw7XG5cdFx0dGhpcy5fbmV4dFJvdXRlID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiB0eXBlIGlzIG9uZSBvZlxuXHQgKiAgICBIaXN0b3J5LmV2ZW50cy5QVVNIU1RBVEU6IHVzZXIgY2xpY2tlZCBzb21ldGhpbmcgdG8gZ28gZm9yd2FyZCBidXQgYnJvd3NlciBkaWRuJ3QgZG8gYVxuXHQgKiBmdWxsIHBhZ2UgbG9hZFxuXHQgKiAgICBIaXN0b3J5LmV2ZW50cy5QT1BTVEFURTogdXNlciBjbGlja2VkIGJhY2sgYnV0dG9uIGJ1dCBicm93c2VyIGRpZG4ndCBkbyBhIGZ1bGwgcGFnZSBsb2FkXG5cdCAqICAgIEhpc3RvcnkuZXZlbnRzLlBBR0VMT0FEOiBmdWxsIGJyb3dzZXIgcGFnZSBsb2FkLCBub3QgdXNpbmcgSGlzdG9yeSBBUEkuXG5cdCAqXG5cdCAqIERlZmF1bHQgaXMgSGlzdG9yeS5ldmVudHMuUEFHRUxPQUQuXG5cdCAqL1xuXHRuYXZpZ2F0ZSAocmVxdWVzdCwgdHlwZSkge1xuXG5cdFx0bG9nZ2VyLmRlYnVnKGBOYXZpZ2F0aW5nIHRvICR7cmVxdWVzdC5nZXRVcmwoKX1gKTtcblx0XHR0eXBlID0gdHlwZSB8fCBIaXN0b3J5LmV2ZW50cy5QQUdFTE9BRDtcblxuXHRcdHRoaXMuX2hhdmVJbml0aWFsaXplZCA9IHRydWU7XG5cblx0XHQvLyBQdWxsIGRlYnVnIHBhcmFtZXRlcnMgb3V0IG9mIHRoZSBxdWVyeSBzdHJpbmcgYW5kIGV4cG9zZSB2aWEgYSB3ZWxsXG5cdFx0Ly8gZGVmaW5lZCBpbnRlcmZhY2UuXG5cdFx0RGVidWdVdGlsLnNldFJlcXVlc3QocmVxdWVzdCk7XG5cblx0XHR2YXIgcm91dGUgPSB0aGlzLnJvdXRlci5nZXRSb3V0ZShyZXF1ZXN0LmdldFVybCgpLCB7IG1ldGhvZDogcmVxdWVzdC5nZXRNZXRob2QoKSB9KTtcblxuXHRcdGlmIChyb3V0ZSkge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKGBNYXBwZWQgJHtyZXF1ZXN0LmdldFVybCgpfSB0byByb3V0ZSAke3JvdXRlLm5hbWV9YCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZW1pdCgnbmF2aWdhdGVEb25lJywgeyBzdGF0dXM6IDQwNCwgbWVzc2FnZTogXCJObyBSb3V0ZSFcIiB9LCBudWxsLCByZXF1ZXN0LmdldFVybCgpLCB0eXBlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBXZSBtYXkgb3IgbWF5IG5vdCBfYWN0dWFsbHlfIHN0YXJ0IHRoaXMgcm91dGUgY2xpZW50IHNpZGUuXG5cdFx0Ly9cblx0XHQvLyBJZiB0aGVyZSdzIGEgZmx1cnJ5IG9mIG5hdmlnYXRpb24gd2Ugc2tpcCBhbnkgcm91dGVzIHRoYXRcblx0XHQvLyBibG93IGJ5IHdoaWxlIHdlJ3JlIHN0aWxsIHdvcmtpbmcgb24gYSBwYWdlLCBhbmQgb25seVxuXHRcdC8vIGZpbmFsbHkgc3RhcnQgdGhlIF9sYXN0XyBvbmUuXG5cdFx0Ly9cblx0XHQvLyBUaGUgcHJvbWlzZSByZXR1cm5lZCBmcm9tIGBzdGFydFJvdXRlKClgIHdpbGwgYmUgcmVqZWN0ZWRcblx0XHQvLyBpZiB3ZSdyZSBub3QgZ29pbmcgdG8gcHJvY2VlZCwgc28gcmVzb3VyY2VzIHdpbGwgYmUgZnJlZWQuXG5cdFx0Ly9cblx0XHR0aGlzXG5cdFx0LnN0YXJ0Um91dGUocm91dGUsIHJlcXVlc3QsIHR5cGUpXG5cblx0XHQvLyBXZSBtaWdodCBoYXZlIGEgZGF0YSBidW5kbGUgb24gaGFuZCwgb3IgdGhlIHJlcXVlc3QgbWF5XG5cdFx0Ly8gaGF2ZSBhc2tlZCB1cyB0byBmZXRjaCBpdCBvbmUuXG5cdFx0LnRoZW4odGhpcy5fZGVhbFdpdGhEYXRhQnVuZGxlTG9hZGluZy5iaW5kKHRoaXMsIHJlcXVlc3QpKVxuXG5cdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0aWYgKHRoaXMuX2lnbm9yZUN1cnJlbnROYXZpZ2F0aW9uKXtcblx0XHRcdFx0Ly8gVGhpcyBpcyBhIG9uZS10aW1lIGRlYWwuXG5cdFx0XHRcdHRoaXMuX2lnbm9yZUN1cnJlbnROYXZpZ2F0aW9uID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0LyogQnJlYXRoZS4uLiAqL1xuXG5cdFx0XHR2YXIgbG9hZGVycyA9IHJvdXRlLmNvbmZpZy5wYWdlO1xuXG5cdFx0XHR2YXIgZGV2aWNlVHlwZSA9IHRoaXMuY29udGV4dC5nZXREZXZpY2VUeXBlKCk7XG5cblx0XHRcdGlmIChsb2FkZXJzW2RldmljZVR5cGVdKSB7XG5cdFx0XHRcdHJvdXRlLm5hbWUgKz0gXCItXCIgKyBkZXZpY2VUeXBlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdXIgcm91dGUgbWF5IGhhdmUgbXVsdGlwbGUgcGFnZSBpbXBsZW1lbnRhdGlvbnMgaWZcblx0XHRcdC8vIHRoZXJlIGFyZSBkZXZpY2Utc3BlY2lmaWMgdmFyaWF0aW9ucy5cblx0XHRcdC8vXG5cdFx0XHQvLyBXZSdsbCB0YWtlIG9uZSBvZiB0aG9zZSBpZiB0aGUgcmVxdWVzdCBkZXZpY2Vcblx0XHRcdC8vIG1hdGNoZXMsIG90aGVyd2lzZSB3ZSdsbCB1c2UgdGhlIGRlZmF1bHQuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gTm90ZSB0aGF0IHRoZSBwYWdlIG9iamVjdCBtYXkgZWl0aGVyIGRpcmVjdGx5IGJlIGFcblx0XHRcdC8vIGxvYWRlciBvciBpdCBtYXkgYmUgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmVcblx0XHRcdC8vIGxvYWRlcnMuXG5cdFx0XHQoXG5cdFx0XHRcdGxvYWRlcnNbZGV2aWNlVHlwZV0gfHxcblx0XHRcdFx0bG9hZGVycy5kZWZhdWx0IHx8XG5cdFx0XHRcdGxvYWRlcnNcblx0XHRcdCkoKS5kb25lKHBhZ2VDb25zdHJ1Y3RvciA9PiB7XG5cdFx0XHRcdGlmIChyZXF1ZXN0LnNldFJvdXRlKSB7XG5cdFx0XHRcdFx0cmVxdWVzdC5zZXRSb3V0ZShyb3V0ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5oYW5kbGVQYWdlKHBhZ2VDb25zdHJ1Y3RvciwgcmVxdWVzdCwgdHlwZSk7XG5cblx0XHRcdH0sIGVyciA9PiB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZXNvbHZpbmcgcGFnZVwiLCBlcnIpO1xuXHRcdFx0fSk7XG5cblx0XHR9KTtcblxuXHR9XG5cblx0Ly8gSWYgeW91IGNhbGwgdGhpcyB5b3UncmUgcmVzcG9uc2libGUgZm9yIGNhbGxpbmcgYGZpbmlzaFJvdXRlKClgXG5cdC8vIHdoZW4geW91J3JlIGRvbmUgd2l0aCB3aGF0ZXZlciBpdCBpcyB5b3UncmUgaGlkaW5nIGZyb20gdGhlXG5cdC8vIG5hdmlnYXRvci5cblx0aWdub3JlQ3VycmVudE5hdmlnYXRpb24oKSB7XG5cdFx0dGhpcy5faWdub3JlQ3VycmVudE5hdmlnYXRpb24gPSB0cnVlO1xuXHR9XG5cblx0X2RlYWxXaXRoRGF0YUJ1bmRsZUxvYWRpbmcocmVxdWVzdCkge1xuXG5cdFx0Ly8gSWYgd2UncmUgbWFuYWdpbmcgYSBmcmFtZSdzIG5hdmlnYXRpb24sIHdlIHdhbnQgX2l0XyB0b1xuXHRcdC8vIHVzZSBhIGRhdGEgYnVuZGxlLlxuXHRcdGlmICh0aGlzLl9pZ25vcmVDdXJyZW50TmF2aWdhdGlvbikgcmV0dXJuIFEoKTtcblxuXHRcdC8vIElmIHRoaXMgcmVxdWVzdCBkb2Vzbid0IHVzZSBhIGRhdGEgYnVuZGxlLCB3ZSdyZSBkb25lLlxuXHRcdGlmICghcmVxdWVzdC5nZXRCdW5kbGVEYXRhKCkpIHJldHVybiBRKCk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCB3YW50cyBhbGwgb2YgdGhlIGRhdGEgZmV0Y2hlZCBhcyBhIGJ1bmRsZVxuXHRcdC8vIHdlJ2xsIG5lZWQgdG8ga2ljayBvZmYgdGhlIHJlcXVlc3QgZm9yIHRoZSBidW5kbGUuXG5cdFx0cmV0dXJuIFJlYWN0U2VydmVyQWdlbnQuX2ZldGNoRGF0YUJ1bmRsZShyZXF1ZXN0LmdldFVybCgpKVxuXHRcdFx0LnRoZW4oUmVhY3RTZXJ2ZXJBZ2VudC5fcmVoeWRyYXRlRGF0YUJ1bmRsZSlcblx0XHRcdC5jYXRjaChlcnIgPT4gbG9nZ2VyLmVycm9yKCdEYXRhIGJ1bmRsZSBlcnJvcicsIGVycikpO1xuXHR9XG5cblx0aGFuZGxlUGFnZShwYWdlQ29uc3RydWN0b3IsIHJlcXVlc3QsIHR5cGUpIHtcblx0XHQvLyBpbnN0YW50aWF0ZSB0aGUgcGFnZXMgd2UgbmVlZCB0byBmdWxmaWxsIHRoaXMgcmVxdWVzdC5cblx0XHR2YXIgcGFnZUNsYXNzZXMgPSBbXTtcblxuXHRcdHRoaXMuX2FkZFBhZ2VNaWRkbGV3YXJlVG9BcnJheSh0aGlzLl9nbG9iYWxNaWRkbGV3YXJlLCBwYWdlQ2xhc3Nlcyk7XG5cdFx0dGhpcy5fYWRkUGFnZU1pZGRsZXdhcmVUb0FycmF5KFtwYWdlQ29uc3RydWN0b3JdLCBwYWdlQ2xhc3Nlcyk7XG5cblx0XHR2YXIgcGFnZXMgPSBwYWdlQ2xhc3Nlcy5tYXAoKHBhZ2VDbGFzcykgPT4ge1xuXHRcdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHBhZ2VDbGFzcykubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGluc3RhbnRpYXRlIGEgcGFnZSBvciBtaWRkbGV3YXJlIGNsYXNzIHRoYXQgd2FzIGFuIGVtcHR5IG9iamVjdC4gRGlkIHlvdSBmb3JnZXQgdG8gYXNzaWduIGEgY2xhc3MgdG8gbW9kdWxlLmV4cG9ydHM/XCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBwYWdlQ2xhc3MoKTtcblx0XHR9KTtcblx0XHR2YXIgcGFnZSA9IFBhZ2VVdGlsLmNyZWF0ZVBhZ2VDaGFpbihwYWdlcyk7XG5cblx0XHR0aGlzLmVtaXQoXCJwYWdlXCIsIHBhZ2UpO1xuXG5cdFx0cGFnZS5zZXRSZXF1ZXN0KHJlcXVlc3QpO1xuXG5cdFx0UGFnZVV0aWwuUGFnZUNvbmZpZy5pbml0RnJvbVBhZ2VXaXRoRGVmYXVsdHMocGFnZSwge1xuXHRcdFx0aXNGcmFnbWVudCAgICA6IGZhbHNlLFxuXHRcdFx0aXNSYXdSZXNwb25zZSA6IGZhbHNlLFxuXHRcdH0pO1xuXG5cdFx0Ly8gU2V0IHRoZSBwYWdlIGNvbnRleHQgb24gdGhlIHJlc3BvbnNlIGxvZ2dlciBzbyBpdCBjYW4gZmlndXJlXG5cdFx0Ly8gb3V0IHdoZXRoZXIgdG8gZmx1c2ggbG9ncyB0byB0aGUgcmVzcG9uc2UgZG9jdW1lbnRcblx0XHRzZXRSZXNwb25zZUxvZ2dlclBhZ2UocGFnZSk7XG5cblx0XHQvLyBjYWxsIHBhZ2UuaGFuZGxlUm91dGUoKSwgYW5kIHVzZSB0aGUgcmVzdWx0aW5nIGNvZGUgdG8gZGVjaWRlIGhvdyB0b1xuXHRcdC8vIHJlc3BvbmQuXG5cdFx0Ly8gV2UgY2FsbCBpdCBpbiBhIHByb21pc2UgaGFuZGxlciBzbyBhbnkgZXhjZXB0aW9uIHRoYXRcblx0XHQvLyBhcmlzZXMgd2lsbCBnZXQgY29udmVydGVkIHRvIGEgcmVqZWN0aW9uIHRoYXQgd2UgY2FuIGhhbmRsZVxuXHRcdC8vIGJlbG93LlxuXHRcdFEoKS50aGVuKHBhZ2UuaGFuZGxlUm91dGUpLnRoZW4oaGFuZGxlUm91dGVSZXN1bHQgPT4ge1xuXG5cdFx0XHRwYWdlLnNldFN0YXR1cyhoYW5kbGVSb3V0ZVJlc3VsdC5jb2RlKTtcblxuXHRcdFx0cGFnZS5zZXRIYXNEb2N1bWVudChoYW5kbGVSb3V0ZVJlc3VsdC5oYXNEb2N1bWVudCk7XG5cblx0XHRcdHBhZ2Uuc2V0SnNCZWxvd1RoZUZvbGQoRGVidWdVdGlsLmdldEpzQmVsb3dUaGVGb2xkKCkgfHwgaGFuZGxlUm91dGVSZXN1bHQuanNCZWxvd1RoZUZvbGQpO1xuXHRcdFx0cGFnZS5zZXRTcGxpdEpzTG9hZChEZWJ1Z1V0aWwuZ2V0U3BsaXRKc0xvYWQoKSB8fCBoYW5kbGVSb3V0ZVJlc3VsdC5zcGxpdEpzTG9hZCk7XG5cblx0XHRcdC8vIFRPRE86IEkgdGhpbmsgdGhhdCAzeHgvNHh4LzV4eCBzaG91bGRuJ3QgYmUgY29uc2lkZXJlZCBcImVycm9yc1wiIGluIG5hdmlnYXRlRG9uZSwgYnV0IHRoYXQnc1xuXHRcdFx0Ly8gaG93IHRoZSBjb2RlIGlzIHN0cnVjdHVyZWQgcmlnaHQgbm93LCBhbmQgSSdtIGNoYW5naW5nIHRvbyBtYW55IHRoaW5ncyBhdCBvbmNlIGF0IHRoZSBtb21lbnQuIC1zcmEuXG5cdFx0XHRpZiAoaGFuZGxlUm91dGVSZXN1bHQuY29kZSAmJiAoKGhhbmRsZVJvdXRlUmVzdWx0LmNvZGUgLyAxMDApfDApICE9PSAyKSB7XG5cdFx0XHRcdHRoaXMuZW1pdChcIm5hdmlnYXRlRG9uZVwiLCB7c3RhdHVzOiBoYW5kbGVSb3V0ZVJlc3VsdC5jb2RlLCByZWRpcmVjdFVybDogaGFuZGxlUm91dGVSZXN1bHQubG9jYXRpb259LCBwYWdlLCByZXF1ZXN0LmdldFVybCgpLCB0eXBlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhhbmRsZVJvdXRlUmVzdWx0LnBhZ2UpIHtcblx0XHRcdFx0Ly8gaW4gdGhpcyBjYXNlLCB3ZSBzaG91bGQgZm9yd2FyZCB0byBhIG5ldyBwYWdlICp3aXRob3V0KiBjaGFuZ2luZyB0aGUgVVJMLiBTaW5jZSB3ZSBhcmUgYWxyZWFkeVxuXHRcdFx0XHQvLyBpbiBhbiBhc3luYyBjYWxsYmFjaywgd2Ugc2hvdWxkIHNjaGVkdWxlIGEgbmV3IGhhbmRsZVBhZ2Ugd2l0aCB0aGUgbmV3IHBhZ2UgY29uc3RydWN0b3IgYW5kIHJldHVyblxuXHRcdFx0XHQvLyBmcm9tIHRoaXMgY2FsbC5cblx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB0aGlzLmhhbmRsZVBhZ2UoaGFuZGxlUm91dGVSZXN1bHQucGFnZSwgcmVxdWVzdCwgdHlwZSksIDApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZW1pdCgnbmF2aWdhdGVEb25lJywgbnVsbCwgcGFnZSwgcmVxdWVzdC5nZXRVcmwoKSwgdHlwZSk7XG5cdFx0fSkuY2F0Y2goZXJyID0+IHtcblx0XHRcdGxvZ2dlci5lcnJvcihcIkVycm9yIHdoaWxlIGhhbmRsaW5nIHJvdXRlXCIsIGVycik7XG5cblx0XHRcdHRoaXMuZW1pdCgnbmF2aWdhdGVEb25lJywge3N0YXR1czogNTAwfSwgcGFnZSwgcmVxdWVzdC5nZXRVcmwoKSwgdHlwZSk7XG5cdFx0fSk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiByZWN1cnNpdmVseSBhZGRzIHRoZSBtaWRkbGV3YXJlIGluIHRoZSBwYWdlcyBhcnJheSB0byBhcnJheS5cblx0ICovXG5cdF9hZGRQYWdlTWlkZGxld2FyZVRvQXJyYXkocGFnZXMsIGFycmF5KSB7XG5cdFx0aWYgKCFwYWdlcykgcmV0dXJuO1xuXHRcdHBhZ2VzLmZvckVhY2goKHBhZ2UpID0+IHtcblx0XHRcdGlmIChwYWdlLm1pZGRsZXdhcmUpIHtcblx0XHRcdFx0dGhpcy5fYWRkUGFnZU1pZGRsZXdhcmVUb0FycmF5KHBhZ2UubWlkZGxld2FyZSgpLCBhcnJheSk7XG5cdFx0XHR9XG5cdFx0XHRhcnJheS5wdXNoKHBhZ2UpO1xuXHRcdH0pO1xuXHR9XG5cblx0Z2V0U3RhdGUgKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRsb2FkaW5nOiB0aGlzLl9sb2FkaW5nLFxuXHRcdFx0cm91dGU6IHRoaXMuX2N1cnJlbnRSb3V0ZSxcblx0XHR9XG5cdH1cblxuXHRnZXRDdXJyZW50Um91dGUgKCkge1xuXHRcdHJldHVybiB0aGlzLl9jdXJyZW50Um91dGU7XG5cdH1cblxuXHRnZXRMb2FkaW5nICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcblx0fVxuXG5cdHN0YXJ0Um91dGUgKHJvdXRlLCByZXF1ZXN0LCB0eXBlKSB7XG5cblx0XHQvLyBJZiB3ZSdyZSBiZWluZyBjYWxsZWQgd2l0aCBhIHJlcXVlc3RlZCByb3V0ZSwgd2UnbGwgbmVlZCB0b1xuXHRcdC8vIHRlbGwgdGhlIGNhbGxlciB3aGVuIHRoZXkgY2FuIHByb2NlZWQgd2l0aCB0aGVpclxuXHRcdC8vIG5hdmlnYXRpb24uXG5cdFx0dmFyIGRmZCwgcHJvbWlzZTtcblxuXHRcdC8vIFdlIG5lZWQgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHJvdXRlcyBhcmUgcmVxdWVzdGVkIHdoaWxlXG5cdFx0Ly8gd2UncmUgaGFuZGxpbmcgdGhlIHByZXZpb3VzIG5hdmlnYXRpb24uICBUaGlzIGNhbiBoYXBwZW4gaWZcblx0XHQvLyB0aGUgdXNlciBmdXJpb3VzbHkgY2xpY2tzIHRoZSBicm93c2VyJ3MgZm9yd2FyZC9iYWNrXG5cdFx0Ly8gbmF2aWdhdGlvbiBidXR0b25zLlxuXHRcdC8vXG5cdFx0Ly8gV2UgZG9uJ3Qgd2FudCBhIF9xdWV1ZV8gaGVyZSwgYmVjYXVzZSB3ZSdyZSBvbmx5IHVsdGltYXRlbHlcblx0XHQvLyBnb2luZyB0byBzaG93IHRoZSB1c2VyIHRoZSBfZmluYWxfIHJvdXRlIHRoYXQncyByZXF1ZXN0ZWQsXG5cdFx0Ly8gc28gd2UnbGwganVzdCBrZWVwIGEgc2luZ2xlIHJlZmVyZW5jZSB0byB0aGUgbmV4dCByb3V0ZSB3ZVxuXHRcdC8vIG5lZWQgdG8gYWN0dWFsbHkgcmVuZGVyIG9uY2Ugb3VyIGN1cnJlbnQgbmF2aWdhdGlvbiBpc1xuXHRcdC8vIGNvbXBsZXRlLlxuXHRcdC8vXG5cdFx0aWYgKHJlcXVlc3QpIHtcblxuXHRcdFx0Ly8gV2UgZG9uJ3Qgd2FudCB0byBsZWF2ZSBuYXZpZ2F0aW9uIGRldHJpdHVzXG5cdFx0XHQvLyBsYXlpbmcgYXJvdW5kIGFzIHdlIGRpc2NhcmQgYnlwYXNzZWQgcGFnZXMuXG5cdFx0XHRpZiAodGhpcy5fbmV4dFJvdXRlKSB0aGlzLl9uZXh0Um91dGUuZGZkLnJlamVjdCgpO1xuXG5cdFx0XHRkZmQgPSBRLmRlZmVyKCksIHByb21pc2UgPSBkZmQucHJvbWlzZTtcblxuXHRcdFx0dGhpcy5fbmV4dFJvdXRlID0ge3JvdXRlLCByZXF1ZXN0LCB0eXBlLCBkZmR9O1xuXHRcdH1cblxuXHRcdC8vIElmIHdlJ3JlIF9jdXJyZW50bHlfIG5hdmlnYXRpbmcsIHdlJ2xsIHdhaXQgdG8gc3RhcnQgdGhlXG5cdFx0Ly8gbmV4dCByb3V0ZSB1bnRpbCB0aGlzIG5hdmlnYXRpb24gaXMgY29tcGxldGUuICBJbnRlcmxlYXZlZFxuXHRcdC8vIG5hdmlnYXRpb24gY2F1c2VzIGFsbCBraW5kcyBvZiBoYXZvYy5cblx0XHRpZiAoIXRoaXMuX2xvYWRpbmcgJiYgdGhpcy5fbmV4dFJvdXRlKXtcblxuXHRcdFx0Y29uc3Qge3JvdXRlLCByZXF1ZXN0LCB0eXBlLCBkZmR9ID0gdGhpcy5fbmV4dFJvdXRlO1xuXG5cdFx0XHR0aGlzLl9sb2FkaW5nICAgICAgPSB0cnVlO1xuXHRcdFx0dGhpcy5fY3VycmVudFJvdXRlID0gcm91dGU7XG5cdFx0XHR0aGlzLl9uZXh0Um91dGUgICAgPSBudWxsO1xuXG5cdFx0XHR0aGlzLmVtaXQoJ25hdmlnYXRlU3RhcnQnLCB7cm91dGUsIHJlcXVlc3QsIHR5cGV9KTtcblxuXHRcdFx0Ly8gVGhpcyBhbGxvd3MgdGhlIGFjdHVhbCBuYXZpZ2F0aW9uIHRvXG5cdFx0XHQvLyBwcm9jZWVkLlxuXHRcdFx0ZGZkLnJlc29sdmUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvbWlzZTtcblx0fVxuXG5cdGZpbmlzaFJvdXRlICgpIHtcblx0XHR0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLmVtaXQoJ2xvYWRDb21wbGV0ZScpO1xuXG5cdFx0Ly8gSWYgb3RoZXIgcm91dGVzIHdlcmUgcXVldWVkIHdoaWxlIHdlIHdlcmUgbmF2aWdhdGluZywgd2UnbGxcblx0XHQvLyBzdGFydCB0aGUgbmV4dCBvbmUgcmlnaHQgb2ZmLlxuXHRcdC8vXG5cdFx0dGhpcy5zdGFydFJvdXRlKCk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOYXZpZ2F0b3I7XG4iXX0=
