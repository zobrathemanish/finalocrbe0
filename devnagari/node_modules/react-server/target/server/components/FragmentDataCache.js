'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ReactServerAgent = require("../ReactServerAgent"),
    React = require('react'),
    PropTypes = require('prop-types');

/**
 * FragmentDataCache writes out a serialized form of the ReactServerAgent request
 * data cache into the `data-react-server-data-cache` attribute of a `<div>`
 * with an id attribute set to the value of the `cacheNodeId` prop. (Defaults
 * to `react-server-fragment-data-cache`)
 *
 * This component should _only_ be used when rendering fragments. Full-page
 * full-page renders have their data cache serialized by `renderMiddleware`.
 *
 * Usage of this component is totally optional. Only use it if you need it.
 *
 * Example (post-fragment-render) :
 *
 * ```javascript
 * var dataCacheStr = document.getElementById('react-server-fragment-data-cache')
 * 			.getAttribute('data-react-server-data-cache');
 *
 * var parsedData = JSON.parse(dataCacheStr);
 *
 * var entry = parsedData.dataCache["/someUrl"];
 * if (entry.err) {
 * 		// there was an error.
 * 		console.log(entry.err.response);	// if 500-error from server: { body: ...JSON... }
 * 		console.log(entry.err.timeout);		// if there was a `.timeout(...)` specified to ReactServerAgent
 *											// that was exceeded
 * } else {
 *		console.log(entry.res); // { body: }
 *
 * ```
 *
 * Known issues:
 * 	* entry.res and entry.err.response won't have any `body` entry if
 *	  the response from the server was HTML instead of JSON.
 */

var FragmentDataCache = function (_React$Component) {
  _inherits(FragmentDataCache, _React$Component);

  function FragmentDataCache() {
    _classCallCheck(this, FragmentDataCache);

    return _possibleConstructorReturn(this, (FragmentDataCache.__proto__ || Object.getPrototypeOf(FragmentDataCache)).apply(this, arguments));
  }

  _createClass(FragmentDataCache, [{
    key: 'render',
    value: function render() {
      return React.createElement('div', {
        id: this.props.cacheNodeId,
        'data-react-server-data-cache': JSON.stringify(ReactServerAgent.cache().dehydrate({ responseBodyOnly: true })) });
    }
  }], [{
    key: 'createWhenReady',


    /**
     * Return a promise that resolves with the FragmentDataCache component
     * when all pending data requests have resolved.
     */
    value: function createWhenReady() {
      var fragmentDataCacheProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return ReactServerAgent.cache().whenAllPendingResolve().then(function () {
        return React.createElement(FragmentDataCache, fragmentDataCacheProps);
      });
    }
  }, {
    key: 'displayName',
    get: function get() {
      return 'FragmentDataCache';
    }
  }, {
    key: 'propTypes',
    get: function get() {
      return {
        cacheNodeId: PropTypes.string
      };
    }
  }, {
    key: 'defaultProps',
    get: function get() {
      return {
        cacheNodeId: "react-server-fragment-data-cache"
      };
    }
  }]);

  return FragmentDataCache;
}(React.Component);

;

module.exports = FragmentDataCache;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHMvRnJhZ21lbnREYXRhQ2FjaGUuanN4Il0sIm5hbWVzIjpbIlJlYWN0U2VydmVyQWdlbnQiLCJyZXF1aXJlIiwiUmVhY3QiLCJQcm9wVHlwZXMiLCJGcmFnbWVudERhdGFDYWNoZSIsInByb3BzIiwiY2FjaGVOb2RlSWQiLCJKU09OIiwic3RyaW5naWZ5IiwiY2FjaGUiLCJkZWh5ZHJhdGUiLCJyZXNwb25zZUJvZHlPbmx5IiwiZnJhZ21lbnREYXRhQ2FjaGVQcm9wcyIsIndoZW5BbGxQZW5kaW5nUmVzb2x2ZSIsInRoZW4iLCJzdHJpbmciLCJDb21wb25lbnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0EsSUFBSUEsbUJBQW1CQyxRQUFRLHFCQUFSLENBQXZCO0FBQUEsSUFDQ0MsUUFBUUQsUUFBUSxPQUFSLENBRFQ7QUFBQSxJQUVDRSxZQUFZRixRQUFRLFlBQVIsQ0FGYjs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFrQ01HLGlCOzs7Ozs7Ozs7Ozs2QkE0Qkk7QUFDUixhQUNDO0FBQ0MsWUFBSSxLQUFLQyxLQUFMLENBQVdDLFdBRGhCO0FBRUMsd0NBQThCQyxLQUFLQyxTQUFMLENBQWVSLGlCQUFpQlMsS0FBakIsR0FBeUJDLFNBQXpCLENBQW1DLEVBQUVDLGtCQUFrQixJQUFwQixFQUFuQyxDQUFmLENBRi9CLEdBREQ7QUFNQTs7Ozs7QUFqQkQ7Ozs7c0NBSW9EO0FBQUEsVUFBN0JDLHNCQUE2Qix1RUFBSixFQUFJOztBQUNuRCxhQUFPWixpQkFBaUJTLEtBQWpCLEdBQXlCSSxxQkFBekIsR0FBaURDLElBQWpELENBQXNELFlBQU07QUFDbEUsZUFBTyxvQkFBQyxpQkFBRCxFQUF1QkYsc0JBQXZCLENBQVA7QUFDQSxPQUZNLENBQVA7QUFHQTs7O3dCQXhCd0I7QUFDeEIsYUFBTyxtQkFBUDtBQUNBOzs7d0JBRXNCO0FBQ3RCLGFBQU87QUFDTk4scUJBQWFILFVBQVVZO0FBRGpCLE9BQVA7QUFHQTs7O3dCQUV5QjtBQUN6QixhQUFPO0FBQ05ULHFCQUFhO0FBRFAsT0FBUDtBQUdBOzs7O0VBaEI4QkosTUFBTWMsUzs7QUFvQ3JDOztBQUVEQyxPQUFPQyxPQUFQLEdBQWlCZCxpQkFBakIiLCJmaWxlIjoiY29tcG9uZW50cy9GcmFnbWVudERhdGFDYWNoZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxudmFyIFJlYWN0U2VydmVyQWdlbnQgPSByZXF1aXJlKFwiLi4vUmVhY3RTZXJ2ZXJBZ2VudFwiKSxcblx0UmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpLFxuXHRQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG5cbi8qKlxuICogRnJhZ21lbnREYXRhQ2FjaGUgd3JpdGVzIG91dCBhIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgUmVhY3RTZXJ2ZXJBZ2VudCByZXF1ZXN0XG4gKiBkYXRhIGNhY2hlIGludG8gdGhlIGBkYXRhLXJlYWN0LXNlcnZlci1kYXRhLWNhY2hlYCBhdHRyaWJ1dGUgb2YgYSBgPGRpdj5gXG4gKiB3aXRoIGFuIGlkIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIHZhbHVlIG9mIHRoZSBgY2FjaGVOb2RlSWRgIHByb3AuIChEZWZhdWx0c1xuICogdG8gYHJlYWN0LXNlcnZlci1mcmFnbWVudC1kYXRhLWNhY2hlYClcbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBzaG91bGQgX29ubHlfIGJlIHVzZWQgd2hlbiByZW5kZXJpbmcgZnJhZ21lbnRzLiBGdWxsLXBhZ2VcbiAqIGZ1bGwtcGFnZSByZW5kZXJzIGhhdmUgdGhlaXIgZGF0YSBjYWNoZSBzZXJpYWxpemVkIGJ5IGByZW5kZXJNaWRkbGV3YXJlYC5cbiAqXG4gKiBVc2FnZSBvZiB0aGlzIGNvbXBvbmVudCBpcyB0b3RhbGx5IG9wdGlvbmFsLiBPbmx5IHVzZSBpdCBpZiB5b3UgbmVlZCBpdC5cbiAqXG4gKiBFeGFtcGxlIChwb3N0LWZyYWdtZW50LXJlbmRlcikgOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBkYXRhQ2FjaGVTdHIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVhY3Qtc2VydmVyLWZyYWdtZW50LWRhdGEtY2FjaGUnKVxuICogXHRcdFx0LmdldEF0dHJpYnV0ZSgnZGF0YS1yZWFjdC1zZXJ2ZXItZGF0YS1jYWNoZScpO1xuICpcbiAqIHZhciBwYXJzZWREYXRhID0gSlNPTi5wYXJzZShkYXRhQ2FjaGVTdHIpO1xuICpcbiAqIHZhciBlbnRyeSA9IHBhcnNlZERhdGEuZGF0YUNhY2hlW1wiL3NvbWVVcmxcIl07XG4gKiBpZiAoZW50cnkuZXJyKSB7XG4gKiBcdFx0Ly8gdGhlcmUgd2FzIGFuIGVycm9yLlxuICogXHRcdGNvbnNvbGUubG9nKGVudHJ5LmVyci5yZXNwb25zZSk7XHQvLyBpZiA1MDAtZXJyb3IgZnJvbSBzZXJ2ZXI6IHsgYm9keTogLi4uSlNPTi4uLiB9XG4gKiBcdFx0Y29uc29sZS5sb2coZW50cnkuZXJyLnRpbWVvdXQpO1x0XHQvLyBpZiB0aGVyZSB3YXMgYSBgLnRpbWVvdXQoLi4uKWAgc3BlY2lmaWVkIHRvIFJlYWN0U2VydmVyQWdlbnRcbiAqXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIHRoYXQgd2FzIGV4Y2VlZGVkXG4gKiB9IGVsc2Uge1xuICpcdFx0Y29uc29sZS5sb2coZW50cnkucmVzKTsgLy8geyBib2R5OiB9XG4gKlxuICogYGBgXG4gKlxuICogS25vd24gaXNzdWVzOlxuICogXHQqIGVudHJ5LnJlcyBhbmQgZW50cnkuZXJyLnJlc3BvbnNlIHdvbid0IGhhdmUgYW55IGBib2R5YCBlbnRyeSBpZlxuICpcdCAgdGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciB3YXMgSFRNTCBpbnN0ZWFkIG9mIEpTT04uXG4gKi9cbmNsYXNzIEZyYWdtZW50RGF0YUNhY2hlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuXHRzdGF0aWMgZ2V0IGRpc3BsYXlOYW1lKCkge1xuXHRcdHJldHVybiAnRnJhZ21lbnREYXRhQ2FjaGUnO1xuXHR9XG5cblx0c3RhdGljIGdldCBwcm9wVHlwZXMoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGNhY2hlTm9kZUlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuXHRcdH07XG5cdH1cblxuXHRzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wcygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Y2FjaGVOb2RlSWQ6IFwicmVhY3Qtc2VydmVyLWZyYWdtZW50LWRhdGEtY2FjaGVcIixcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBGcmFnbWVudERhdGFDYWNoZSBjb21wb25lbnRcblx0ICogd2hlbiBhbGwgcGVuZGluZyBkYXRhIHJlcXVlc3RzIGhhdmUgcmVzb2x2ZWQuXG5cdCAqL1xuXHRzdGF0aWMgY3JlYXRlV2hlblJlYWR5KGZyYWdtZW50RGF0YUNhY2hlUHJvcHMgPSB7fSkge1xuXHRcdHJldHVybiBSZWFjdFNlcnZlckFnZW50LmNhY2hlKCkud2hlbkFsbFBlbmRpbmdSZXNvbHZlKCkudGhlbigoKSA9PiB7XG5cdFx0XHRyZXR1cm4gPEZyYWdtZW50RGF0YUNhY2hlIHsuLi5mcmFnbWVudERhdGFDYWNoZVByb3BzfSAvPjtcblx0XHR9KTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdlxuXHRcdFx0XHRpZD17dGhpcy5wcm9wcy5jYWNoZU5vZGVJZH1cblx0XHRcdFx0ZGF0YS1yZWFjdC1zZXJ2ZXItZGF0YS1jYWNoZT17SlNPTi5zdHJpbmdpZnkoUmVhY3RTZXJ2ZXJBZ2VudC5jYWNoZSgpLmRlaHlkcmF0ZSh7IHJlc3BvbnNlQm9keU9ubHk6IHRydWUgfSkpfT5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnJhZ21lbnREYXRhQ2FjaGU7XG4iXX0=
