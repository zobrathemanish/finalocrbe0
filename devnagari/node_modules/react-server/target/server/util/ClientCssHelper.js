"use strict";

var logger = require('../logging').getLogger({ "name": "react-server.core.util.ClientCssHelper", "color": { "server": 147, "client": "rgb(127,127,212)" } });

var _require = require('../constants'),
    PAGE_CSS_NODE_ID = _require.PAGE_CSS_NODE_ID;

var Q = require('q');
var PageUtil = require('./PageUtil');

var loadedCss = {};

module.exports = {

	registerPageLoad: function registerPageLoad() {
		if (true) {
			throw new Error("ClientCssHelper.registerPageLoad can't be called server-side");
		}

		// for each css node in the head that the react-server server wrote to the response, note it down in the cache, so that
		// we can remove it on a page to page transition.
		var serverWrittenLinkNodes = document.head.querySelectorAll("link[" + PAGE_CSS_NODE_ID + "],style[" + PAGE_CSS_NODE_ID + "]");
		for (var i = 0; i < serverWrittenLinkNodes.length; i++) {
			var key,
			    styleNode = serverWrittenLinkNodes[i];
			if (styleNode.href) {
				key = normalizeLocalUrl(styleNode.href);
			} else {
				key = styleNode.innerHTML;
			}
			loadedCss[key] = styleNode;
		}
	},

	ensureCss: function ensureCss(routeName, pageObject) {
		var _this = this;

		if (true) {
			throw new Error("ClientCssHelper.registerPageLoad can't be called server-side");
		}

		return Q.all(PageUtil.standardizeStyles(pageObject.getHeadStylesheets())).then(function (newCss) {
			var newCssByKey = {};
			newCss.filter(function (style) {
				return !!style;
			}).forEach(function (style) {
				newCssByKey[_this._keyFromStyleSheet(style)] = style;
			});

			// first, remove the unneeded CSS link elements.
			Object.keys(loadedCss).forEach(function (loadedCssKey) {

				if (!newCssByKey[loadedCssKey]) {
					// remove the corresponding node from the DOM.
					logger.debug("Removing stylesheet: " + loadedCssKey);
					var node = loadedCss[loadedCssKey];
					node.parentNode.removeChild(node);
					delete loadedCss[loadedCssKey];
				}
			});

			// next add the style URLs that weren't already loaded.
			return Q.all(Object.keys(newCssByKey).map(function (newCssKey) {
				var retval;
				if (!loadedCss[newCssKey]) {
					// this means that the CSS is not currently present in the
					// document, so we need to add it.
					logger.debug("Adding stylesheet: " + newCssKey);

					var style = newCssByKey[newCssKey];
					var styleTag;

					if (style.href) {
						styleTag = document.createElement('link');
						styleTag.rel = 'stylesheet';
						styleTag.href = style.href;

						// If we _can_ wait for the CSS to be loaded before
						// proceeding, let's do so.
						if ('onload' in styleTag) {
							var dfd = Q.defer();
							styleTag.onload = dfd.resolve;
							retval = dfd.promise;
						}
					} else {
						styleTag = document.createElement('style');
						styleTag.innerHTML = style.text;
					}
					styleTag.type = style.type;
					styleTag.media = style.media;

					loadedCss[newCssKey] = styleTag;
					document.head.appendChild(styleTag);
				} else {
					logger.debug("Stylesheet already loaded (no-op): " + newCssKey);
				}
				return retval;
			}));
		});
	},

	_keyFromStyleSheet: function _keyFromStyleSheet(style) {
		return normalizeLocalUrl(style.href) || style.text;
	}
};

function normalizeLocalUrl(url) {
	// Step 1: make the url protocol less first.  This helps recognizing http://0.0.0.0:3001/common.css
	// and //0.0.0.0:3001/common.css as the same file.
	// Step 2: The browser will give us a full URL even if we only put a
	// path in on the server.  So, if we're comparing against just
	// a path here we need to strip the base off to avoid a flash
	// of unstyled content.
	if (typeof url === 'string') {
		url = url.replace(/^http[s]?:/, '').replace(new RegExp("^\/\/" + location.host), '');
	}

	return url;
}
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInV0aWwvQ2xpZW50Q3NzSGVscGVyLmpzIl0sIm5hbWVzIjpbImxvZ2dlciIsInJlcXVpcmUiLCJnZXRMb2dnZXIiLCJQQUdFX0NTU19OT0RFX0lEIiwiUSIsIlBhZ2VVdGlsIiwibG9hZGVkQ3NzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlZ2lzdGVyUGFnZUxvYWQiLCJFcnJvciIsInNlcnZlcldyaXR0ZW5MaW5rTm9kZXMiLCJkb2N1bWVudCIsImhlYWQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaSIsImxlbmd0aCIsImtleSIsInN0eWxlTm9kZSIsImhyZWYiLCJub3JtYWxpemVMb2NhbFVybCIsImlubmVySFRNTCIsImVuc3VyZUNzcyIsInJvdXRlTmFtZSIsInBhZ2VPYmplY3QiLCJhbGwiLCJzdGFuZGFyZGl6ZVN0eWxlcyIsImdldEhlYWRTdHlsZXNoZWV0cyIsInRoZW4iLCJuZXdDc3NCeUtleSIsIm5ld0NzcyIsImZpbHRlciIsInN0eWxlIiwiZm9yRWFjaCIsIl9rZXlGcm9tU3R5bGVTaGVldCIsIk9iamVjdCIsImtleXMiLCJsb2FkZWRDc3NLZXkiLCJkZWJ1ZyIsIm5vZGUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJtYXAiLCJyZXR2YWwiLCJuZXdDc3NLZXkiLCJzdHlsZVRhZyIsImNyZWF0ZUVsZW1lbnQiLCJyZWwiLCJkZmQiLCJkZWZlciIsIm9ubG9hZCIsInJlc29sdmUiLCJwcm9taXNlIiwidGV4dCIsInR5cGUiLCJtZWRpYSIsImFwcGVuZENoaWxkIiwidXJsIiwicmVwbGFjZSIsIlJlZ0V4cCIsImxvY2F0aW9uIiwiaG9zdCJdLCJtYXBwaW5ncyI6Ijs7QUFDQSxJQUFJQSxTQUFTQyxRQUFRLFlBQVIsRUFBc0JDLFNBQXRCLENBQWdDLEVBQUMsUUFBTyx3Q0FBUixFQUFpRCxTQUFRLEVBQUMsVUFBUyxHQUFWLEVBQWMsVUFBUyxrQkFBdkIsRUFBekQsRUFBaEMsQ0FBYjs7ZUFDeUJELFFBQVEsY0FBUixDO0lBQXBCRSxnQixZ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a0MsYUFBVCxDQUF1QixPQUF2QixDQUFYO0FBQ0FELGVBQVN4QixTQUFULEdBQXFCVyxNQUFNcUIsSUFBM0I7QUFDQTtBQUNEUixjQUFTUyxJQUFULEdBQWdCdEIsTUFBTXNCLElBQXRCO0FBQ0FULGNBQVNVLEtBQVQsR0FBaUJ2QixNQUFNdUIsS0FBdkI7O0FBRUFqRCxlQUFVc0MsU0FBVixJQUF1QkMsUUFBdkI7QUFDQWpDLGNBQVNDLElBQVQsQ0FBYzJDLFdBQWQsQ0FBMEJYLFFBQTFCO0FBQ0EsS0E3QkQsTUE2Qk87QUFDTjdDLFlBQU9zQyxLQUFQLHlDQUFtRE0sU0FBbkQ7QUFDQTtBQUNELFdBQU9ELE1BQVA7QUFDQSxJQW5DWSxDQUFOLENBQVA7QUFvQ0EsR0F2RE0sQ0FBUDtBQXdEQSxFQWxGZTs7QUFvRmhCVCxxQkFBb0IsNEJBQVNGLEtBQVQsRUFBZ0I7QUFDbkMsU0FBT1osa0JBQWtCWSxNQUFNYixJQUF4QixLQUFpQ2EsTUFBTXFCLElBQTlDO0FBQ0E7QUF0RmUsQ0FBakI7O0FBeUZBLFNBQVNqQyxpQkFBVCxDQUEyQnFDLEdBQTNCLEVBQWdDO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUksT0FBT0EsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzVCQSxRQUFNQSxJQUNKQyxPQURJLENBQ0ksWUFESixFQUNrQixFQURsQixFQUVKQSxPQUZJLENBRUksSUFBSUMsTUFBSixDQUFXLFVBQVVDLFNBQVNDLElBQTlCLENBRkosRUFFeUMsRUFGekMsQ0FBTjtBQUdBOztBQUVELFFBQU9KLEdBQVA7QUFDQSIsImZpbGUiOiJ1dGlsL0NsaWVudENzc0hlbHBlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGxvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dpbmcnKS5nZXRMb2dnZXIoe1wibmFtZVwiOlwicmVhY3Qtc2VydmVyLmNvcmUudXRpbC5DbGllbnRDc3NIZWxwZXJcIixcImNvbG9yXCI6e1wic2VydmVyXCI6MTQ3LFwiY2xpZW50XCI6XCJyZ2IoMTI3LDEyNywyMTIpXCJ9fSk7XG52YXIge1BBR0VfQ1NTX05PREVfSUR9ID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG52YXIgUSA9IHJlcXVpcmUoJ3EnKTtcbnZhciBQYWdlVXRpbCA9IHJlcXVpcmUoJy4vUGFnZVV0aWwnKVxuXG52YXIgbG9hZGVkQ3NzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdHJlZ2lzdGVyUGFnZUxvYWQ6IGZ1bmN0aW9uIHJlZ2lzdGVyUGFnZUxvYWQoKSB7XG5cdFx0aWYgKHRydWUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNsaWVudENzc0hlbHBlci5yZWdpc3RlclBhZ2VMb2FkIGNhbid0IGJlIGNhbGxlZCBzZXJ2ZXItc2lkZVwiKTtcblx0XHR9XG5cblx0XHQvLyBmb3IgZWFjaCBjc3Mgbm9kZSBpbiB0aGUgaGVhZCB0aGF0IHRoZSByZWFjdC1zZXJ2ZXIgc2VydmVyIHdyb3RlIHRvIHRoZSByZXNwb25zZSwgbm90ZSBpdCBkb3duIGluIHRoZSBjYWNoZSwgc28gdGhhdFxuXHRcdC8vIHdlIGNhbiByZW1vdmUgaXQgb24gYSBwYWdlIHRvIHBhZ2UgdHJhbnNpdGlvbi5cblx0XHR2YXIgc2VydmVyV3JpdHRlbkxpbmtOb2RlcyA9IGRvY3VtZW50LmhlYWQucXVlcnlTZWxlY3RvckFsbChgbGlua1ske1BBR0VfQ1NTX05PREVfSUR9XSxzdHlsZVske1BBR0VfQ1NTX05PREVfSUR9XWApO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2VydmVyV3JpdHRlbkxpbmtOb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGtleSwgc3R5bGVOb2RlID0gc2VydmVyV3JpdHRlbkxpbmtOb2Rlc1tpXTtcblx0XHRcdGlmIChzdHlsZU5vZGUuaHJlZikge1xuXHRcdFx0XHRrZXkgPSBub3JtYWxpemVMb2NhbFVybChzdHlsZU5vZGUuaHJlZik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBzdHlsZU5vZGUuaW5uZXJIVE1MO1xuXHRcdFx0fVxuXHRcdFx0bG9hZGVkQ3NzW2tleV0gPSBzdHlsZU5vZGU7XG5cdFx0fVxuXHR9LFxuXG5cdGVuc3VyZUNzczogZnVuY3Rpb24gZW5zdXJlQ3NzKHJvdXRlTmFtZSwgcGFnZU9iamVjdCkge1xuXHRcdGlmICh0cnVlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDbGllbnRDc3NIZWxwZXIucmVnaXN0ZXJQYWdlTG9hZCBjYW4ndCBiZSBjYWxsZWQgc2VydmVyLXNpZGVcIik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFEuYWxsKFBhZ2VVdGlsLnN0YW5kYXJkaXplU3R5bGVzKHBhZ2VPYmplY3QuZ2V0SGVhZFN0eWxlc2hlZXRzKCkpKS50aGVuKG5ld0NzcyA9PiB7XG5cdFx0XHR2YXIgbmV3Q3NzQnlLZXkgPSB7fTtcblx0XHRcdG5ld0Nzc1xuXHRcdFx0XHQuZmlsdGVyKHN0eWxlID0+ICEhc3R5bGUpXG5cdFx0XHRcdC5mb3JFYWNoKHN0eWxlID0+IHtuZXdDc3NCeUtleVt0aGlzLl9rZXlGcm9tU3R5bGVTaGVldChzdHlsZSldID0gc3R5bGV9KTtcblxuXHRcdFx0Ly8gZmlyc3QsIHJlbW92ZSB0aGUgdW5uZWVkZWQgQ1NTIGxpbmsgZWxlbWVudHMuXG5cdFx0XHRPYmplY3Qua2V5cyhsb2FkZWRDc3MpLmZvckVhY2gobG9hZGVkQ3NzS2V5ID0+IHtcblxuXHRcdFx0XHRpZiAoIW5ld0Nzc0J5S2V5W2xvYWRlZENzc0tleV0pIHtcblx0XHRcdFx0XHQvLyByZW1vdmUgdGhlIGNvcnJlc3BvbmRpbmcgbm9kZSBmcm9tIHRoZSBET00uXG5cdFx0XHRcdFx0bG9nZ2VyLmRlYnVnKFwiUmVtb3Zpbmcgc3R5bGVzaGVldDogXCIgKyBsb2FkZWRDc3NLZXkpO1xuXHRcdFx0XHRcdHZhciBub2RlID0gbG9hZGVkQ3NzW2xvYWRlZENzc0tleV07XG5cdFx0XHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuXHRcdFx0XHRcdGRlbGV0ZSBsb2FkZWRDc3NbbG9hZGVkQ3NzS2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIG5leHQgYWRkIHRoZSBzdHlsZSBVUkxzIHRoYXQgd2VyZW4ndCBhbHJlYWR5IGxvYWRlZC5cblx0XHRcdHJldHVybiBRLmFsbChPYmplY3Qua2V5cyhuZXdDc3NCeUtleSkubWFwKG5ld0Nzc0tleSA9PiB7XG5cdFx0XHRcdHZhciByZXR2YWw7XG5cdFx0XHRcdGlmICghbG9hZGVkQ3NzW25ld0Nzc0tleV0pIHtcblx0XHRcdFx0XHQvLyB0aGlzIG1lYW5zIHRoYXQgdGhlIENTUyBpcyBub3QgY3VycmVudGx5IHByZXNlbnQgaW4gdGhlXG5cdFx0XHRcdFx0Ly8gZG9jdW1lbnQsIHNvIHdlIG5lZWQgdG8gYWRkIGl0LlxuXHRcdFx0XHRcdGxvZ2dlci5kZWJ1ZyhcIkFkZGluZyBzdHlsZXNoZWV0OiBcIiArIG5ld0Nzc0tleSk7XG5cblx0XHRcdFx0XHR2YXIgc3R5bGUgPSBuZXdDc3NCeUtleVtuZXdDc3NLZXldO1xuXHRcdFx0XHRcdHZhciBzdHlsZVRhZztcblxuXHRcdFx0XHRcdGlmIChzdHlsZS5ocmVmKSB7XG5cdFx0XHRcdFx0XHRzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcblx0XHRcdFx0XHRcdHN0eWxlVGFnLnJlbCA9ICdzdHlsZXNoZWV0Jztcblx0XHRcdFx0XHRcdHN0eWxlVGFnLmhyZWYgPSBzdHlsZS5ocmVmO1xuXG5cdFx0XHRcdFx0XHQvLyBJZiB3ZSBfY2FuXyB3YWl0IGZvciB0aGUgQ1NTIHRvIGJlIGxvYWRlZCBiZWZvcmVcblx0XHRcdFx0XHRcdC8vIHByb2NlZWRpbmcsIGxldCdzIGRvIHNvLlxuXHRcdFx0XHRcdFx0aWYgKCdvbmxvYWQnIGluIHN0eWxlVGFnKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBkZmQgPSBRLmRlZmVyKCk7XG5cdFx0XHRcdFx0XHRcdHN0eWxlVGFnLm9ubG9hZCA9IGRmZC5yZXNvbHZlO1xuXHRcdFx0XHRcdFx0XHRyZXR2YWwgPSBkZmQucHJvbWlzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3R5bGVUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXHRcdFx0XHRcdFx0c3R5bGVUYWcuaW5uZXJIVE1MID0gc3R5bGUudGV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3R5bGVUYWcudHlwZSA9IHN0eWxlLnR5cGU7XG5cdFx0XHRcdFx0c3R5bGVUYWcubWVkaWEgPSBzdHlsZS5tZWRpYTtcblxuXHRcdFx0XHRcdGxvYWRlZENzc1tuZXdDc3NLZXldID0gc3R5bGVUYWc7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZVRhZyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bG9nZ2VyLmRlYnVnKGBTdHlsZXNoZWV0IGFscmVhZHkgbG9hZGVkIChuby1vcCk6ICR7bmV3Q3NzS2V5fWApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXR2YWw7XG5cdFx0XHR9KSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2tleUZyb21TdHlsZVNoZWV0OiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHJldHVybiBub3JtYWxpemVMb2NhbFVybChzdHlsZS5ocmVmKSB8fCBzdHlsZS50ZXh0O1xuXHR9LFxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVMb2NhbFVybCh1cmwpIHtcblx0Ly8gU3RlcCAxOiBtYWtlIHRoZSB1cmwgcHJvdG9jb2wgbGVzcyBmaXJzdC4gIFRoaXMgaGVscHMgcmVjb2duaXppbmcgaHR0cDovLzAuMC4wLjA6MzAwMS9jb21tb24uY3NzXG5cdC8vIGFuZCAvLzAuMC4wLjA6MzAwMS9jb21tb24uY3NzIGFzIHRoZSBzYW1lIGZpbGUuXG5cdC8vIFN0ZXAgMjogVGhlIGJyb3dzZXIgd2lsbCBnaXZlIHVzIGEgZnVsbCBVUkwgZXZlbiBpZiB3ZSBvbmx5IHB1dCBhXG5cdC8vIHBhdGggaW4gb24gdGhlIHNlcnZlci4gIFNvLCBpZiB3ZSdyZSBjb21wYXJpbmcgYWdhaW5zdCBqdXN0XG5cdC8vIGEgcGF0aCBoZXJlIHdlIG5lZWQgdG8gc3RyaXAgdGhlIGJhc2Ugb2ZmIHRvIGF2b2lkIGEgZmxhc2hcblx0Ly8gb2YgdW5zdHlsZWQgY29udGVudC5cblx0aWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG5cdFx0dXJsID0gdXJsXG5cdFx0XHQucmVwbGFjZSgvXmh0dHBbc10/Oi8sICcnKVxuXHRcdFx0LnJlcGxhY2UobmV3IFJlZ0V4cChcIl5cXC9cXC9cIiArIGxvY2F0aW9uLmhvc3QpLCAnJyk7XG5cdH1cblxuXHRyZXR1cm4gdXJsO1xufVxuIl19
