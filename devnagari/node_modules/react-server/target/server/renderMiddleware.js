"use strict";

var logger = require('./logging').getLogger({ "name": "react-server.core.renderMiddleware", "color": { "server": 207, "client": "rgb(212,42,212)" } }),
    React = require('react'),
    ReactDOMServer = require('react-dom/server'),
    MobileDetect = require('mobile-detect'),
    RequestContext = require('./context/RequestContext'),
    RequestLocalStorage = require('./util/RequestLocalStorage'),
    DebugUtil = require('./util/DebugUtil'),
    RLS = RequestLocalStorage.getNamespace(),
    flab = require('flab'),
    Q = require('q'),
    config = require('./config'),
    ExpressServerRequest = require("./ExpressServerRequest"),
    PageUtil = require('./util/PageUtil'),
    ReactServerAgent = require('./ReactServerAgent'),
    StringEscapeUtil = require('./util/StringEscapeUtil'),
    _require = require('./components/RootElement'),
    getRootElementAttributes = _require.getRootElementAttributes,
    _require2 = require('./constants'),
    PAGE_CSS_NODE_ID = _require2.PAGE_CSS_NODE_ID,
    PAGE_LINK_NODE_ID = _require2.PAGE_LINK_NODE_ID,
    PAGE_CONTENT_NODE_ID = _require2.PAGE_CONTENT_NODE_ID,
    PAGE_CONTAINER_NODE_ID = _require2.PAGE_CONTAINER_NODE_ID,
    _require3 = require('./logging/response'),
    flushLogsToResponse = _require3.flushLogsToResponse;


var _ = {
	map: require('lodash/map')
};

// TODO FIXME ??
// It *might* be worthwhile to get rid of all the closure-y things in render()
// https://developers.google.com/speed/articles/optimizing-javascript

// If an element hasn't rendered in this long it gets the axe.
var FAILSAFE_RENDER_TIMEOUT = 20e3;

// If a page's `handleRoute` fails to resolve this fast it gets the axe.
var FAILSAFE_ROUTER_TIMEOUT = 20e3;

// We'll use this for keeping track of request concurrency per worker.
var ACTIVE_REQUESTS = 0;

// Some non-content items that can live in the elements array.
var ELEMENT_PENDING = -1;
var ELEMENT_ALREADY_WRITTEN = -2;

/**
 * renderMiddleware entrypoint. Called by express for every request.
 */
module.exports = function (req, res, next, routes) {
	RequestLocalStorage.startRequest(function () {
		ACTIVE_REQUESTS++;

		var start = RLS().startTime = new Date();
		var startHR = process.hrtime();

		logger.debug("Incoming request for " + req.path);

		initResponseCompletePromise(res);

		// monkey-patch `res.write` so that we don't try to write to the stream if it's
		// already closed
		var origWrite = res.write;
		res.write = function () {
			if (!res.finished) {
				origWrite.apply(res, arguments);
			} else {
				logger.error("Attempted write after response finished", { path: req && req.path || "unknown", stack: logger.stack() });
			}
		};

		// TODO? pull this context building into its own middleware
		var context = new RequestContext.Builder().setRoutes(routes).setDefaultXhrHeadersFromRequest(req).create({
			// TODO: context opts?
		});

		// Need this stuff in for logging.
		context.setServerStash({ req: req, res: res, start: start, startHR: startHR });

		context.setDeviceType(getDeviceType(req));

		var navigateDfd = Q.defer();

		// setup navigation handler (TODO: should we have a 'once' version?)
		context.onNavigate(function (err, page) {

			if (!navigateDfd.promise.isPending()) {
				logger.error("Finished navigation after FAILSAFE_ROUTER_TIMEOUT", {
					page: context.page,
					path: req.path
				});
				return;
			}

			// Success.
			navigateDfd.resolve();

			if (err) {
				// The page can elect to proceed to render
				// even with a non-2xx response.  If it
				// _doesn't_ do so then we're done.
				var done = !(page && page.getHasDocument());

				if (err.status === 301 || err.status === 302 || err.status === 307) {
					if (done) {
						// This adds a boilerplate body.
						res.redirect(err.status, err.redirectUrl);
					} else {
						// This expects our page to
						// render a body.  Hope they
						// know what they're doing.
						res.set('Location', err.redirectUrl);
					}
				} else if (done) {
					if (err.status === 404) {
						next();
					} else {
						next(err);
					}
				}
				if (done) {
					logger.log("onNavigate received a non-2xx HTTP code", err);
					handleResponseComplete(req, res, context, start, page);
					return;
				}
			}
			renderPage(req, res, context, start, page);
		});

		var timeout = setTimeout(navigateDfd.reject, FAILSAFE_ROUTER_TIMEOUT);

		// Don't leave dead timers hanging around.
		navigateDfd.promise.then(function () {
			return clearTimeout(timeout);
		});

		// If we fail to navigate, we'll throw a 500 and move on.
		navigateDfd.promise.catch(function () {
			logger.error("Failed to navigate after FAILSAFE_ROUTER_TIMEOUT", {
				page: context.navigator.getCurrentRoute().name,
				path: req.path
			});
			handleResponseComplete(req, res, context, start, context.page);
			next({ status: 500 });
		});

		context.navigate(new ExpressServerRequest(req));
	});
};

module.exports.getActiveRequests = function () {
	return ACTIVE_REQUESTS;
};

function initResponseCompletePromise(res) {
	var dfd = Q.defer();

	res.on('close', dfd.resolve);
	res.on('finish', dfd.resolve);

	RLS().responseCompletePromise = dfd.promise;
}

function handleResponseComplete(req, res, context, start, page) {

	RLS().responseCompletePromise.then(RequestLocalStorage.bind(function () {

		// All intentional response completion should funnel through
		// this function.  If this value starts climbing gradually
		// that's an indication that we have some _unintentional_
		// response completion going on that we should deal with.
		ACTIVE_REQUESTS--;

		// Note that if the navigator couldn't even map the request to
		// a page, we won't be able to call middleware
		// `handleComplete()` here.
		//
		if (page) {
			logRequestStats(req, res, context, start, page);

			page.handleComplete();
		}
	}));
}

function renderPage(req, res, context, start, page) {

	var routeName = context.navigator.getCurrentRoute().name;

	logger.debug("Route Name: " + routeName);

	var timer = logger.timer("lifecycle.individual");

	// Protects some browsers (Chrome, IE) against MIME sniffing attacks.
	// see: http://security.stackexchange.com/a/12916
	res.set('X-Content-Type-Options', 'nosniff');

	res.status(page.getStatus() || 200);

	// Handy to have random access to this rather than needing to thread it
	// through everywhere.
	RLS().page = page;

	// Each of these functions has the same signature and returns a
	// promise, so we can chain them up with a promise reduction.
	var lifecycleMethods;
	if (PageUtil.PageConfig.get('isFragment')) {
		lifecycleMethods = fragmentLifecycle();
	} else if (PageUtil.PageConfig.get('isRawResponse')) {
		lifecycleMethods = rawResponseLifecycle();
	} else if (req.query[ReactServerAgent.DATA_BUNDLE_PARAMETER]) {
		lifecycleMethods = dataBundleLifecycle();
	} else {
		lifecycleMethods = pageLifecycle();
	}

	lifecycleMethods.reduce(function (chain, func) {
		return chain.then(function () {
			return func(req, res, context, start, page);
		}).then(function () {
			timer.tick(func.name);
			logger.time("lifecycle.fromStart." + func.name, new Date() - start);
		});
	}).catch(function (err) {
		logger.error("Error in renderPage chain", err);

		// Register `finish` listener before ending response.
		handleResponseComplete(req, res, context, start, page);

		// Bummer.
		res.status(500).end();
	});

	// TODO: we probably want a "we're not waiting any longer for this"
	// timeout as well, and cancel the waiting deferreds
}

function rawResponseLifecycle() {
	return [Q(), // NOOP lead-in to prime the reduction
	setHttpHeaders, setContentType, writeResponseData, handleResponseComplete, endResponse];
}

function fragmentLifecycle() {
	return [Q(), // NOOP lead-in to prime the reduction
	setHttpHeaders, writeDebugComments, writeBody, handleResponseComplete, endResponse];
}

function dataBundleLifecycle() {
	return [Q(), // NOOP lead-in to prime the reduction
	setDataBundleContentType, writeDataBundle, handleResponseComplete, endResponse];
}

function pageLifecycle() {
	return [Q(), // This is just a NOOP lead-in to prime the reduction.
	setHttpHeaders, writeHeader, startBody, writeBody, wrapUpLateArrivals, closeBody, handleResponseComplete, endResponse];
}

function setDataBundleContentType(req, res) {
	res.set('Content-Type', 'application/json');
}

function setHttpHeaders(req, res, context, start, pageObject) {
	// Write out custom page-defined http headers. Headers may be overwritten later on in the render chain
	// (e.g. transfer encoding, content type)
	var handler = function handler(header) {
		return res.set(header[0], header[1]);
	};

	return Q(pageObject.getHeaders()).then(function (headers) {
		return headers.forEach(handler);
	});
}

function setContentType(req, res, context, start, pageObject) {
	res.set('Content-Type', pageObject.getContentType());
}

function writeHeader(req, res, context, start, pageObject) {
	// This is awkward and imprecise.  We don't want to put `<script>`
	// tags between divs above the fold, so we're going to keep separate
	// track of time client and server side. Then we'll put `<noscript>`
	// tags with data elements representing offset from our _server_ base
	// time that we'll apply to our _client_ base time as a proxy for when
	// the element arrived (when it's actually when we _sent_ it).
	RLS().timingDataT0 = new Date();

	res.type('html');
	res.set('Transfer-Encoding', 'chunked');

	res.write('<!DOCTYPE html><html lang="en"><head>');

	// note: these responses can currently come back out-of-order, as many are returning
	// promises. scripts and stylesheets are guaranteed
	return Q.all([renderDebugComments(pageObject, res), renderTitle(pageObject, res),
	// PLAT-602: inline scripts come before stylesheets because
	// stylesheet downloads block inline script execution.
	pageObject.getJsBelowTheFold() && !pageObject.getSplitJsLoad() ? Q() : renderScripts(pageObject, res), renderStylesheets(pageObject, res).then(function () {
		return Q.all([renderMetaTags(pageObject, res), renderLinkTags(pageObject, res), renderBaseTag(pageObject, res)]);
	})]).then(function () {
		// once we have finished rendering all of the pieces of the head element, we
		// can close the head and start the body element.
		res.write("</head>");

		// Get headers out right away so secondary resource download can start.
		flushRes(res);
	});
}

function flushRes(res) {

	// This method is only defined on the response object if the compress
	// middleware is installed, so we need to guard our calls.
	if (res.flush) {
		res.flush();
		if (!RLS().didLogFirstFlush) {
			RLS().didLogFirstFlush = true;
			logger.time('firstFlush', new Date() - RLS().startTime);
		}
	}
}

function renderDebugComments(pageObject, res) {
	var debugComments = pageObject.getDebugComments();
	debugComments.map(function (debugComment) {
		if (!debugComment.label || !debugComment.value) {
			logger.warning("Debug comment is missing either a label or a value", debugComment);
		}

		res.write("<!-- " + debugComment.label + ": " + debugComment.value + " -->");
	});

	// resolve immediately.
	return Q("");
}

function writeDebugComments(req, res, context, start, pageObject) {
	return Q(renderDebugComments(pageObject, res));
}

function renderTitle(pageObject, res) {
	return pageObject.getTitle().then(function (title) {
		res.write("<title>" + title + "</title>");
	});
}

function attrfy(value) {
	return value.replace(/"/g, '&quot;');
}

function renderMetaTags(pageObject, res) {
	var metaTags = pageObject.getMetaTags();

	var metaTagsRendered = metaTags.map(function (metaTagPromise) {
		return metaTagPromise.then(PageUtil.makeArray).then(function (metaTags) {
			return metaTags.forEach(function (metaTag) {
				if (metaTag) {
					// TODO: escaping
					if (metaTag.name && metaTag.httpEquiv || metaTag.name && metaTag.charset || metaTag.charset && metaTag.httpEquiv) {
						throw new Error("Meta tag cannot have more than one of name, httpEquiv, and charset", metaTag);
					}

					if (metaTag.name && !metaTag.content || metaTag.httpEquiv && !metaTag.content) {
						throw new Error("Meta tag has name or httpEquiv but does not have content", metaTag);
					}

					if (metaTag.noscript) res.write("<noscript>");
					res.write("<meta");

					if (metaTag.name) res.write(" name=\"" + attrfy(metaTag.name) + "\"");
					if (metaTag.httpEquiv) res.write(" http-equiv=\"" + attrfy(metaTag.httpEquiv) + "\"");
					if (metaTag.charset) res.write(" charset=\"" + attrfy(metaTag.charset) + "\"");
					if (metaTag.property) res.write(" property=\"" + attrfy(metaTag.property) + "\"");
					if (metaTag.content) res.write(" content=\"" + attrfy(metaTag.content) + "\"");

					res.write(">");
					if (metaTag.noscript) res.write("</noscript>");
				}
			});
		});
	});

	return Q.all(metaTagsRendered);
}

function renderLinkTags(pageObject, res) {
	var linkTags = pageObject.getLinkTags();

	var linkTagsRendered = linkTags.map(function (linkTagPromise) {
		return linkTagPromise.then(PageUtil.makeArray).then(function (linkTags) {
			return linkTags.forEach(function (linkTag) {
				if (linkTag) {
					if (!linkTag.rel) {
						throw new Error("<link> tag specified without 'rel' attr");
					}

					res.write("<link " + PAGE_LINK_NODE_ID + " " + Object.keys(linkTag).map(function (attr) {
						return attr + "=\"" + attrfy(linkTag[attr]) + "\"";
					}).join(' ') + ">");
				}
			});
		});
	});

	return Q.all(linkTagsRendered);
}

function renderBaseTag(pageObject, res) {
	return pageObject.getBase().then(function (base) {
		if (base !== null) {
			if (!base.href && !base.target) {
				throw new Error("<base> needs at least one of 'href' or 'target'");
			}
			var tag = "<base";
			if (base.href) {
				tag += " href=\"" + attrfy(base.href) + "\"";
			}
			if (base.target) {
				tag += " target=\"" + attrfy(base.target) + "\"";
			}
			tag += ">";
			res.write(tag);
		}
	});
}

function renderScriptsSync(scripts, res) {

	// right now, the getXXXScriptFiles methods return synchronously, no promises, so we can render
	// immediately.
	scripts.forEach(function (script) {
		// make sure there's a leading '/'
		if (!script.type) script.type = "text/javascript";

		if (script.href) {
			res.write("<script src=\"" + script.href + "\" type=\"" + script.type + "\"></script>");
		} else if (script.text) {
			res.write("<script type=\"" + script.type + "\">" + script.text + "</script>");
		} else {
			throw new Error("Script cannot be rendered because it has neither an href nor a text attribute: " + script);
		}
	});
}

function renderScriptsAsync(scripts, res) {

	// Nothing to do if there are no scripts.
	if (!scripts.length) return;

	// Don't need "type" in <script> tags anymore.
	//
	// http://www.w3.org/TR/html/scripting-1.html#the-script-element
	//
	// > The default, which is used if the attribute is absent, is "text/javascript".
	//
	res.write("<script>");

	// Lazily load LAB the first time we spit out async scripts.
	if (!RLS().didLoadLAB) {

		var globalDefaults = { AlwaysPreserveOrder: true };

		// The "cache-preloading" option in stock LABjs doesn't work in modern
		// Chrome. If you're configured for splitJsLoad then you'd better have
		// xhr access to your scripts!  They need to either be on the same
		// domain or have CORS headers.
		if (RLS().page.getSplitJsLoad()) {
			globalDefaults.UseCORSXHR = true;
		}

		// This is the full implementation of LABjs.
		// Pass `?_debug_lab=1` for unminified source with debugging output.
		res.write(DebugUtil.getLab() ? flab.src : flab.min);

		// We always want scripts to be executed in order.
		res.write("$LAB.setGlobalDefaults(" + JSON.stringify(globalDefaults) + ");");

		// We'll use this to store state between calls (see below).
		res.write("window._tLAB=$LAB");

		// If we're splitting our JS load from the execution of our JS then we
		// need to tell LABjs to preload our bundles but hold off on executing
		// them.
		if (RLS().page.getSplitJsLoad()) res.write(".cork()");

		// Only need to do this part once.
		RLS().didLoadLAB = true;
	} else {

		// The assignment to `_tLAB` here is so we maintain a single
		// LAB chain through all of our calls to `renderScriptsAsync`.
		//
		// Each call to this function emits output that looks
		// something like:
		//
		//   _tLAB=_tLAB.script(...).wait(...) ...
		//
		// The result is that `window._tLAB` winds up holding the
		// final state of the LAB chain after each call, so that same
		// LAB chain can be appended to in the _next_ call (if there
		// is one).
		//
		// You can think of a LAB chain as being similar to a promise
		// chain.  The output of `$LAB.script()` or `$LAB.wait()` is
		// an object that itself has `script()` and `wait()` methods.
		// So long as the output of each call is used as the input for
		// the next call our code (both async loaded scripts and
		// inline JS) will be executed _in order_.
		//
		// If we start a _new_ chain directly from `$LAB` (the root
		// chain), we can wind up with _out of order_ execution.
		//
		// We want everything to be executed in order, so we maintain
		// one master chain for the page.  This chain is
		// `window._tLAB`.
		//
		res.write("_tLAB=_tLAB");
	}

	scripts.forEach(function (script) {

		if (script.href) {
			var LABScript = { src: script.href };

			if (script.crossOrigin) {
				LABScript.crossOrigin = script.crossOrigin;
			}

			// If we don't have any other options we can shave a
			// few bytes by just passing the string.
			if (Object.keys(LABScript).length === 1) {
				LABScript = LABScript.src;
			}

			if (script.condition) {
				res.write(".script(function(){if(" + script.condition + ") return " + JSON.stringify(LABScript) + "})");
			} else {
				res.write(".script(" + JSON.stringify(LABScript) + ")");
			}
		} else if (script.text) {
			if (script.condition) {
				throw new Error("Script using `text` cannot be loaded conditionally");
			}

			// The try/catch dance here is so exceptions get their
			// own time slice and can't mess with execution of the
			// LAB chain.
			//
			// The binding to `this` is so enclosed references to
			// `this` correctly get the `window` object (despite
			// being in a strict context).
			//
			res.write(".wait(function(){" + (script.strict ? '"use strict";' : '') + "try{" + script.text + "}catch(e){setTimeout(function(){throw(e)},1)}}.bind(this))");
		} else {

			throw new Error("Script needs either `href` or `text`: " + script);
		}
	});

	res.write(";</script>");
}

function renderScripts(pageObject, res) {

	// Want to gather these into one list of scripts, because we care if
	// there are any non-JS scripts in the whole bunch.
	var scripts = pageObject.getSystemScripts().concat(pageObject.getScripts());

	var thereIsAtLeastOneNonJSScript = scripts.filter(function (script) {
		return script.type && script.type !== "text/javascript";
	}).length;

	if (thereIsAtLeastOneNonJSScript) {

		// If there are non-JS scripts we can't use LAB for async
		// loading.  We still want to preserve script execution order,
		// so we'll cut over to all-synchronous loading.
		renderScriptsSync(scripts, res);
	} else {

		// Otherwise, we can do async script loading.
		renderScriptsAsync(scripts, res);
	}

	// resolve immediately.
	return Q("");
}

function renderStylesheets(pageObject, res) {

	var writeTag = function writeTag(styleSheet) {
		if (!styleSheet) {
			// skip. a promise resolving to nothing is the only way to decide
			// to not output a stylesheet if you return a promise
			return;
		}
		if (styleSheet.href) {
			res.write("<link rel=\"stylesheet\" type=\"" + styleSheet.type + "\" media=\"" + styleSheet.media + "\" href=\"" + styleSheet.href + "\" " + PAGE_CSS_NODE_ID + ">");
		} else if (styleSheet.text) {
			res.write("<style type=\"" + styleSheet.type + "\" media=\"" + styleSheet.media + "\" " + PAGE_CSS_NODE_ID + ">" + styleSheet.text + "</style>");
		} else {
			throw new Error("Style cannot be rendered because it has neither an href nor a text attribute: " + styleSheet);
		}
	};

	var styles = PageUtil.standardizeStyles(pageObject.getHeadStylesheets());

	return styles.reduce(function (prev, styleP) {
		return prev.then(function () {
			return styleP.then(writeTag);
		});
	}, Q());
}

function startBody(req, res, context, start, page) {

	var routeName = context.navigator.getCurrentRoute().name;

	return page.getBodyClasses().then(function (classes) {
		classes.push("route-" + routeName);
		res.write("<body class='" + classes.join(' ') + "'>");
	}).then(function () {
		return page.getBodyStartContent();
	}).then(function (texts) {
		return texts.forEach(function (text) {
			res.write(text);
		});
	}).then(function () {
		res.write("<div id='content' " + PAGE_CONTENT_NODE_ID + ">");
	});
}

/**
 * Writes out the ReactElements to the response. Returns a promise that fulfills when
 * all the ReactElements have been written out.
 */
function writeBody(req, res, context, start, page) {

	// standardize to an array of EarlyPromises of ReactElements
	var elementPromises = PageUtil.standardizeElements(page.getElements());

	// This is where we'll store our rendered HTML strings.  A value of
	// `undefined` means we haven't rendered that element yet.
	var rendered = elementPromises.map(function () {
		return ELEMENT_PENDING;
	});

	// We need to return a promise that resolves when we're done, so we'll
	// maintain an array of deferreds that we punch out as we render
	// elements and we'll return a promise that resolves when they've all
	// been hit.
	var dfds = elementPromises.map(function () {
		return Q.defer();
	});

	var doElement = function doElement(element, index) {

		// Exceeded `FAILSAFE_RENDER_TIMEOUT`.  Bummer.
		if (rendered[index] === ELEMENT_ALREADY_WRITTEN) return;

		rendered[index] = renderElement(res, element, context);

		// If we've just rendered the next element to be written we'll
		// write it out.
		writeElements(res, rendered);

		dfds[index].resolve();
	};

	// Render elements as their data becomes available.
	elementPromises.forEach(function (promise, index) {
		return promise.then(function (element) {
			return doElement(element, index);
		}).catch(function (e) {
			logger.error("Error rendering element " + index, e);
			// TODO: the error handling here should probably be merged
			// somehow with renderElement so that we get timing info.

			// In the case where there was an exception thrown while rendering,
			// the next three lines are effectively a no-op. In the case where
			// the element promise was rejected, this prevents a hang until
			// FAILSAFE_RENDER_TIMEOUT has passed.

			// No way we can recover in the second case, so let's just move on.
			// We'll call `writeElements` just in case everything is ready
			// after us.

			// This doesn't completely handle the extremely unlikely case that:
			//     1) `renderElement` successfully rendered this element, and
			//     2) `writeElements` successfully wrote it, but...
			//     3) `writeElements` threw after this element was written.
			//
			// We'll make a good-faith effort, but in this rare case writeElements is probably
			// going to fail again when we call it here. At least if that happens, _this_
			// particular element should show up properly on the page, even though the page
			// overall could be totally horked. And we won't have a 20s timeout...
			try {
				if (rendered[index] !== ELEMENT_ALREADY_WRITTEN) {
					rendered[index] = '';
					writeElements(res, rendered);
				}
			} finally {
				// try _really_ hard to resolve this deferred, to avoid a 20s hang.
				dfds[index].resolve();
			}
		})
		// just in case writeElements throws in our error callback above.
		.catch(function (e) {
			return logger.error("Error recovering from error rendering element " + index, e);
		});
	});

	// Some time has already elapsed since the request started.
	// Note that you can override `FAILSAFE_RENDER_TIMEOUT` with a
	// `?_debug_render_timeout={ms}` query string parameter.
	var totalWait = DebugUtil.getRenderTimeout() || FAILSAFE_RENDER_TIMEOUT,
	    timeRemaining = totalWait - (new Date() - start);

	var retval = Q.defer();
	var writeBodyDfd = Q.defer();

	// If we exceed the timeout then we'll just send empty elements for
	// anything that hadn't rendered yet.
	writeBodyDfd.promise.catch(function (err) {

		// Write out what we've got.
		writeElements(res, rendered.map(function (value) {
			return value === ELEMENT_PENDING ? '' : value;
		}));

		// If it hasn't arrived by now, we're not going to wait for it.
		RLS().lateArrivals = undefined;

		// Let the client know it's not getting any more data.
		renderScriptsAsync([{ text: "__reactServerClientController.failArrival()" }], res);

		//Log timeout error but still resolve so we continue in the lifecycle process
		logger.error("Error in writeBody", err);
		retval.resolve();
	});

	Q.all(dfds.map(function (dfd) {
		return dfd.promise;
	})).then(writeBodyDfd.resolve);

	var timeout = setTimeout(function () {
		// give some additional information when we time out
		writeBodyDfd.reject({
			message: "Timed out rendering.",
			// `timeRemaining` is how long we waited before timing out
			timeWaited: timeRemaining,
			elements: rendered.map(function (val) {
				if (val === ELEMENT_ALREADY_WRITTEN) {
					return 'W'; // written
				} else if (val === ELEMENT_PENDING) {
					return 'P'; // not rendered
				} else {
					return 'R'; // rendered, not yet written
				}
			})
		});
	}, timeRemaining);

	// Don't leave dead timers hanging around.
	writeBodyDfd.promise.then(function () {
		clearTimeout(timeout);
		//writeBody ran successfully, sweet
		retval.resolve();
	});

	return retval.promise;
}

function writeResponseData(req, res, context, start, page) {
	page.setExpressRequest(req);
	page.setExpressResponse(res);
	return page.getResponseData().then(function (data) {
		if (typeof data !== 'undefined') {
			res.write(data);
		}
	});
}

function writeDataBundle(req, res) {

	var cache = ReactServerAgent.cache();

	return Q.allSettled(cache.getPendingRequests().map(function (v) {
		return v.entry.dfd.promise;
	})).then(function () {
		return res.write(JSON.stringify(cache.dehydrate()));
	});
}

function renderElement(res, element, context) {

	if (element.containerOpen || element.containerClose || element.isTheFold) {

		// Short-circuit out.  Don't want timing for control objects.
		return element;
	}

	var name = PageUtil.getElementDisplayName(element),
	    start = RLS().startTime,
	    timer = logger.timer("renderElement.individual." + name),
	    html = '',
	    attrs = {};

	try {
		if (element !== null) {
			html = ReactDOMServer.renderToString(React.cloneElement(element, { context: context }));
			attrs = getRootElementAttributes(element);
		}
	} catch (err) {
		// A component failing to render is not fatal.  We've already
		// started the page with a 200 response.  We've even opened
		// the `data-react-server-root-id` div for this component.  We need
		// to close it out and move on.  This is a bummer, and we'll
		// log it, but it's too late to totally bail out.
		logger.error("Error with element " + name + "'s lifecycle methods", err);
	}

	// We time how long _this_ element's render took, and also how long
	// since the beginning of the request it took us to spit this element
	// out.
	var individualTime = timer.stop();
	logger.time("renderElement.fromStart." + name, new Date() - start);

	// We _also_ keep track of the _total_ time we spent rendering during
	// each request so we can keep track of that overhead.
	RLS().renderTime || (RLS().renderTime = 0);
	RLS().renderTime += individualTime;

	return { html: html, attrs: attrs };
}

// Write as many elements out in a row as possible and then flush output.
// We render elements as their data becomes available, so they might fill in
// out-of-order.
function writeElements(res, elements) {

	// Pick up where we left off.
	var start = RLS().nextElement || (RLS().nextElement = 0);

	for (var i = start; i < elements.length; RLS().nextElement = ++i) {

		// If we haven't rendered the next element yet, we're done.
		if (elements[i] === ELEMENT_PENDING) break;

		// Got one!
		writeElement(res, elements[i], i);

		// Free for GC.
		elements[i] = ELEMENT_ALREADY_WRITTEN;

		if (PageUtil.PageConfig.get('isFragment')) continue;

		if (RLS().haveBootstrapped) {

			// We've already bootstrapped, so we can immediately tell the
			// client controller to wake the new element we just sent.
			wakeElementRange(res, i, i);
		} else if (i === elements.length - 1) {

			// Page didn't emit `<TheFold/>`.  Now we're done.
			// This wakes everything up through `i`.
			bootstrapClient(res, i);
		}
	}

	// It may be a while before we render the next element, so if we just
	// wrote anything let's send it down right away.
	if (i !== start) flushRes(res);
}

function writeElement(res, element, i) {
	if (!element) {
		// A falsy element was a render error.  We've gotta
		// emit a root for it, so we'll cook up an empty
		// element object.
		element = {
			attrs: {},
			html: ''
		};
	}
	if (element.containerOpen) {
		res.write("<div " + PAGE_CONTAINER_NODE_ID + "=" + i + _.map(element.containerOpen, function (v, k) {
			return " " + k + "=\"" + attrfy(v) + "\"";
		}) + ">");
	} else if (element.containerClose) {
		res.write('</div>');
	} else if (element.isTheFold) {

		// Okay, we've sent all of our above-the-fold HTML,
		// now we can let the client start waking nodes up.
		bootstrapClient(res, i);
	} else {
		res.write("<div data-react-server-root-id=" + i + " data-react-server-timing-offset=\"" + (
		// Mark when we sent it.
		new Date() - RLS().timingDataT0) + "\"" + _.map(element.attrs, function (v, k) {
			return " " + k + "=\"" + attrfy(v) + "\"";
		}) + ">" + element.html + "</div>");
	}
}

function logAboveTheFoldTime(res) {
	// write a synchronous script to record the time on the browser when above the fold content shows up
	// this is a proxy for "first paint" when the DOM is parsed and painted
	renderScriptsSync([{ text: '__displayAboveTheFold=new Date;' + 'window.performance && window.performance.mark && window.performance.mark("displayAboveTheFold.fromStart");' }], res);
}

function bootstrapClient(res, lastElementSent) {

	logAboveTheFoldTime(res);

	if (RLS().page.getSplitJsLoad()) {
		// If we've corked our LABjs chain then we need to start executing JS.
		renderScriptsSync([{ text: '_tLAB.uncork()' }], res);
	} else if (RLS().page.getJsBelowTheFold()) {
		// Otherwise if we've deferred _all_ JS below the fold then we need to
		// kick off our fetch/load of the page JS now.
		renderScripts(RLS().page, res);
	}

	var initialContext = {
		'ReactServerAgent.cache': ReactServerAgent.cache().dehydrate(),
		'deviceType': RequestContext.getCurrentRequestContext().getDeviceType()
	};

	res.expose(initialContext, 'InitialContext');
	res.expose(getNonInternalConfigs(), "Config");

	// Using naked `rfBootstrap()` instead of `window.rfBootstrap()`
	// because the browser's error message if it isn't defined is more
	// helpful this way.  With `window.rfBootstrap()` the error is just
	// "undefined is not a function".
	renderScriptsAsync([{
		text: res.locals.state + ";rfBootstrap();"
	}], res);

	// This actually needs to happen _synchronously_ with this current
	// function to avoid letting responses slip in between.
	setupLateArrivals(res);

	wakeElementRange(res, 0, lastElementSent);

	RLS().haveBootstrapped = true;
}

function wakeElementRange(res, startIndex, endIndex) {
	endIndex = endIndex || startIndex;
	renderScriptsAsync([{
		text: "__reactServerClientController.nodeArrival(" + startIndex + "," + endIndex + ")"
	}], res);
}

function setupLateArrivals(res) {
	var start = RLS().startTime;
	var notLoaded = ReactServerAgent.cache().getPendingRequests();

	// This is for reporting purposes.  We're going to log how many late
	// requests there were, but we won't actually emit the log line until
	// all of the requests have resolved.
	ReactServerAgent.cache().markLateRequests();

	notLoaded.forEach(function (pendingRequest) {
		pendingRequest.entry.whenDataReadyInternal().then(function () {
			logger.time("lateArrival", new Date() - start);
			renderScriptsAsync([{
				text: "__reactServerClientController.dataArrival(" + JSON.stringify(pendingRequest.url) + ", " + StringEscapeUtil.escapeForScriptTag(JSON.stringify(pendingRequest.entry.dehydrate())) + ");"
			}], res);
		});
	});

	// TODO: maximum-wait-time-exceeded-so-cancel-pending-requests code
	var promises = notLoaded.map(function (result) {
		return result.entry.dfd.promise;
	});
	RLS().lateArrivals = Q.allSettled(promises);
}

function wrapUpLateArrivals() {
	return RLS().lateArrivals;
}

function closeBody(req, res) {
	// Flush timing/log data to the response document
	if (DebugUtil.getOutputLogs()) {
		flushLogsToResponse(res);
	}
	res.write("</div></body></html>");
	return Q();
}

function endResponse(req, res) {
	res.end();
	return Q();
}

function logRequestStats(req, res, context, start) {
	var allRequests = ReactServerAgent.cache().getAllRequests(),
	    notLoaded = ReactServerAgent.cache().getLateRequests(),
	    sock = req.socket,
	    stash = context.getServerStash();

	// The socket can be re-used for multiple requests with keep-alive.
	// Fortunately, until HTTP/2 rolls around, the requests over a given
	// socket will happen serially.  So we can just keep track of the
	// previous values for each socket and log the delta for a given
	// request.
	stash.bytesR = sock.bytesRead - (sock._preR || (sock._preR = 0));
	stash.bytesW = sock.bytesWritten - (sock._preW || (sock._preW = 0));

	sock._preR += stash.bytesR;
	sock._preW += stash.bytesW;

	logger.gauge("countDataRequests", allRequests.length);
	logger.gauge("countLateArrivals", notLoaded.length, { hi: 1 });
	logger.gauge("bytesRead", stash.bytesR, { hi: 1 << 12 });
	logger.gauge("bytesWritten", stash.bytesW, { hi: 1 << 18 });

	var time = new Date() - start;

	logger.time("responseCode." + res.statusCode, time);
	logger.time("totalRequestTime", time);

	// Only populated for full pages and fragments.
	if (RLS().renderTime) {
		logger.time("totalRenderTime", RLS().renderTime);
	}

	if (notLoaded.length) {
		logger.time("totalRequestTimeWithLateArrivals", time);
	}

	return Q();
}

function getNonInternalConfigs() {
	var nonInternal = {};
	var fullConfig = config();
	Object.keys(fullConfig).forEach(function (configKey) {
		if (configKey !== 'internal') {
			nonInternal[configKey] = fullConfig[configKey];
		}
	});
	return nonInternal;
}

function getDeviceType(req) {
	var md = new MobileDetect(req.get('user-agent'));

	// "mobile" is the union of "phone" and "tablet" _except_ for
	// "unknown" mobile devices, which are _neither_ phone _nor_ tablet.
	//
	// http://hgoebl.github.io/mobile-detect.js/doc/MobileDetect.html#mobile
	//
	// :rage:
	//
	// We'll call them "phone" to avoid introducing a weird third device
	// type that depends on this implementation quirk of mobile-detect.
	//
	if (md.tablet()) return "tablet";
	if (md.phone()) return "phone";
	if (md.mobile()) return "phone";
	return "desktop";
}

module.exports._testFunctions = {
	renderMetaTags: renderMetaTags,
	renderLinkTags: renderLinkTags,
	renderBaseTag: renderBaseTag
};
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlbmRlck1pZGRsZXdhcmUuanMiXSwibmFtZXMiOlsicmVxdWlyZSIsImdldExvZ2dlciIsIlJlYWN0IiwiUmVhY3RET01TZXJ2ZXIiLCJNb2JpbGVEZXRlY3QiLCJSZXF1ZXN0Q29udGV4dCIsIlJlcXVlc3RMb2NhbFN0b3JhZ2UiLCJEZWJ1Z1V0aWwiLCJSTFMiLCJnZXROYW1lc3BhY2UiLCJmbGFiIiwiUSIsImNvbmZpZyIsIkV4cHJlc3NTZXJ2ZXJSZXF1ZXN0IiwiUGFnZVV0aWwiLCJSZWFjdFNlcnZlckFnZW50IiwiU3RyaW5nRXNjYXBlVXRpbCIsImdldFJvb3RFbGVtZW50QXR0cmlidXRlcyIsIlBBR0VfQ1NTX05PREVfSUQiLCJQQUdFX0xJTktfTk9ERV9JRCIsIlBBR0VfQ09OVEVOVF9OT0RFX0lEIiwiUEFHRV9DT05UQUlORVJfTk9ERV9JRCIsImZsdXNoTG9nc1RvUmVzcG9uc2UiLCJfIiwibWFwIiwiRkFJTFNBRkVfUkVOREVSX1RJTUVPVVQiLCJGQUlMU0FGRV9ST1VURVJfVElNRU9VVCIsIkFDVElWRV9SRVFVRVNUUyIsIkVMRU1FTlRfUEVORElORyIsIkVMRU1FTlRfQUxSRUFEWV9XUklUVEVOIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcSIsInJlcyIsIm5leHQiLCJyb3V0ZXMiLCJzdGFydFJlcXVlc3QiLCJzdGFydCIsInN0YXJ0VGltZSIsIkRhdGUiLCJzdGFydEhSIiwicHJvY2VzcyIsImhydGltZSIsImxvZ2dlciIsImRlYnVnIiwicGF0aCIsImluaXRSZXNwb25zZUNvbXBsZXRlUHJvbWlzZSIsIm9yaWdXcml0ZSIsIndyaXRlIiwiZmluaXNoZWQiLCJhcHBseSIsImFyZ3VtZW50cyIsImVycm9yIiwic3RhY2siLCJjb250ZXh0IiwiQnVpbGRlciIsInNldFJvdXRlcyIsInNldERlZmF1bHRYaHJIZWFkZXJzRnJvbVJlcXVlc3QiLCJjcmVhdGUiLCJzZXRTZXJ2ZXJTdGFzaCIsInNldERldmljZVR5cGUiLCJnZXREZXZpY2VUeXBlIiwibmF2aWdhdGVEZmQiLCJkZWZlciIsIm9uTmF2aWdhdGUiLCJlcnIiLCJwYWdlIiwicHJvbWlzZSIsImlzUGVuZGluZyIsInJlc29sdmUiLCJkb25lIiwiZ2V0SGFzRG9jdW1lbnQiLCJzdGF0dXMiLCJyZWRpcmVjdCIsInJlZGlyZWN0VXJsIiwic2V0IiwibG9nIiwiaGFuZGxlUmVzcG9uc2VDb21wbGV0ZSIsInJlbmRlclBhZ2UiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsInJlamVjdCIsInRoZW4iLCJjbGVhclRpbWVvdXQiLCJjYXRjaCIsIm5hdmlnYXRvciIsImdldEN1cnJlbnRSb3V0ZSIsIm5hbWUiLCJuYXZpZ2F0ZSIsImdldEFjdGl2ZVJlcXVlc3RzIiwiZGZkIiwib24iLCJyZXNwb25zZUNvbXBsZXRlUHJvbWlzZSIsImJpbmQiLCJsb2dSZXF1ZXN0U3RhdHMiLCJoYW5kbGVDb21wbGV0ZSIsInJvdXRlTmFtZSIsInRpbWVyIiwiZ2V0U3RhdHVzIiwibGlmZWN5Y2xlTWV0aG9kcyIsIlBhZ2VDb25maWciLCJnZXQiLCJmcmFnbWVudExpZmVjeWNsZSIsInJhd1Jlc3BvbnNlTGlmZWN5Y2xlIiwicXVlcnkiLCJEQVRBX0JVTkRMRV9QQVJBTUVURVIiLCJkYXRhQnVuZGxlTGlmZWN5Y2xlIiwicGFnZUxpZmVjeWNsZSIsInJlZHVjZSIsImNoYWluIiwiZnVuYyIsInRpY2siLCJ0aW1lIiwiZW5kIiwic2V0SHR0cEhlYWRlcnMiLCJzZXRDb250ZW50VHlwZSIsIndyaXRlUmVzcG9uc2VEYXRhIiwiZW5kUmVzcG9uc2UiLCJ3cml0ZURlYnVnQ29tbWVudHMiLCJ3cml0ZUJvZHkiLCJzZXREYXRhQnVuZGxlQ29udGVudFR5cGUiLCJ3cml0ZURhdGFCdW5kbGUiLCJ3cml0ZUhlYWRlciIsInN0YXJ0Qm9keSIsIndyYXBVcExhdGVBcnJpdmFscyIsImNsb3NlQm9keSIsInBhZ2VPYmplY3QiLCJoYW5kbGVyIiwiaGVhZGVyIiwiZ2V0SGVhZGVycyIsImhlYWRlcnMiLCJmb3JFYWNoIiwiZ2V0Q29udGVudFR5cGUiLCJ0aW1pbmdEYXRhVDAiLCJ0eXBlIiwiYWxsIiwicmVuZGVyRGVidWdDb21tZW50cyIsInJlbmRlclRpdGxlIiwiZ2V0SnNCZWxvd1RoZUZvbGQiLCJnZXRTcGxpdEpzTG9hZCIsInJlbmRlclNjcmlwdHMiLCJyZW5kZXJTdHlsZXNoZWV0cyIsInJlbmRlck1ldGFUYWdzIiwicmVuZGVyTGlua1RhZ3MiLCJyZW5kZXJCYXNlVGFnIiwiZmx1c2hSZXMiLCJmbHVzaCIsImRpZExvZ0ZpcnN0Rmx1c2giLCJkZWJ1Z0NvbW1lbnRzIiwiZ2V0RGVidWdDb21tZW50cyIsImRlYnVnQ29tbWVudCIsImxhYmVsIiwidmFsdWUiLCJ3YXJuaW5nIiwiZ2V0VGl0bGUiLCJ0aXRsZSIsImF0dHJmeSIsInJlcGxhY2UiLCJtZXRhVGFncyIsImdldE1ldGFUYWdzIiwibWV0YVRhZ3NSZW5kZXJlZCIsIm1ldGFUYWdQcm9taXNlIiwibWFrZUFycmF5IiwibWV0YVRhZyIsImh0dHBFcXVpdiIsImNoYXJzZXQiLCJFcnJvciIsImNvbnRlbnQiLCJub3NjcmlwdCIsInByb3BlcnR5IiwibGlua1RhZ3MiLCJnZXRMaW5rVGFncyIsImxpbmtUYWdzUmVuZGVyZWQiLCJsaW5rVGFnUHJvbWlzZSIsImxpbmtUYWciLCJyZWwiLCJPYmplY3QiLCJrZXlzIiwiYXR0ciIsImpvaW4iLCJnZXRCYXNlIiwiYmFzZSIsImhyZWYiLCJ0YXJnZXQiLCJ0YWciLCJyZW5kZXJTY3JpcHRzU3luYyIsInNjcmlwdHMiLCJzY3JpcHQiLCJ0ZXh0IiwicmVuZGVyU2NyaXB0c0FzeW5jIiwibGVuZ3RoIiwiZGlkTG9hZExBQiIsImdsb2JhbERlZmF1bHRzIiwiQWx3YXlzUHJlc2VydmVPcmRlciIsIlVzZUNPUlNYSFIiLCJnZXRMYWIiLCJzcmMiLCJtaW4iLCJKU09OIiwic3RyaW5naWZ5IiwiTEFCU2NyaXB0IiwiY3Jvc3NPcmlnaW4iLCJjb25kaXRpb24iLCJzdHJpY3QiLCJnZXRTeXN0ZW1TY3JpcHRzIiwiY29uY2F0IiwiZ2V0U2NyaXB0cyIsInRoZXJlSXNBdExlYXN0T25lTm9uSlNTY3JpcHQiLCJmaWx0ZXIiLCJ3cml0ZVRhZyIsInN0eWxlU2hlZXQiLCJtZWRpYSIsInN0eWxlcyIsInN0YW5kYXJkaXplU3R5bGVzIiwiZ2V0SGVhZFN0eWxlc2hlZXRzIiwicHJldiIsInN0eWxlUCIsImdldEJvZHlDbGFzc2VzIiwiY2xhc3NlcyIsInB1c2giLCJnZXRCb2R5U3RhcnRDb250ZW50IiwidGV4dHMiLCJlbGVtZW50UHJvbWlzZXMiLCJzdGFuZGFyZGl6ZUVsZW1lbnRzIiwiZ2V0RWxlbWVudHMiLCJyZW5kZXJlZCIsImRmZHMiLCJkb0VsZW1lbnQiLCJlbGVtZW50IiwiaW5kZXgiLCJyZW5kZXJFbGVtZW50Iiwid3JpdGVFbGVtZW50cyIsImUiLCJ0b3RhbFdhaXQiLCJnZXRSZW5kZXJUaW1lb3V0IiwidGltZVJlbWFpbmluZyIsInJldHZhbCIsIndyaXRlQm9keURmZCIsImxhdGVBcnJpdmFscyIsInVuZGVmaW5lZCIsIm1lc3NhZ2UiLCJ0aW1lV2FpdGVkIiwiZWxlbWVudHMiLCJ2YWwiLCJzZXRFeHByZXNzUmVxdWVzdCIsInNldEV4cHJlc3NSZXNwb25zZSIsImdldFJlc3BvbnNlRGF0YSIsImRhdGEiLCJjYWNoZSIsImFsbFNldHRsZWQiLCJnZXRQZW5kaW5nUmVxdWVzdHMiLCJ2IiwiZW50cnkiLCJkZWh5ZHJhdGUiLCJjb250YWluZXJPcGVuIiwiY29udGFpbmVyQ2xvc2UiLCJpc1RoZUZvbGQiLCJnZXRFbGVtZW50RGlzcGxheU5hbWUiLCJodG1sIiwiYXR0cnMiLCJyZW5kZXJUb1N0cmluZyIsImNsb25lRWxlbWVudCIsImluZGl2aWR1YWxUaW1lIiwic3RvcCIsInJlbmRlclRpbWUiLCJuZXh0RWxlbWVudCIsImkiLCJ3cml0ZUVsZW1lbnQiLCJoYXZlQm9vdHN0cmFwcGVkIiwid2FrZUVsZW1lbnRSYW5nZSIsImJvb3RzdHJhcENsaWVudCIsImsiLCJsb2dBYm92ZVRoZUZvbGRUaW1lIiwibGFzdEVsZW1lbnRTZW50IiwiaW5pdGlhbENvbnRleHQiLCJnZXRDdXJyZW50UmVxdWVzdENvbnRleHQiLCJleHBvc2UiLCJnZXROb25JbnRlcm5hbENvbmZpZ3MiLCJsb2NhbHMiLCJzdGF0ZSIsInNldHVwTGF0ZUFycml2YWxzIiwic3RhcnRJbmRleCIsImVuZEluZGV4Iiwibm90TG9hZGVkIiwibWFya0xhdGVSZXF1ZXN0cyIsInBlbmRpbmdSZXF1ZXN0Iiwid2hlbkRhdGFSZWFkeUludGVybmFsIiwidXJsIiwiZXNjYXBlRm9yU2NyaXB0VGFnIiwicHJvbWlzZXMiLCJyZXN1bHQiLCJnZXRPdXRwdXRMb2dzIiwiYWxsUmVxdWVzdHMiLCJnZXRBbGxSZXF1ZXN0cyIsImdldExhdGVSZXF1ZXN0cyIsInNvY2siLCJzb2NrZXQiLCJzdGFzaCIsImdldFNlcnZlclN0YXNoIiwiYnl0ZXNSIiwiYnl0ZXNSZWFkIiwiX3ByZVIiLCJieXRlc1ciLCJieXRlc1dyaXR0ZW4iLCJfcHJlVyIsImdhdWdlIiwiaGkiLCJzdGF0dXNDb2RlIiwibm9uSW50ZXJuYWwiLCJmdWxsQ29uZmlnIiwiY29uZmlnS2V5IiwibWQiLCJ0YWJsZXQiLCJwaG9uZSIsIm1vYmlsZSIsIl90ZXN0RnVuY3Rpb25zIl0sIm1hcHBpbmdzIjoiOztBQUNJLGFBQVNBLFFBQVEsV0FBUixFQUFxQkMsU0FBckIsQ0FBK0IsRUFBQyxRQUFPLG9DQUFSLEVBQTZDLFNBQVEsRUFBQyxVQUFTLEdBQVYsRUFBYyxVQUFTLGlCQUF2QixFQUFyRCxFQUEvQixDQUFUO0FBQUEsSUFDSEMsS0FERyxHQUNLRixRQUFRLE9BQVIsQ0FETDtBQUFBLElBRUhHLGNBRkcsR0FFY0gsUUFBUSxrQkFBUixDQUZkO0FBQUEsSUFHSEksWUFIRyxHQUdZSixRQUFRLGVBQVIsQ0FIWjtBQUFBLElBSUhLLGNBSkcsR0FJY0wsUUFBUSwwQkFBUixDQUpkO0FBQUEsSUFLSE0sbUJBTEcsR0FLbUJOLFFBQVEsNEJBQVIsQ0FMbkI7QUFBQSxJQU1ITyxTQU5HLEdBTVNQLFFBQVEsa0JB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ck1pZGRsZXdhcmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBsb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dpbmcnKS5nZXRMb2dnZXIoe1wibmFtZVwiOlwicmVhY3Qtc2VydmVyLmNvcmUucmVuZGVyTWlkZGxld2FyZVwiLFwiY29sb3JcIjp7XCJzZXJ2ZXJcIjoyMDcsXCJjbGllbnRcIjpcInJnYigyMTIsNDIsMjEyKVwifX0pLFxuXHRSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0JyksXG5cdFJlYWN0RE9NU2VydmVyID0gcmVxdWlyZSgncmVhY3QtZG9tL3NlcnZlcicpLFxuXHRNb2JpbGVEZXRlY3QgPSByZXF1aXJlKCdtb2JpbGUtZGV0ZWN0JyksXG5cdFJlcXVlc3RDb250ZXh0ID0gcmVxdWlyZSgnLi9jb250ZXh0L1JlcXVlc3RDb250ZXh0JyksXG5cdFJlcXVlc3RMb2NhbFN0b3JhZ2UgPSByZXF1aXJlKCcuL3V0aWwvUmVxdWVzdExvY2FsU3RvcmFnZScpLFxuXHREZWJ1Z1V0aWwgPSByZXF1aXJlKCcuL3V0aWwvRGVidWdVdGlsJyksXG5cdFJMUyA9IFJlcXVlc3RMb2NhbFN0b3JhZ2UuZ2V0TmFtZXNwYWNlKCksXG5cdGZsYWIgPSByZXF1aXJlKCdmbGFiJyksXG5cdFEgPSByZXF1aXJlKCdxJyksXG5cdGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyksXG5cdEV4cHJlc3NTZXJ2ZXJSZXF1ZXN0ID0gcmVxdWlyZShcIi4vRXhwcmVzc1NlcnZlclJlcXVlc3RcIiksXG5cblx0UGFnZVV0aWwgPSByZXF1aXJlKCcuL3V0aWwvUGFnZVV0aWwnKSxcblx0UmVhY3RTZXJ2ZXJBZ2VudCA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJBZ2VudCcpLFxuXHRTdHJpbmdFc2NhcGVVdGlsID0gcmVxdWlyZSgnLi91dGlsL1N0cmluZ0VzY2FwZVV0aWwnKSxcblx0e2dldFJvb3RFbGVtZW50QXR0cmlidXRlc30gPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvUm9vdEVsZW1lbnQnKSxcblx0e1BBR0VfQ1NTX05PREVfSUQsIFBBR0VfTElOS19OT0RFX0lELCBQQUdFX0NPTlRFTlRfTk9ERV9JRCwgUEFHRV9DT05UQUlORVJfTk9ERV9JRH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLFxuXHR7Zmx1c2hMb2dzVG9SZXNwb25zZX0gPSByZXF1aXJlKCcuL2xvZ2dpbmcvcmVzcG9uc2UnKTtcblxudmFyIF8gPSB7XG5cdG1hcDogcmVxdWlyZSgnbG9kYXNoL21hcCcpLFxufTtcblxuLy8gVE9ETyBGSVhNRSA/P1xuLy8gSXQgKm1pZ2h0KiBiZSB3b3J0aHdoaWxlIHRvIGdldCByaWQgb2YgYWxsIHRoZSBjbG9zdXJlLXkgdGhpbmdzIGluIHJlbmRlcigpXG4vLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9zcGVlZC9hcnRpY2xlcy9vcHRpbWl6aW5nLWphdmFzY3JpcHRcblxuLy8gSWYgYW4gZWxlbWVudCBoYXNuJ3QgcmVuZGVyZWQgaW4gdGhpcyBsb25nIGl0IGdldHMgdGhlIGF4ZS5cbnZhciBGQUlMU0FGRV9SRU5ERVJfVElNRU9VVCA9IDIwZTM7XG5cbi8vIElmIGEgcGFnZSdzIGBoYW5kbGVSb3V0ZWAgZmFpbHMgdG8gcmVzb2x2ZSB0aGlzIGZhc3QgaXQgZ2V0cyB0aGUgYXhlLlxudmFyIEZBSUxTQUZFX1JPVVRFUl9USU1FT1VUID0gMjBlMztcblxuLy8gV2UnbGwgdXNlIHRoaXMgZm9yIGtlZXBpbmcgdHJhY2sgb2YgcmVxdWVzdCBjb25jdXJyZW5jeSBwZXIgd29ya2VyLlxudmFyIEFDVElWRV9SRVFVRVNUUyA9IDA7XG5cbi8vIFNvbWUgbm9uLWNvbnRlbnQgaXRlbXMgdGhhdCBjYW4gbGl2ZSBpbiB0aGUgZWxlbWVudHMgYXJyYXkuXG52YXIgRUxFTUVOVF9QRU5ESU5HICAgICAgICAgPSAtMTtcbnZhciBFTEVNRU5UX0FMUkVBRFlfV1JJVFRFTiA9IC0yO1xuXG4vKipcbiAqIHJlbmRlck1pZGRsZXdhcmUgZW50cnlwb2ludC4gQ2FsbGVkIGJ5IGV4cHJlc3MgZm9yIGV2ZXJ5IHJlcXVlc3QuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocmVxLCByZXMsIG5leHQsIHJvdXRlcykge1xuXHRSZXF1ZXN0TG9jYWxTdG9yYWdlLnN0YXJ0UmVxdWVzdCgoKSA9PiB7XG5cdFx0QUNUSVZFX1JFUVVFU1RTKys7XG5cblx0XHR2YXIgc3RhcnQgPSBSTFMoKS5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuXHRcdHZhciBzdGFydEhSID0gcHJvY2Vzcy5ocnRpbWUoKTtcblxuXHRcdGxvZ2dlci5kZWJ1ZyhgSW5jb21pbmcgcmVxdWVzdCBmb3IgJHtyZXEucGF0aH1gKTtcblxuXHRcdGluaXRSZXNwb25zZUNvbXBsZXRlUHJvbWlzZShyZXMpO1xuXG5cdFx0Ly8gbW9ua2V5LXBhdGNoIGByZXMud3JpdGVgIHNvIHRoYXQgd2UgZG9uJ3QgdHJ5IHRvIHdyaXRlIHRvIHRoZSBzdHJlYW0gaWYgaXQnc1xuXHRcdC8vIGFscmVhZHkgY2xvc2VkXG5cdFx0dmFyIG9yaWdXcml0ZSA9IHJlcy53cml0ZTtcblx0XHRyZXMud3JpdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIXJlcy5maW5pc2hlZCkge1xuXHRcdFx0XHRvcmlnV3JpdGUuYXBwbHkocmVzLCBhcmd1bWVudHMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bG9nZ2VyLmVycm9yKFwiQXR0ZW1wdGVkIHdyaXRlIGFmdGVyIHJlc3BvbnNlIGZpbmlzaGVkXCIsIHsgcGF0aDogcmVxICYmIHJlcS5wYXRoIHx8IFwidW5rbm93blwiLCBzdGFjazogbG9nZ2VyLnN0YWNrKCkgfSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIFRPRE8/IHB1bGwgdGhpcyBjb250ZXh0IGJ1aWxkaW5nIGludG8gaXRzIG93biBtaWRkbGV3YXJlXG5cdFx0dmFyIGNvbnRleHQgPSBuZXcgUmVxdWVzdENvbnRleHQuQnVpbGRlcigpXG5cdFx0XHRcdC5zZXRSb3V0ZXMocm91dGVzKVxuXHRcdFx0XHQuc2V0RGVmYXVsdFhockhlYWRlcnNGcm9tUmVxdWVzdChyZXEpXG5cdFx0XHRcdC5jcmVhdGUoe1xuXHRcdFx0XHRcdC8vIFRPRE86IGNvbnRleHQgb3B0cz9cblx0XHRcdFx0fSk7XG5cblx0XHQvLyBOZWVkIHRoaXMgc3R1ZmYgaW4gZm9yIGxvZ2dpbmcuXG5cdFx0Y29udGV4dC5zZXRTZXJ2ZXJTdGFzaCh7IHJlcSwgcmVzLCBzdGFydCwgc3RhcnRIUiB9KTtcblxuXHRcdGNvbnRleHQuc2V0RGV2aWNlVHlwZShnZXREZXZpY2VUeXBlKHJlcSkpO1xuXG5cdFx0dmFyIG5hdmlnYXRlRGZkID0gUS5kZWZlcigpO1xuXG5cdFx0Ly8gc2V0dXAgbmF2aWdhdGlvbiBoYW5kbGVyIChUT0RPOiBzaG91bGQgd2UgaGF2ZSBhICdvbmNlJyB2ZXJzaW9uPylcblx0XHRjb250ZXh0Lm9uTmF2aWdhdGUoIChlcnIsIHBhZ2UpID0+IHtcblxuXHRcdFx0aWYgKCFuYXZpZ2F0ZURmZC5wcm9taXNlLmlzUGVuZGluZygpKSB7XG5cdFx0XHRcdGxvZ2dlci5lcnJvcihcIkZpbmlzaGVkIG5hdmlnYXRpb24gYWZ0ZXIgRkFJTFNBRkVfUk9VVEVSX1RJTUVPVVRcIiwge1xuXHRcdFx0XHRcdHBhZ2U6IGNvbnRleHQucGFnZSxcblx0XHRcdFx0XHRwYXRoOiByZXEucGF0aCxcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VjY2Vzcy5cblx0XHRcdG5hdmlnYXRlRGZkLnJlc29sdmUoKTtcblxuXG5cdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdC8vIFRoZSBwYWdlIGNhbiBlbGVjdCB0byBwcm9jZWVkIHRvIHJlbmRlclxuXHRcdFx0XHQvLyBldmVuIHdpdGggYSBub24tMnh4IHJlc3BvbnNlLiAgSWYgaXRcblx0XHRcdFx0Ly8gX2RvZXNuJ3RfIGRvIHNvIHRoZW4gd2UncmUgZG9uZS5cblx0XHRcdFx0dmFyIGRvbmUgPSAhKHBhZ2UgJiYgcGFnZS5nZXRIYXNEb2N1bWVudCgpKTtcblxuXHRcdFx0XHRpZiAoZXJyLnN0YXR1cyA9PT0gMzAxIHx8IGVyci5zdGF0dXMgPT09IDMwMiB8fCBlcnIuc3RhdHVzID09PSAzMDcpIHtcblx0XHRcdFx0XHRpZiAoZG9uZSl7XG5cdFx0XHRcdFx0XHQvLyBUaGlzIGFkZHMgYSBib2lsZXJwbGF0ZSBib2R5LlxuXHRcdFx0XHRcdFx0cmVzLnJlZGlyZWN0KGVyci5zdGF0dXMsIGVyci5yZWRpcmVjdFVybCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFRoaXMgZXhwZWN0cyBvdXIgcGFnZSB0b1xuXHRcdFx0XHRcdFx0Ly8gcmVuZGVyIGEgYm9keS4gIEhvcGUgdGhleVxuXHRcdFx0XHRcdFx0Ly8ga25vdyB3aGF0IHRoZXkncmUgZG9pbmcuXG5cdFx0XHRcdFx0XHRyZXMuc2V0KCdMb2NhdGlvbicsIGVyci5yZWRpcmVjdFVybCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGRvbmUpIHtcblx0XHRcdFx0XHRpZiAoZXJyLnN0YXR1cyA9PT0gNDA0KSB7XG5cdFx0XHRcdFx0XHRuZXh0KCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5leHQoZXJyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGRvbmUpIHtcblx0XHRcdFx0XHRsb2dnZXIubG9nKFwib25OYXZpZ2F0ZSByZWNlaXZlZCBhIG5vbi0yeHggSFRUUCBjb2RlXCIsIGVycik7XG5cdFx0XHRcdFx0aGFuZGxlUmVzcG9uc2VDb21wbGV0ZShyZXEsIHJlcywgY29udGV4dCwgc3RhcnQsIHBhZ2UpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVuZGVyUGFnZShyZXEsIHJlcywgY29udGV4dCwgc3RhcnQsIHBhZ2UpO1xuXG5cdFx0fSk7XG5cblxuXHRcdGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KG5hdmlnYXRlRGZkLnJlamVjdCwgRkFJTFNBRkVfUk9VVEVSX1RJTUVPVVQpO1xuXG5cdFx0Ly8gRG9uJ3QgbGVhdmUgZGVhZCB0aW1lcnMgaGFuZ2luZyBhcm91bmQuXG5cdFx0bmF2aWdhdGVEZmQucHJvbWlzZS50aGVuKCgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KSk7XG5cblx0XHQvLyBJZiB3ZSBmYWlsIHRvIG5hdmlnYXRlLCB3ZSdsbCB0aHJvdyBhIDUwMCBhbmQgbW92ZSBvbi5cblx0XHRuYXZpZ2F0ZURmZC5wcm9taXNlLmNhdGNoKCgpID0+IHtcblx0XHRcdGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBuYXZpZ2F0ZSBhZnRlciBGQUlMU0FGRV9ST1VURVJfVElNRU9VVFwiLCB7XG5cdFx0XHRcdHBhZ2U6IGNvbnRleHQubmF2aWdhdG9yLmdldEN1cnJlbnRSb3V0ZSgpLm5hbWUsXG5cdFx0XHRcdHBhdGg6IHJlcS5wYXRoLFxuXHRcdFx0fSk7XG5cdFx0XHRoYW5kbGVSZXNwb25zZUNvbXBsZXRlKHJlcSwgcmVzLCBjb250ZXh0LCBzdGFydCwgY29udGV4dC5wYWdlKTtcblx0XHRcdG5leHQoe3N0YXR1czogNTAwfSk7XG5cdFx0fSk7XG5cblx0XHRjb250ZXh0Lm5hdmlnYXRlKG5ldyBFeHByZXNzU2VydmVyUmVxdWVzdChyZXEpKTtcblxuXHR9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldEFjdGl2ZVJlcXVlc3RzID0gKCkgPT4gQUNUSVZFX1JFUVVFU1RTO1xuXG5mdW5jdGlvbiBpbml0UmVzcG9uc2VDb21wbGV0ZVByb21pc2UocmVzKXtcblx0dmFyIGRmZCA9IFEuZGVmZXIoKTtcblxuXHRyZXMub24oJ2Nsb3NlJywgIGRmZC5yZXNvbHZlKTtcblx0cmVzLm9uKCdmaW5pc2gnLCBkZmQucmVzb2x2ZSk7XG5cblx0UkxTKCkucmVzcG9uc2VDb21wbGV0ZVByb21pc2UgPSBkZmQucHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2VDb21wbGV0ZShyZXEsIHJlcywgY29udGV4dCwgc3RhcnQsIHBhZ2UpIHtcblxuXHRSTFMoKS5yZXNwb25zZUNvbXBsZXRlUHJvbWlzZS50aGVuKFJlcXVlc3RMb2NhbFN0b3JhZ2UuYmluZCgoKSA9PiB7XG5cblx0XHQvLyBBbGwgaW50ZW50aW9uYWwgcmVzcG9uc2UgY29tcGxldGlvbiBzaG91bGQgZnVubmVsIHRocm91Z2hcblx0XHQvLyB0aGlzIGZ1bmN0aW9uLiAgSWYgdGhpcyB2YWx1ZSBzdGFydHMgY2xpbWJpbmcgZ3JhZHVhbGx5XG5cdFx0Ly8gdGhhdCdzIGFuIGluZGljYXRpb24gdGhhdCB3ZSBoYXZlIHNvbWUgX3VuaW50ZW50aW9uYWxfXG5cdFx0Ly8gcmVzcG9uc2UgY29tcGxldGlvbiBnb2luZyBvbiB0aGF0IHdlIHNob3VsZCBkZWFsIHdpdGguXG5cdFx0QUNUSVZFX1JFUVVFU1RTLS07XG5cblx0XHQvLyBOb3RlIHRoYXQgaWYgdGhlIG5hdmlnYXRvciBjb3VsZG4ndCBldmVuIG1hcCB0aGUgcmVxdWVzdCB0b1xuXHRcdC8vIGEgcGFnZSwgd2Ugd29uJ3QgYmUgYWJsZSB0byBjYWxsIG1pZGRsZXdhcmVcblx0XHQvLyBgaGFuZGxlQ29tcGxldGUoKWAgaGVyZS5cblx0XHQvL1xuXHRcdGlmIChwYWdlKSB7XG5cdFx0XHRsb2dSZXF1ZXN0U3RhdHMocmVxLCByZXMsIGNvbnRleHQsIHN0YXJ0LCBwYWdlKTtcblxuXHRcdFx0cGFnZS5oYW5kbGVDb21wbGV0ZSgpO1xuXHRcdH1cblx0fSkpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJQYWdlKHJlcSwgcmVzLCBjb250ZXh0LCBzdGFydCwgcGFnZSkge1xuXG5cdHZhciByb3V0ZU5hbWUgPSBjb250ZXh0Lm5hdmlnYXRvci5nZXRDdXJyZW50Um91dGUoKS5uYW1lO1xuXG5cdGxvZ2dlci5kZWJ1ZyhcIlJvdXRlIE5hbWU6IFwiICsgcm91dGVOYW1lKTtcblxuXHR2YXIgdGltZXIgPSBsb2dnZXIudGltZXIoXCJsaWZlY3ljbGUuaW5kaXZpZHVhbFwiKTtcblxuXHQvLyBQcm90ZWN0cyBzb21lIGJyb3dzZXJzIChDaHJvbWUsIElFKSBhZ2FpbnN0IE1JTUUgc25pZmZpbmcgYXR0YWNrcy5cblx0Ly8gc2VlOiBodHRwOi8vc2VjdXJpdHkuc3RhY2tleGNoYW5nZS5jb20vYS8xMjkxNlxuXHRyZXMuc2V0KCdYLUNvbnRlbnQtVHlwZS1PcHRpb25zJywgJ25vc25pZmYnKTtcblxuXHRyZXMuc3RhdHVzKHBhZ2UuZ2V0U3RhdHVzKCl8fDIwMCk7XG5cblx0Ly8gSGFuZHkgdG8gaGF2ZSByYW5kb20gYWNjZXNzIHRvIHRoaXMgcmF0aGVyIHRoYW4gbmVlZGluZyB0byB0aHJlYWQgaXRcblx0Ly8gdGhyb3VnaCBldmVyeXdoZXJlLlxuXHRSTFMoKS5wYWdlID0gcGFnZTtcblxuXHQvLyBFYWNoIG9mIHRoZXNlIGZ1bmN0aW9ucyBoYXMgdGhlIHNhbWUgc2lnbmF0dXJlIGFuZCByZXR1cm5zIGFcblx0Ly8gcHJvbWlzZSwgc28gd2UgY2FuIGNoYWluIHRoZW0gdXAgd2l0aCBhIHByb21pc2UgcmVkdWN0aW9uLlxuXHR2YXIgbGlmZWN5Y2xlTWV0aG9kcztcblx0aWYgKFBhZ2VVdGlsLlBhZ2VDb25maWcuZ2V0KCdpc0ZyYWdtZW50Jykpe1xuXHRcdGxpZmVjeWNsZU1ldGhvZHMgPSBmcmFnbWVudExpZmVjeWNsZSgpO1xuXHR9IGVsc2UgaWYgKFBhZ2VVdGlsLlBhZ2VDb25maWcuZ2V0KCdpc1Jhd1Jlc3BvbnNlJykpe1xuXHRcdGxpZmVjeWNsZU1ldGhvZHMgPSByYXdSZXNwb25zZUxpZmVjeWNsZSgpO1xuXHR9IGVsc2UgaWYgKHJlcS5xdWVyeVtSZWFjdFNlcnZlckFnZW50LkRBVEFfQlVORExFX1BBUkFNRVRFUl0pIHtcblx0XHRsaWZlY3ljbGVNZXRob2RzID0gZGF0YUJ1bmRsZUxpZmVjeWNsZSgpO1xuXHR9IGVsc2Uge1xuXHRcdGxpZmVjeWNsZU1ldGhvZHMgPSBwYWdlTGlmZWN5Y2xlKCk7XG5cdH1cblxuXHRsaWZlY3ljbGVNZXRob2RzLnJlZHVjZSgoY2hhaW4sIGZ1bmMpID0+IGNoYWluXG5cdFx0LnRoZW4oKCkgPT4gZnVuYyhyZXEsIHJlcywgY29udGV4dCwgc3RhcnQsIHBhZ2UpKVxuXHRcdC50aGVuKCgpID0+IHtcblx0XHRcdHRpbWVyLnRpY2soZnVuYy5uYW1lKTtcblx0XHRcdGxvZ2dlci50aW1lKGBsaWZlY3ljbGUuZnJvbVN0YXJ0LiR7ZnVuYy5uYW1lfWAsIG5ldyBEYXRlIC0gc3RhcnQpO1xuXHRcdH0pXG5cdCkuY2F0Y2goZXJyID0+IHtcblx0XHRsb2dnZXIuZXJyb3IoXCJFcnJvciBpbiByZW5kZXJQYWdlIGNoYWluXCIsIGVycilcblxuXHRcdC8vIFJlZ2lzdGVyIGBmaW5pc2hgIGxpc3RlbmVyIGJlZm9yZSBlbmRpbmcgcmVzcG9uc2UuXG5cdFx0aGFuZGxlUmVzcG9uc2VDb21wbGV0ZShyZXEsIHJlcywgY29udGV4dCwgc3RhcnQsIHBhZ2UpO1xuXG5cdFx0Ly8gQnVtbWVyLlxuXHRcdHJlcy5zdGF0dXMoNTAwKS5lbmQoKTtcblx0fSk7XG5cblx0Ly8gVE9ETzogd2UgcHJvYmFibHkgd2FudCBhIFwid2UncmUgbm90IHdhaXRpbmcgYW55IGxvbmdlciBmb3IgdGhpc1wiXG5cdC8vIHRpbWVvdXQgYXMgd2VsbCwgYW5kIGNhbmNlbCB0aGUgd2FpdGluZyBkZWZlcnJlZHNcbn1cblxuZnVuY3Rpb24gcmF3UmVzcG9uc2VMaWZlY3ljbGUgKCkge1xuXHRyZXR1cm4gW1xuXHRcdFEoKSwgLy8gTk9PUCBsZWFkLWluIHRvIHByaW1lIHRoZSByZWR1Y3Rpb25cblx0XHRzZXRIdHRwSGVhZGVycyxcblx0XHRzZXRDb250ZW50VHlwZSxcblx0XHR3cml0ZVJlc3BvbnNlRGF0YSxcblx0XHRoYW5kbGVSZXNwb25zZUNvbXBsZXRlLFxuXHRcdGVuZFJlc3BvbnNlLFxuXHRdO1xufVxuXG5mdW5jdGlvbiBmcmFnbWVudExpZmVjeWNsZSAoKSB7XG5cdHJldHVybiBbXG5cdFx0USgpLCAvLyBOT09QIGxlYWQtaW4gdG8gcHJpbWUgdGhlIHJlZHVjdGlvblxuXHRcdHNldEh0dHBIZWFkZXJzLFxuXHRcdHdyaXRlRGVidWdDb21tZW50cyxcblx0XHR3cml0ZUJvZHksXG5cdFx0aGFuZGxlUmVzcG9uc2VDb21wbGV0ZSxcblx0XHRlbmRSZXNwb25zZSxcblx0XTtcbn1cblxuZnVuY3Rpb24gZGF0YUJ1bmRsZUxpZmVjeWNsZSAoKSB7XG5cdHJldHVybiBbXG5cdFx0USgpLCAvLyBOT09QIGxlYWQtaW4gdG8gcHJpbWUgdGhlIHJlZHVjdGlvblxuXHRcdHNldERhdGFCdW5kbGVDb250ZW50VHlwZSxcblx0XHR3cml0ZURhdGFCdW5kbGUsXG5cdFx0aGFuZGxlUmVzcG9uc2VDb21wbGV0ZSxcblx0XHRlbmRSZXNwb25zZSxcblx0XTtcbn1cblxuZnVuY3Rpb24gcGFnZUxpZmVjeWNsZSgpIHtcblx0cmV0dXJuIFtcblx0XHRRKCksIC8vIFRoaXMgaXMganVzdCBhIE5PT1AgbGVhZC1pbiB0byBwcmltZSB0aGUgcmVkdWN0aW9uLlxuXHRcdHNldEh0dHBIZWFkZXJzLFxuXHRcdHdyaXRlSGVhZGVyLFxuXHRcdHN0YXJ0Qm9keSxcblx0XHR3cml0ZUJvZHksXG5cdFx0d3JhcFVwTGF0ZUFycml2YWxzLFxuXHRcdGNsb3NlQm9keSxcblx0XHRoYW5kbGVSZXNwb25zZUNvbXBsZXRlLFxuXHRcdGVuZFJlc3BvbnNlLFxuXHRdO1xufVxuXG5mdW5jdGlvbiBzZXREYXRhQnVuZGxlQ29udGVudFR5cGUocmVxLCByZXMpIHtcblx0cmVzLnNldCgnQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbn1cblxuZnVuY3Rpb24gc2V0SHR0cEhlYWRlcnMocmVxLCByZXMsIGNvbnRleHQsIHN0YXJ0LCBwYWdlT2JqZWN0KSB7XG5cdC8vIFdyaXRlIG91dCBjdXN0b20gcGFnZS1kZWZpbmVkIGh0dHAgaGVhZGVycy4gSGVhZGVycyBtYXkgYmUgb3ZlcndyaXR0ZW4gbGF0ZXIgb24gaW4gdGhlIHJlbmRlciBjaGFpblxuXHQvLyAoZS5nLiB0cmFuc2ZlciBlbmNvZGluZywgY29udGVudCB0eXBlKVxuXHRjb25zdCBoYW5kbGVyID0gaGVhZGVyID0+IHJlcy5zZXQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pO1xuXG5cdHJldHVybiBRKHBhZ2VPYmplY3QuZ2V0SGVhZGVycygpKS50aGVuKGhlYWRlcnMgPT4gaGVhZGVycy5mb3JFYWNoKGhhbmRsZXIpKTtcbn1cblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGUocmVxLCByZXMsIGNvbnRleHQsIHN0YXJ0LCBwYWdlT2JqZWN0KSB7XG5cdHJlcy5zZXQoJ0NvbnRlbnQtVHlwZScsIHBhZ2VPYmplY3QuZ2V0Q29udGVudFR5cGUoKSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlSGVhZGVyKHJlcSwgcmVzLCBjb250ZXh0LCBzdGFydCwgcGFnZU9iamVjdCkge1xuXHQvLyBUaGlzIGlzIGF3a3dhcmQgYW5kIGltcHJlY2lzZS4gIFdlIGRvbid0IHdhbnQgdG8gcHV0IGA8c2NyaXB0PmBcblx0Ly8gdGFncyBiZXR3ZWVuIGRpdnMgYWJvdmUgdGhlIGZvbGQsIHNvIHdlJ3JlIGdvaW5nIHRvIGtlZXAgc2VwYXJhdGVcblx0Ly8gdHJhY2sgb2YgdGltZSBjbGllbnQgYW5kIHNlcnZlciBzaWRlLiBUaGVuIHdlJ2xsIHB1dCBgPG5vc2NyaXB0PmBcblx0Ly8gdGFncyB3aXRoIGRhdGEgZWxlbWVudHMgcmVwcmVzZW50aW5nIG9mZnNldCBmcm9tIG91ciBfc2VydmVyXyBiYXNlXG5cdC8vIHRpbWUgdGhhdCB3ZSdsbCBhcHBseSB0byBvdXIgX2NsaWVudF8gYmFzZSB0aW1lIGFzIGEgcHJveHkgZm9yIHdoZW5cblx0Ly8gdGhlIGVsZW1lbnQgYXJyaXZlZCAod2hlbiBpdCdzIGFjdHVhbGx5IHdoZW4gd2UgX3NlbnRfIGl0KS5cblx0UkxTKCkudGltaW5nRGF0YVQwID0gbmV3IERhdGU7XG5cblx0cmVzLnR5cGUoJ2h0bWwnKTtcblx0cmVzLnNldCgnVHJhbnNmZXItRW5jb2RpbmcnLCAnY2h1bmtlZCcpO1xuXG5cdHJlcy53cml0ZSgnPCFET0NUWVBFIGh0bWw+PGh0bWwgbGFuZz1cImVuXCI+PGhlYWQ+Jyk7XG5cblx0Ly8gbm90ZTogdGhlc2UgcmVzcG9uc2VzIGNhbiBjdXJyZW50bHkgY29tZSBiYWNrIG91dC1vZi1vcmRlciwgYXMgbWFueSBhcmUgcmV0dXJuaW5nXG5cdC8vIHByb21pc2VzLiBzY3JpcHRzIGFuZCBzdHlsZXNoZWV0cyBhcmUgZ3VhcmFudGVlZFxuXHRyZXR1cm4gUS5hbGwoW1xuXHRcdHJlbmRlckRlYnVnQ29tbWVudHMocGFnZU9iamVjdCwgcmVzKSxcblx0XHRyZW5kZXJUaXRsZShwYWdlT2JqZWN0LCByZXMpLFxuXHRcdC8vIFBMQVQtNjAyOiBpbmxpbmUgc2NyaXB0cyBjb21lIGJlZm9yZSBzdHlsZXNoZWV0cyBiZWNhdXNlXG5cdFx0Ly8gc3R5bGVzaGVldCBkb3dubG9hZHMgYmxvY2sgaW5saW5lIHNjcmlwdCBleGVjdXRpb24uXG5cdFx0KHBhZ2VPYmplY3QuZ2V0SnNCZWxvd1RoZUZvbGQoKSAmJiAhcGFnZU9iamVjdC5nZXRTcGxpdEpzTG9hZCgpKVxuXHRcdFx0PyBRKClcblx0XHRcdDogcmVuZGVyU2NyaXB0cyhwYWdlT2JqZWN0LCByZXMpLFxuXHRcdHJlbmRlclN0eWxlc2hlZXRzKHBhZ2VPYmplY3QsIHJlcylcblx0XHRcdC50aGVuKCgpID0+IFEuYWxsKFtcblx0XHRcdFx0cmVuZGVyTWV0YVRhZ3MocGFnZU9iamVjdCwgcmVzKSxcblx0XHRcdFx0cmVuZGVyTGlua1RhZ3MocGFnZU9iamVjdCwgcmVzKSxcblx0XHRcdFx0cmVuZGVyQmFzZVRhZyhwYWdlT2JqZWN0LCByZXMpLFxuXHRcdFx0XSkpLFxuXHRdKS50aGVuKCgpID0+IHtcblx0XHQvLyBvbmNlIHdlIGhhdmUgZmluaXNoZWQgcmVuZGVyaW5nIGFsbCBvZiB0aGUgcGllY2VzIG9mIHRoZSBoZWFkIGVsZW1lbnQsIHdlXG5cdFx0Ly8gY2FuIGNsb3NlIHRoZSBoZWFkIGFuZCBzdGFydCB0aGUgYm9keSBlbGVtZW50LlxuXHRcdHJlcy53cml0ZShgPC9oZWFkPmApO1xuXG5cdFx0Ly8gR2V0IGhlYWRlcnMgb3V0IHJpZ2h0IGF3YXkgc28gc2Vjb25kYXJ5IHJlc291cmNlIGRvd25sb2FkIGNhbiBzdGFydC5cblx0XHRmbHVzaFJlcyhyZXMpO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gZmx1c2hSZXMocmVzKXtcblxuXHQvLyBUaGlzIG1ldGhvZCBpcyBvbmx5IGRlZmluZWQgb24gdGhlIHJlc3BvbnNlIG9iamVjdCBpZiB0aGUgY29tcHJlc3Ncblx0Ly8gbWlkZGxld2FyZSBpcyBpbnN0YWxsZWQsIHNvIHdlIG5lZWQgdG8gZ3VhcmQgb3VyIGNhbGxzLlxuXHRpZiAocmVzLmZsdXNoKSB7XG5cdFx0cmVzLmZsdXNoKClcblx0XHRpZiAoIVJMUygpLmRpZExvZ0ZpcnN0Rmx1c2gpe1xuXHRcdFx0UkxTKCkuZGlkTG9nRmlyc3RGbHVzaCA9IHRydWU7XG5cdFx0XHRsb2dnZXIudGltZSgnZmlyc3RGbHVzaCcsIG5ldyBEYXRlIC0gUkxTKCkuc3RhcnRUaW1lKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyRGVidWdDb21tZW50cyAocGFnZU9iamVjdCwgcmVzKSB7XG5cdHZhciBkZWJ1Z0NvbW1lbnRzID0gcGFnZU9iamVjdC5nZXREZWJ1Z0NvbW1lbnRzKCk7XG5cdGRlYnVnQ29tbWVudHMubWFwKGRlYnVnQ29tbWVudCA9PiB7XG5cdFx0aWYgKCFkZWJ1Z0NvbW1lbnQubGFiZWwgfHwgIWRlYnVnQ29tbWVudC52YWx1ZSkge1xuXHRcdFx0bG9nZ2VyLndhcm5pbmcoXCJEZWJ1ZyBjb21tZW50IGlzIG1pc3NpbmcgZWl0aGVyIGEgbGFiZWwgb3IgYSB2YWx1ZVwiLCBkZWJ1Z0NvbW1lbnQpO1xuXHRcdH1cblxuXHRcdHJlcy53cml0ZShgPCEtLSAke2RlYnVnQ29tbWVudC5sYWJlbH06ICR7ZGVidWdDb21tZW50LnZhbHVlfSAtLT5gKTtcblx0fSk7XG5cblx0Ly8gcmVzb2x2ZSBpbW1lZGlhdGVseS5cblx0cmV0dXJuIFEoXCJcIik7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRGVidWdDb21tZW50cyAocmVxLCByZXMsIGNvbnRleHQsIHN0YXJ0LCBwYWdlT2JqZWN0KSB7XG5cdHJldHVybiBRKHJlbmRlckRlYnVnQ29tbWVudHMocGFnZU9iamVjdCwgcmVzKSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclRpdGxlIChwYWdlT2JqZWN0LCByZXMpIHtcblx0cmV0dXJuIHBhZ2VPYmplY3QuZ2V0VGl0bGUoKS50aGVuKCh0aXRsZSkgPT4ge1xuXHRcdHJlcy53cml0ZShgPHRpdGxlPiR7dGl0bGV9PC90aXRsZT5gKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGF0dHJmeSAodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWV0YVRhZ3MgKHBhZ2VPYmplY3QsIHJlcykge1xuXHR2YXIgbWV0YVRhZ3MgPSBwYWdlT2JqZWN0LmdldE1ldGFUYWdzKCk7XG5cblx0dmFyIG1ldGFUYWdzUmVuZGVyZWQgPSBtZXRhVGFncy5tYXAobWV0YVRhZ1Byb21pc2UgPT4ge1xuXHRcdHJldHVybiBtZXRhVGFnUHJvbWlzZS50aGVuKFBhZ2VVdGlsLm1ha2VBcnJheSkudGhlbihtZXRhVGFncyA9PiBtZXRhVGFncy5mb3JFYWNoKG1ldGFUYWcgPT4ge1xuXHRcdFx0aWYgKG1ldGFUYWcpIHtcblx0XHRcdFx0Ly8gVE9ETzogZXNjYXBpbmdcblx0XHRcdFx0aWYgKChtZXRhVGFnLm5hbWUgJiYgbWV0YVRhZy5odHRwRXF1aXYpIHx8IChtZXRhVGFnLm5hbWUgJiYgbWV0YVRhZy5jaGFyc2V0KSB8fCAobWV0YVRhZy5jaGFyc2V0ICYmIG1ldGFUYWcuaHR0cEVxdWl2KSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIk1ldGEgdGFnIGNhbm5vdCBoYXZlIG1vcmUgdGhhbiBvbmUgb2YgbmFtZSwgaHR0cEVxdWl2LCBhbmQgY2hhcnNldFwiLCBtZXRhVGFnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICgobWV0YVRhZy5uYW1lICYmICFtZXRhVGFnLmNvbnRlbnQpIHx8IChtZXRhVGFnLmh0dHBFcXVpdiAmJiAhbWV0YVRhZy5jb250ZW50KSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIk1ldGEgdGFnIGhhcyBuYW1lIG9yIGh0dHBFcXVpdiBidXQgZG9lcyBub3QgaGF2ZSBjb250ZW50XCIsIG1ldGFUYWcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG1ldGFUYWcubm9zY3JpcHQpIHJlcy53cml0ZShgPG5vc2NyaXB0PmApO1xuXHRcdFx0XHRyZXMud3JpdGUoYDxtZXRhYCk7XG5cblx0XHRcdFx0aWYgKG1ldGFUYWcubmFtZSkgcmVzLndyaXRlKGAgbmFtZT1cIiR7YXR0cmZ5KG1ldGFUYWcubmFtZSl9XCJgKTtcblx0XHRcdFx0aWYgKG1ldGFUYWcuaHR0cEVxdWl2KSByZXMud3JpdGUoYCBodHRwLWVxdWl2PVwiJHthdHRyZnkobWV0YVRhZy5odHRwRXF1aXYpfVwiYCk7XG5cdFx0XHRcdGlmIChtZXRhVGFnLmNoYXJzZXQpIHJlcy53cml0ZShgIGNoYXJzZXQ9XCIke2F0dHJmeShtZXRhVGFnLmNoYXJzZXQpfVwiYCk7XG5cdFx0XHRcdGlmIChtZXRhVGFnLnByb3BlcnR5KSByZXMud3JpdGUoYCBwcm9wZXJ0eT1cIiR7YXR0cmZ5KG1ldGFUYWcucHJvcGVydHkpfVwiYCk7XG5cdFx0XHRcdGlmIChtZXRhVGFnLmNvbnRlbnQpIHJlcy53cml0ZShgIGNvbnRlbnQ9XCIke2F0dHJmeShtZXRhVGFnLmNvbnRlbnQpfVwiYCk7XG5cblx0XHRcdFx0cmVzLndyaXRlKGA+YClcblx0XHRcdFx0aWYgKG1ldGFUYWcubm9zY3JpcHQpIHJlcy53cml0ZShgPC9ub3NjcmlwdD5gKTtcblx0XHRcdH1cblx0XHR9KSk7XG5cdH0pO1xuXG5cdHJldHVybiBRLmFsbChtZXRhVGFnc1JlbmRlcmVkKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTGlua1RhZ3MgKHBhZ2VPYmplY3QsIHJlcykge1xuXHR2YXIgbGlua1RhZ3MgPSBwYWdlT2JqZWN0LmdldExpbmtUYWdzKCk7XG5cblx0dmFyIGxpbmtUYWdzUmVuZGVyZWQgPSBsaW5rVGFncy5tYXAobGlua1RhZ1Byb21pc2UgPT4ge1xuXHRcdHJldHVybiBsaW5rVGFnUHJvbWlzZS50aGVuKFBhZ2VVdGlsLm1ha2VBcnJheSkudGhlbihsaW5rVGFncyA9PiBsaW5rVGFncy5mb3JFYWNoKGxpbmtUYWcgPT4ge1xuXHRcdFx0aWYgKGxpbmtUYWcpIHtcblx0XHRcdFx0aWYgKCFsaW5rVGFnLnJlbCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgPGxpbms+IHRhZyBzcGVjaWZpZWQgd2l0aG91dCAncmVsJyBhdHRyYCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXMud3JpdGUoYDxsaW5rICR7UEFHRV9MSU5LX05PREVfSUR9ICR7XG5cdFx0XHRcdFx0T2JqZWN0LmtleXMobGlua1RhZylcblx0XHRcdFx0XHRcdC5tYXAoYXR0ciA9PiBgJHthdHRyfT1cIiR7YXR0cmZ5KGxpbmtUYWdbYXR0cl0pfVwiYClcblx0XHRcdFx0XHRcdC5qb2luKCcgJylcblx0XHRcdFx0XHR9PmApO1xuXHRcdFx0fVxuXHRcdH0pKTtcblx0fSk7XG5cblx0cmV0dXJuIFEuYWxsKGxpbmtUYWdzUmVuZGVyZWQpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJCYXNlVGFnKHBhZ2VPYmplY3QsIHJlcykge1xuXHRyZXR1cm4gcGFnZU9iamVjdC5nZXRCYXNlKCkudGhlbigoYmFzZSkgPT4ge1xuXHRcdGlmIChiYXNlICE9PSBudWxsKSB7XG5cdFx0XHRpZiAoIWJhc2UuaHJlZiAmJiAhYmFzZS50YXJnZXQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiPGJhc2U+IG5lZWRzIGF0IGxlYXN0IG9uZSBvZiAnaHJlZicgb3IgJ3RhcmdldCdcIik7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdGFnID0gXCI8YmFzZVwiO1xuXHRcdFx0aWYgKGJhc2UuaHJlZikge1xuXHRcdFx0XHR0YWcgKz0gYCBocmVmPVwiJHthdHRyZnkoYmFzZS5ocmVmKX1cImA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYmFzZS50YXJnZXQpIHtcblx0XHRcdFx0dGFnICs9IGAgdGFyZ2V0PVwiJHthdHRyZnkoYmFzZS50YXJnZXQpfVwiYDtcblx0XHRcdH1cblx0XHRcdHRhZyArPSBcIj5cIjtcblx0XHRcdHJlcy53cml0ZSh0YWcpO1xuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclNjcmlwdHNTeW5jKHNjcmlwdHMsIHJlcykge1xuXG5cdC8vIHJpZ2h0IG5vdywgdGhlIGdldFhYWFNjcmlwdEZpbGVzIG1ldGhvZHMgcmV0dXJuIHN5bmNocm9ub3VzbHksIG5vIHByb21pc2VzLCBzbyB3ZSBjYW4gcmVuZGVyXG5cdC8vIGltbWVkaWF0ZWx5LlxuXHRzY3JpcHRzLmZvckVhY2goIChzY3JpcHQpID0+IHtcblx0XHQvLyBtYWtlIHN1cmUgdGhlcmUncyBhIGxlYWRpbmcgJy8nXG5cdFx0aWYgKCFzY3JpcHQudHlwZSkgc2NyaXB0LnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xuXG5cdFx0aWYgKHNjcmlwdC5ocmVmKSB7XG5cdFx0XHRyZXMud3JpdGUoYDxzY3JpcHQgc3JjPVwiJHtzY3JpcHQuaHJlZn1cIiB0eXBlPVwiJHtzY3JpcHQudHlwZX1cIj48L3NjcmlwdD5gKTtcblx0XHR9IGVsc2UgaWYgKHNjcmlwdC50ZXh0KSB7XG5cdFx0XHRyZXMud3JpdGUoYDxzY3JpcHQgdHlwZT1cIiR7c2NyaXB0LnR5cGV9XCI+JHtzY3JpcHQudGV4dH08L3NjcmlwdD5gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU2NyaXB0IGNhbm5vdCBiZSByZW5kZXJlZCBiZWNhdXNlIGl0IGhhcyBuZWl0aGVyIGFuIGhyZWYgbm9yIGEgdGV4dCBhdHRyaWJ1dGU6IFwiICsgc2NyaXB0KTtcblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTY3JpcHRzQXN5bmMoc2NyaXB0cywgcmVzKSB7XG5cblx0Ly8gTm90aGluZyB0byBkbyBpZiB0aGVyZSBhcmUgbm8gc2NyaXB0cy5cblx0aWYgKCFzY3JpcHRzLmxlbmd0aCkgcmV0dXJuO1xuXG5cdC8vIERvbid0IG5lZWQgXCJ0eXBlXCIgaW4gPHNjcmlwdD4gdGFncyBhbnltb3JlLlxuXHQvL1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sL3NjcmlwdGluZy0xLmh0bWwjdGhlLXNjcmlwdC1lbGVtZW50XG5cdC8vXG5cdC8vID4gVGhlIGRlZmF1bHQsIHdoaWNoIGlzIHVzZWQgaWYgdGhlIGF0dHJpYnV0ZSBpcyBhYnNlbnQsIGlzIFwidGV4dC9qYXZhc2NyaXB0XCIuXG5cdC8vXG5cdHJlcy53cml0ZShcIjxzY3JpcHQ+XCIpO1xuXG5cdC8vIExhemlseSBsb2FkIExBQiB0aGUgZmlyc3QgdGltZSB3ZSBzcGl0IG91dCBhc3luYyBzY3JpcHRzLlxuXHRpZiAoIVJMUygpLmRpZExvYWRMQUIpe1xuXG5cdFx0Y29uc3QgZ2xvYmFsRGVmYXVsdHMgPSB7QWx3YXlzUHJlc2VydmVPcmRlcjp0cnVlfTtcblxuXHRcdC8vIFRoZSBcImNhY2hlLXByZWxvYWRpbmdcIiBvcHRpb24gaW4gc3RvY2sgTEFCanMgZG9lc24ndCB3b3JrIGluIG1vZGVyblxuXHRcdC8vIENocm9tZS4gSWYgeW91J3JlIGNvbmZpZ3VyZWQgZm9yIHNwbGl0SnNMb2FkIHRoZW4geW91J2QgYmV0dGVyIGhhdmVcblx0XHQvLyB4aHIgYWNjZXNzIHRvIHlvdXIgc2NyaXB0cyEgIFRoZXkgbmVlZCB0byBlaXRoZXIgYmUgb24gdGhlIHNhbWVcblx0XHQvLyBkb21haW4gb3IgaGF2ZSBDT1JTIGhlYWRlcnMuXG5cdFx0aWYgKFJMUygpLnBhZ2UuZ2V0U3BsaXRKc0xvYWQoKSkge1xuXHRcdFx0Z2xvYmFsRGVmYXVsdHMuVXNlQ09SU1hIUiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gVGhpcyBpcyB0aGUgZnVsbCBpbXBsZW1lbnRhdGlvbiBvZiBMQUJqcy5cblx0XHQvLyBQYXNzIGA/X2RlYnVnX2xhYj0xYCBmb3IgdW5taW5pZmllZCBzb3VyY2Ugd2l0aCBkZWJ1Z2dpbmcgb3V0cHV0LlxuXHRcdHJlcy53cml0ZShEZWJ1Z1V0aWwuZ2V0TGFiKCkgPyBmbGFiLnNyYyA6IGZsYWIubWluKTtcblxuXHRcdC8vIFdlIGFsd2F5cyB3YW50IHNjcmlwdHMgdG8gYmUgZXhlY3V0ZWQgaW4gb3JkZXIuXG5cdFx0cmVzLndyaXRlKGAkTEFCLnNldEdsb2JhbERlZmF1bHRzKCR7SlNPTi5zdHJpbmdpZnkoZ2xvYmFsRGVmYXVsdHMpfSk7YCk7XG5cblx0XHQvLyBXZSdsbCB1c2UgdGhpcyB0byBzdG9yZSBzdGF0ZSBiZXR3ZWVuIGNhbGxzIChzZWUgYmVsb3cpLlxuXHRcdHJlcy53cml0ZShcIndpbmRvdy5fdExBQj0kTEFCXCIpXG5cblx0XHQvLyBJZiB3ZSdyZSBzcGxpdHRpbmcgb3VyIEpTIGxvYWQgZnJvbSB0aGUgZXhlY3V0aW9uIG9mIG91ciBKUyB0aGVuIHdlXG5cdFx0Ly8gbmVlZCB0byB0ZWxsIExBQmpzIHRvIHByZWxvYWQgb3VyIGJ1bmRsZXMgYnV0IGhvbGQgb2ZmIG9uIGV4ZWN1dGluZ1xuXHRcdC8vIHRoZW0uXG5cdFx0aWYgKFJMUygpLnBhZ2UuZ2V0U3BsaXRKc0xvYWQoKSkgcmVzLndyaXRlKFwiLmNvcmsoKVwiKTtcblxuXHRcdC8vIE9ubHkgbmVlZCB0byBkbyB0aGlzIHBhcnQgb25jZS5cblx0XHRSTFMoKS5kaWRMb2FkTEFCID0gdHJ1ZTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRoZSBhc3NpZ25tZW50IHRvIGBfdExBQmAgaGVyZSBpcyBzbyB3ZSBtYWludGFpbiBhIHNpbmdsZVxuXHRcdC8vIExBQiBjaGFpbiB0aHJvdWdoIGFsbCBvZiBvdXIgY2FsbHMgdG8gYHJlbmRlclNjcmlwdHNBc3luY2AuXG5cdFx0Ly9cblx0XHQvLyBFYWNoIGNhbGwgdG8gdGhpcyBmdW5jdGlvbiBlbWl0cyBvdXRwdXQgdGhhdCBsb29rc1xuXHRcdC8vIHNvbWV0aGluZyBsaWtlOlxuXHRcdC8vXG5cdFx0Ly8gICBfdExBQj1fdExBQi5zY3JpcHQoLi4uKS53YWl0KC4uLikgLi4uXG5cdFx0Ly9cblx0XHQvLyBUaGUgcmVzdWx0IGlzIHRoYXQgYHdpbmRvdy5fdExBQmAgd2luZHMgdXAgaG9sZGluZyB0aGVcblx0XHQvLyBmaW5hbCBzdGF0ZSBvZiB0aGUgTEFCIGNoYWluIGFmdGVyIGVhY2ggY2FsbCwgc28gdGhhdCBzYW1lXG5cdFx0Ly8gTEFCIGNoYWluIGNhbiBiZSBhcHBlbmRlZCB0byBpbiB0aGUgX25leHRfIGNhbGwgKGlmIHRoZXJlXG5cdFx0Ly8gaXMgb25lKS5cblx0XHQvL1xuXHRcdC8vIFlvdSBjYW4gdGhpbmsgb2YgYSBMQUIgY2hhaW4gYXMgYmVpbmcgc2ltaWxhciB0byBhIHByb21pc2Vcblx0XHQvLyBjaGFpbi4gIFRoZSBvdXRwdXQgb2YgYCRMQUIuc2NyaXB0KClgIG9yIGAkTEFCLndhaXQoKWAgaXNcblx0XHQvLyBhbiBvYmplY3QgdGhhdCBpdHNlbGYgaGFzIGBzY3JpcHQoKWAgYW5kIGB3YWl0KClgIG1ldGhvZHMuXG5cdFx0Ly8gU28gbG9uZyBhcyB0aGUgb3V0cHV0IG9mIGVhY2ggY2FsbCBpcyB1c2VkIGFzIHRoZSBpbnB1dCBmb3Jcblx0XHQvLyB0aGUgbmV4dCBjYWxsIG91ciBjb2RlIChib3RoIGFzeW5jIGxvYWRlZCBzY3JpcHRzIGFuZFxuXHRcdC8vIGlubGluZSBKUykgd2lsbCBiZSBleGVjdXRlZCBfaW4gb3JkZXJfLlxuXHRcdC8vXG5cdFx0Ly8gSWYgd2Ugc3RhcnQgYSBfbmV3XyBjaGFpbiBkaXJlY3RseSBmcm9tIGAkTEFCYCAodGhlIHJvb3Rcblx0XHQvLyBjaGFpbiksIHdlIGNhbiB3aW5kIHVwIHdpdGggX291dCBvZiBvcmRlcl8gZXhlY3V0aW9uLlxuXHRcdC8vXG5cdFx0Ly8gV2Ugd2FudCBldmVyeXRoaW5nIHRvIGJlIGV4ZWN1dGVkIGluIG9yZGVyLCBzbyB3ZSBtYWludGFpblxuXHRcdC8vIG9uZSBtYXN0ZXIgY2hhaW4gZm9yIHRoZSBwYWdlLiAgVGhpcyBjaGFpbiBpc1xuXHRcdC8vIGB3aW5kb3cuX3RMQUJgLlxuXHRcdC8vXG5cdFx0cmVzLndyaXRlKFwiX3RMQUI9X3RMQUJcIik7XG5cdH1cblxuXHRzY3JpcHRzLmZvckVhY2goc2NyaXB0ID0+IHtcblxuXHRcdGlmIChzY3JpcHQuaHJlZikge1xuXHRcdFx0dmFyIExBQlNjcmlwdCA9IHsgc3JjOiBzY3JpcHQuaHJlZiB9O1xuXG5cdFx0XHRpZiAoc2NyaXB0LmNyb3NzT3JpZ2luKXtcblx0XHRcdFx0TEFCU2NyaXB0LmNyb3NzT3JpZ2luID0gc2NyaXB0LmNyb3NzT3JpZ2luO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBvdGhlciBvcHRpb25zIHdlIGNhbiBzaGF2ZSBhXG5cdFx0XHQvLyBmZXcgYnl0ZXMgYnkganVzdCBwYXNzaW5nIHRoZSBzdHJpbmcuXG5cdFx0XHRpZiAoT2JqZWN0LmtleXMoTEFCU2NyaXB0KS5sZW5ndGggPT09IDEpe1xuXHRcdFx0XHRMQUJTY3JpcHQgPSBMQUJTY3JpcHQuc3JjO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc2NyaXB0LmNvbmRpdGlvbikge1xuXHRcdFx0XHRyZXMud3JpdGUoYC5zY3JpcHQoZnVuY3Rpb24oKXtpZigke3NjcmlwdC5jb25kaXRpb259KSByZXR1cm4gJHtKU09OLnN0cmluZ2lmeShMQUJTY3JpcHQpfX0pYCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXMud3JpdGUoYC5zY3JpcHQoJHtKU09OLnN0cmluZ2lmeShMQUJTY3JpcHQpfSlgKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoc2NyaXB0LnRleHQpIHtcblx0XHRcdGlmIChzY3JpcHQuY29uZGl0aW9uKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlNjcmlwdCB1c2luZyBgdGV4dGAgY2Fubm90IGJlIGxvYWRlZCBjb25kaXRpb25hbGx5XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgdHJ5L2NhdGNoIGRhbmNlIGhlcmUgaXMgc28gZXhjZXB0aW9ucyBnZXQgdGhlaXJcblx0XHRcdC8vIG93biB0aW1lIHNsaWNlIGFuZCBjYW4ndCBtZXNzIHdpdGggZXhlY3V0aW9uIG9mIHRoZVxuXHRcdFx0Ly8gTEFCIGNoYWluLlxuXHRcdFx0Ly9cblx0XHRcdC8vIFRoZSBiaW5kaW5nIHRvIGB0aGlzYCBpcyBzbyBlbmNsb3NlZCByZWZlcmVuY2VzIHRvXG5cdFx0XHQvLyBgdGhpc2AgY29ycmVjdGx5IGdldCB0aGUgYHdpbmRvd2Agb2JqZWN0IChkZXNwaXRlXG5cdFx0XHQvLyBiZWluZyBpbiBhIHN0cmljdCBjb250ZXh0KS5cblx0XHRcdC8vXG5cdFx0XHRyZXMud3JpdGUoYC53YWl0KGZ1bmN0aW9uKCl7JHtcblx0XHRcdFx0c2NyaXB0LnN0cmljdD8nXCJ1c2Ugc3RyaWN0XCI7JzonJ1xuXHRcdFx0fXRyeXske1xuXHRcdFx0XHRzY3JpcHQudGV4dFxuXHRcdFx0fX1jYXRjaChlKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3coZSl9LDEpfX0uYmluZCh0aGlzKSlgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlNjcmlwdCBuZWVkcyBlaXRoZXIgYGhyZWZgIG9yIGB0ZXh0YDogXCIgKyBzY3JpcHQpO1xuXHRcdH1cblx0fSk7XG5cblx0cmVzLndyaXRlKFwiOzwvc2NyaXB0PlwiKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyU2NyaXB0cyhwYWdlT2JqZWN0LCByZXMpIHtcblxuXHQvLyBXYW50IHRvIGdhdGhlciB0aGVzZSBpbnRvIG9uZSBsaXN0IG9mIHNjcmlwdHMsIGJlY2F1c2Ugd2UgY2FyZSBpZlxuXHQvLyB0aGVyZSBhcmUgYW55IG5vbi1KUyBzY3JpcHRzIGluIHRoZSB3aG9sZSBidW5jaC5cblx0dmFyIHNjcmlwdHMgPSBwYWdlT2JqZWN0LmdldFN5c3RlbVNjcmlwdHMoKS5jb25jYXQocGFnZU9iamVjdC5nZXRTY3JpcHRzKCkpO1xuXG5cdHZhciB0aGVyZUlzQXRMZWFzdE9uZU5vbkpTU2NyaXB0ID0gc2NyaXB0cy5maWx0ZXIoXG5cdFx0c2NyaXB0ID0+IHNjcmlwdC50eXBlICYmIHNjcmlwdC50eXBlICE9PSBcInRleHQvamF2YXNjcmlwdFwiXG5cdCkubGVuZ3RoO1xuXG5cdGlmICh0aGVyZUlzQXRMZWFzdE9uZU5vbkpTU2NyaXB0KXtcblxuXHRcdC8vIElmIHRoZXJlIGFyZSBub24tSlMgc2NyaXB0cyB3ZSBjYW4ndCB1c2UgTEFCIGZvciBhc3luY1xuXHRcdC8vIGxvYWRpbmcuICBXZSBzdGlsbCB3YW50IHRvIHByZXNlcnZlIHNjcmlwdCBleGVjdXRpb24gb3JkZXIsXG5cdFx0Ly8gc28gd2UnbGwgY3V0IG92ZXIgdG8gYWxsLXN5bmNocm9ub3VzIGxvYWRpbmcuXG5cdFx0cmVuZGVyU2NyaXB0c1N5bmMoc2NyaXB0cywgcmVzKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIE90aGVyd2lzZSwgd2UgY2FuIGRvIGFzeW5jIHNjcmlwdCBsb2FkaW5nLlxuXHRcdHJlbmRlclNjcmlwdHNBc3luYyhzY3JpcHRzLCByZXMpO1xuXHR9XG5cblx0Ly8gcmVzb2x2ZSBpbW1lZGlhdGVseS5cblx0cmV0dXJuIFEoXCJcIik7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclN0eWxlc2hlZXRzIChwYWdlT2JqZWN0LCByZXMpIHtcblxuXHRjb25zdCB3cml0ZVRhZyA9IHN0eWxlU2hlZXQgPT4ge1xuXHRcdGlmICghc3R5bGVTaGVldCkge1xuXHRcdFx0Ly8gc2tpcC4gYSBwcm9taXNlIHJlc29sdmluZyB0byBub3RoaW5nIGlzIHRoZSBvbmx5IHdheSB0byBkZWNpZGVcblx0XHRcdC8vIHRvIG5vdCBvdXRwdXQgYSBzdHlsZXNoZWV0IGlmIHlvdSByZXR1cm4gYSBwcm9taXNlXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChzdHlsZVNoZWV0LmhyZWYpIHtcblx0XHRcdHJlcy53cml0ZShgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIHR5cGU9XCIke3N0eWxlU2hlZXQudHlwZX1cIiBtZWRpYT1cIiR7c3R5bGVTaGVldC5tZWRpYX1cIiBocmVmPVwiJHtzdHlsZVNoZWV0LmhyZWZ9XCIgJHtQQUdFX0NTU19OT0RFX0lEfT5gKTtcblx0XHR9IGVsc2UgaWYgKHN0eWxlU2hlZXQudGV4dCkge1xuXHRcdFx0cmVzLndyaXRlKGA8c3R5bGUgdHlwZT1cIiR7c3R5bGVTaGVldC50eXBlfVwiIG1lZGlhPVwiJHtzdHlsZVNoZWV0Lm1lZGlhfVwiICR7UEFHRV9DU1NfTk9ERV9JRH0+JHtzdHlsZVNoZWV0LnRleHR9PC9zdHlsZT5gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU3R5bGUgY2Fubm90IGJlIHJlbmRlcmVkIGJlY2F1c2UgaXQgaGFzIG5laXRoZXIgYW4gaHJlZiBub3IgYSB0ZXh0IGF0dHJpYnV0ZTogXCIgKyBzdHlsZVNoZWV0KTtcblx0XHR9XG5cdH07XG5cblx0Y29uc3Qgc3R5bGVzID0gUGFnZVV0aWwuc3RhbmRhcmRpemVTdHlsZXMocGFnZU9iamVjdC5nZXRIZWFkU3R5bGVzaGVldHMoKSk7XG5cblx0cmV0dXJuIHN0eWxlcy5yZWR1Y2UoIChwcmV2LCBzdHlsZVApID0+IHtcblx0XHRyZXR1cm4gcHJldi50aGVuKCgpID0+IHN0eWxlUC50aGVuKHdyaXRlVGFnKSk7XG5cdH0sIFEoKSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Qm9keShyZXEsIHJlcywgY29udGV4dCwgc3RhcnQsIHBhZ2UpIHtcblxuXHR2YXIgcm91dGVOYW1lID0gY29udGV4dC5uYXZpZ2F0b3IuZ2V0Q3VycmVudFJvdXRlKCkubmFtZVxuXG5cdHJldHVybiBwYWdlLmdldEJvZHlDbGFzc2VzKCkudGhlbigoY2xhc3NlcykgPT4ge1xuXHRcdGNsYXNzZXMucHVzaChgcm91dGUtJHtyb3V0ZU5hbWV9YClcblx0XHRyZXMud3JpdGUoYDxib2R5IGNsYXNzPScke2NsYXNzZXMuam9pbignICcpfSc+YCk7XG5cdH0pLnRoZW4oKCkgPT4gcGFnZS5nZXRCb2R5U3RhcnRDb250ZW50KCkpLnRoZW4oKHRleHRzKSA9PiB0ZXh0cy5mb3JFYWNoKCh0ZXh0KSA9PiB7XG5cdFx0cmVzLndyaXRlKHRleHQpO1xuXHR9KSkudGhlbigoKSA9PiB7XG5cdFx0cmVzLndyaXRlKGA8ZGl2IGlkPSdjb250ZW50JyAke1BBR0VfQ09OVEVOVF9OT0RFX0lEfT5gKTtcblx0fSk7XG59XG5cbi8qKlxuICogV3JpdGVzIG91dCB0aGUgUmVhY3RFbGVtZW50cyB0byB0aGUgcmVzcG9uc2UuIFJldHVybnMgYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2hlblxuICogYWxsIHRoZSBSZWFjdEVsZW1lbnRzIGhhdmUgYmVlbiB3cml0dGVuIG91dC5cbiAqL1xuZnVuY3Rpb24gd3JpdGVCb2R5KHJlcSwgcmVzLCBjb250ZXh0LCBzdGFydCwgcGFnZSkge1xuXG5cdC8vIHN0YW5kYXJkaXplIHRvIGFuIGFycmF5IG9mIEVhcmx5UHJvbWlzZXMgb2YgUmVhY3RFbGVtZW50c1xuXHR2YXIgZWxlbWVudFByb21pc2VzID0gUGFnZVV0aWwuc3RhbmRhcmRpemVFbGVtZW50cyhwYWdlLmdldEVsZW1lbnRzKCkpO1xuXG5cdC8vIFRoaXMgaXMgd2hlcmUgd2UnbGwgc3RvcmUgb3VyIHJlbmRlcmVkIEhUTUwgc3RyaW5ncy4gIEEgdmFsdWUgb2Zcblx0Ly8gYHVuZGVmaW5lZGAgbWVhbnMgd2UgaGF2ZW4ndCByZW5kZXJlZCB0aGF0IGVsZW1lbnQgeWV0LlxuXHR2YXIgcmVuZGVyZWQgPSBlbGVtZW50UHJvbWlzZXMubWFwKCgpID0+IEVMRU1FTlRfUEVORElORyk7XG5cblx0Ly8gV2UgbmVlZCB0byByZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB3ZSdyZSBkb25lLCBzbyB3ZSdsbFxuXHQvLyBtYWludGFpbiBhbiBhcnJheSBvZiBkZWZlcnJlZHMgdGhhdCB3ZSBwdW5jaCBvdXQgYXMgd2UgcmVuZGVyXG5cdC8vIGVsZW1lbnRzIGFuZCB3ZSdsbCByZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGV5J3ZlIGFsbFxuXHQvLyBiZWVuIGhpdC5cblx0dmFyIGRmZHMgPSBlbGVtZW50UHJvbWlzZXMubWFwKCgpID0+IFEuZGVmZXIoKSk7XG5cblx0dmFyIGRvRWxlbWVudCA9IChlbGVtZW50LCBpbmRleCkgPT4ge1xuXG5cdFx0Ly8gRXhjZWVkZWQgYEZBSUxTQUZFX1JFTkRFUl9USU1FT1VUYC4gIEJ1bW1lci5cblx0XHRpZiAocmVuZGVyZWRbaW5kZXhdID09PSBFTEVNRU5UX0FMUkVBRFlfV1JJVFRFTikgcmV0dXJuO1xuXG5cdFx0cmVuZGVyZWRbaW5kZXhdID0gcmVuZGVyRWxlbWVudChyZXMsIGVsZW1lbnQsIGNvbnRleHQpO1xuXG5cdFx0Ly8gSWYgd2UndmUganVzdCByZW5kZXJlZCB0aGUgbmV4dCBlbGVtZW50IHRvIGJlIHdyaXR0ZW4gd2UnbGxcblx0XHQvLyB3cml0ZSBpdCBvdXQuXG5cdFx0d3JpdGVFbGVtZW50cyhyZXMsIHJlbmRlcmVkKTtcblxuXHRcdGRmZHNbaW5kZXhdLnJlc29sdmUoKTtcblx0fTtcblxuXHQvLyBSZW5kZXIgZWxlbWVudHMgYXMgdGhlaXIgZGF0YSBiZWNvbWVzIGF2YWlsYWJsZS5cblx0ZWxlbWVudFByb21pc2VzLmZvckVhY2goKHByb21pc2UsIGluZGV4KSA9PiBwcm9taXNlXG5cdFx0LnRoZW4oZWxlbWVudCA9PiBkb0VsZW1lbnQoZWxlbWVudCwgaW5kZXgpKVxuXHRcdC5jYXRjaChlID0+IHtcblx0XHRcdGxvZ2dlci5lcnJvcihgRXJyb3IgcmVuZGVyaW5nIGVsZW1lbnQgJHtpbmRleH1gLCBlKVxuXHRcdFx0Ly8gVE9ETzogdGhlIGVycm9yIGhhbmRsaW5nIGhlcmUgc2hvdWxkIHByb2JhYmx5IGJlIG1lcmdlZFxuXHRcdFx0Ly8gc29tZWhvdyB3aXRoIHJlbmRlckVsZW1lbnQgc28gdGhhdCB3ZSBnZXQgdGltaW5nIGluZm8uXG5cblx0XHRcdC8vIEluIHRoZSBjYXNlIHdoZXJlIHRoZXJlIHdhcyBhbiBleGNlcHRpb24gdGhyb3duIHdoaWxlIHJlbmRlcmluZyxcblx0XHRcdC8vIHRoZSBuZXh0IHRocmVlIGxpbmVzIGFyZSBlZmZlY3RpdmVseSBhIG5vLW9wLiBJbiB0aGUgY2FzZSB3aGVyZVxuXHRcdFx0Ly8gdGhlIGVsZW1lbnQgcHJvbWlzZSB3YXMgcmVqZWN0ZWQsIHRoaXMgcHJldmVudHMgYSBoYW5nIHVudGlsXG5cdFx0XHQvLyBGQUlMU0FGRV9SRU5ERVJfVElNRU9VVCBoYXMgcGFzc2VkLlxuXG5cdFx0XHQvLyBObyB3YXkgd2UgY2FuIHJlY292ZXIgaW4gdGhlIHNlY29uZCBjYXNlLCBzbyBsZXQncyBqdXN0IG1vdmUgb24uXG5cdFx0XHQvLyBXZSdsbCBjYWxsIGB3cml0ZUVsZW1lbnRzYCBqdXN0IGluIGNhc2UgZXZlcnl0aGluZyBpcyByZWFkeVxuXHRcdFx0Ly8gYWZ0ZXIgdXMuXG5cblx0XHRcdC8vIFRoaXMgZG9lc24ndCBjb21wbGV0ZWx5IGhhbmRsZSB0aGUgZXh0cmVtZWx5IHVubGlrZWx5IGNhc2UgdGhhdDpcblx0XHRcdC8vICAgICAxKSBgcmVuZGVyRWxlbWVudGAgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHRoaXMgZWxlbWVudCwgYW5kXG5cdFx0XHQvLyAgICAgMikgYHdyaXRlRWxlbWVudHNgIHN1Y2Nlc3NmdWxseSB3cm90ZSBpdCwgYnV0Li4uXG5cdFx0XHQvLyAgICAgMykgYHdyaXRlRWxlbWVudHNgIHRocmV3IGFmdGVyIHRoaXMgZWxlbWVudCB3YXMgd3JpdHRlbi5cblx0XHRcdC8vXG5cdFx0XHQvLyBXZSdsbCBtYWtlIGEgZ29vZC1mYWl0aCBlZmZvcnQsIGJ1dCBpbiB0aGlzIHJhcmUgY2FzZSB3cml0ZUVsZW1lbnRzIGlzIHByb2JhYmx5XG5cdFx0XHQvLyBnb2luZyB0byBmYWlsIGFnYWluIHdoZW4gd2UgY2FsbCBpdCBoZXJlLiBBdCBsZWFzdCBpZiB0aGF0IGhhcHBlbnMsIF90aGlzX1xuXHRcdFx0Ly8gcGFydGljdWxhciBlbGVtZW50IHNob3VsZCBzaG93IHVwIHByb3Blcmx5IG9uIHRoZSBwYWdlLCBldmVuIHRob3VnaCB0aGUgcGFnZVxuXHRcdFx0Ly8gb3ZlcmFsbCBjb3VsZCBiZSB0b3RhbGx5IGhvcmtlZC4gQW5kIHdlIHdvbid0IGhhdmUgYSAyMHMgdGltZW91dC4uLlxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHJlbmRlcmVkW2luZGV4XSAhPT0gRUxFTUVOVF9BTFJFQURZX1dSSVRURU4pIHtcblx0XHRcdFx0XHRyZW5kZXJlZFtpbmRleF0gPSAnJztcblx0XHRcdFx0XHR3cml0ZUVsZW1lbnRzKHJlcywgcmVuZGVyZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHQvLyB0cnkgX3JlYWxseV8gaGFyZCB0byByZXNvbHZlIHRoaXMgZGVmZXJyZWQsIHRvIGF2b2lkIGEgMjBzIGhhbmcuXG5cdFx0XHRcdGRmZHNbaW5kZXhdLnJlc29sdmUoKTtcblx0XHRcdH1cblx0XHR9KVxuXHRcdC8vIGp1c3QgaW4gY2FzZSB3cml0ZUVsZW1lbnRzIHRocm93cyBpbiBvdXIgZXJyb3IgY2FsbGJhY2sgYWJvdmUuXG5cdFx0LmNhdGNoKGUgPT4gbG9nZ2VyLmVycm9yKGBFcnJvciByZWNvdmVyaW5nIGZyb20gZXJyb3IgcmVuZGVyaW5nIGVsZW1lbnQgJHtpbmRleH1gLCBlKSlcblx0KTtcblxuXHQvLyBTb21lIHRpbWUgaGFzIGFscmVhZHkgZWxhcHNlZCBzaW5jZSB0aGUgcmVxdWVzdCBzdGFydGVkLlxuXHQvLyBOb3RlIHRoYXQgeW91IGNhbiBvdmVycmlkZSBgRkFJTFNBRkVfUkVOREVSX1RJTUVPVVRgIHdpdGggYVxuXHQvLyBgP19kZWJ1Z19yZW5kZXJfdGltZW91dD17bXN9YCBxdWVyeSBzdHJpbmcgcGFyYW1ldGVyLlxuXHR2YXIgdG90YWxXYWl0ICAgICA9IERlYnVnVXRpbC5nZXRSZW5kZXJUaW1lb3V0KCkgfHwgRkFJTFNBRkVfUkVOREVSX1RJTUVPVVRcblx0LCAgIHRpbWVSZW1haW5pbmcgPSB0b3RhbFdhaXQgLSAobmV3IERhdGUgLSBzdGFydClcblxuXHR2YXIgcmV0dmFsID0gUS5kZWZlcigpO1xuXHR2YXIgd3JpdGVCb2R5RGZkID0gUS5kZWZlcigpO1xuXG5cdC8vIElmIHdlIGV4Y2VlZCB0aGUgdGltZW91dCB0aGVuIHdlJ2xsIGp1c3Qgc2VuZCBlbXB0eSBlbGVtZW50cyBmb3Jcblx0Ly8gYW55dGhpbmcgdGhhdCBoYWRuJ3QgcmVuZGVyZWQgeWV0LlxuXHR3cml0ZUJvZHlEZmQucHJvbWlzZS5jYXRjaCgoZXJyKSA9PiB7XG5cblx0XHQvLyBXcml0ZSBvdXQgd2hhdCB3ZSd2ZSBnb3QuXG5cdFx0d3JpdGVFbGVtZW50cyhyZXMsIHJlbmRlcmVkLm1hcChcblx0XHRcdHZhbHVlID0+IHZhbHVlID09PSBFTEVNRU5UX1BFTkRJTkc/Jyc6dmFsdWVcblx0XHQpKTtcblxuXHRcdC8vIElmIGl0IGhhc24ndCBhcnJpdmVkIGJ5IG5vdywgd2UncmUgbm90IGdvaW5nIHRvIHdhaXQgZm9yIGl0LlxuXHRcdFJMUygpLmxhdGVBcnJpdmFscyA9IHVuZGVmaW5lZDtcblxuXHRcdC8vIExldCB0aGUgY2xpZW50IGtub3cgaXQncyBub3QgZ2V0dGluZyBhbnkgbW9yZSBkYXRhLlxuXHRcdHJlbmRlclNjcmlwdHNBc3luYyhbeyB0ZXh0OiBgX19yZWFjdFNlcnZlckNsaWVudENvbnRyb2xsZXIuZmFpbEFycml2YWwoKWAgfV0sIHJlcylcblxuXHRcdC8vTG9nIHRpbWVvdXQgZXJyb3IgYnV0IHN0aWxsIHJlc29sdmUgc28gd2UgY29udGludWUgaW4gdGhlIGxpZmVjeWNsZSBwcm9jZXNzXG5cdFx0bG9nZ2VyLmVycm9yKFwiRXJyb3IgaW4gd3JpdGVCb2R5XCIsIGVycik7XG5cdFx0cmV0dmFsLnJlc29sdmUoKTtcblx0fSk7XG5cblx0US5hbGwoZGZkcy5tYXAoZGZkID0+IGRmZC5wcm9taXNlKSkudGhlbih3cml0ZUJvZHlEZmQucmVzb2x2ZSk7XG5cblx0Y29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdC8vIGdpdmUgc29tZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHdoZW4gd2UgdGltZSBvdXRcblx0XHR3cml0ZUJvZHlEZmQucmVqZWN0KHtcblx0XHRcdG1lc3NhZ2U6IFwiVGltZWQgb3V0IHJlbmRlcmluZy5cIixcblx0XHRcdC8vIGB0aW1lUmVtYWluaW5nYCBpcyBob3cgbG9uZyB3ZSB3YWl0ZWQgYmVmb3JlIHRpbWluZyBvdXRcblx0XHRcdHRpbWVXYWl0ZWQ6IHRpbWVSZW1haW5pbmcsXG5cdFx0XHRlbGVtZW50czogcmVuZGVyZWQubWFwKHZhbCA9PiB7XG5cdFx0XHRcdGlmICh2YWwgPT09IEVMRU1FTlRfQUxSRUFEWV9XUklUVEVOKSB7XG5cdFx0XHRcdFx0cmV0dXJuICdXJzsgLy8gd3JpdHRlblxuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbCA9PT0gRUxFTUVOVF9QRU5ESU5HKSB7XG5cdFx0XHRcdFx0cmV0dXJuICdQJzsgLy8gbm90IHJlbmRlcmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuICdSJzsgLy8gcmVuZGVyZWQsIG5vdCB5ZXQgd3JpdHRlblxuXHRcdFx0XHR9XG5cdFx0XHR9KSxcblx0XHR9KTtcblx0fSwgdGltZVJlbWFpbmluZyk7XG5cblx0Ly8gRG9uJ3QgbGVhdmUgZGVhZCB0aW1lcnMgaGFuZ2luZyBhcm91bmQuXG5cdHdyaXRlQm9keURmZC5wcm9taXNlLnRoZW4oKCkgPT4ge1xuXHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHQvL3dyaXRlQm9keSByYW4gc3VjY2Vzc2Z1bGx5LCBzd2VldFxuXHRcdHJldHZhbC5yZXNvbHZlKCk7XG5cdH0pO1xuXG5cdHJldHVybiByZXR2YWwucHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gd3JpdGVSZXNwb25zZURhdGEocmVxLCByZXMsIGNvbnRleHQsIHN0YXJ0LCBwYWdlKSB7XG5cdHBhZ2Uuc2V0RXhwcmVzc1JlcXVlc3QocmVxKTtcblx0cGFnZS5zZXRFeHByZXNzUmVzcG9uc2UocmVzKTtcblx0cmV0dXJuIHBhZ2UuZ2V0UmVzcG9uc2VEYXRhKCkudGhlbihkYXRhID0+IHtcblx0XHRpZiAodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXMud3JpdGUoZGF0YSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gd3JpdGVEYXRhQnVuZGxlKHJlcSwgcmVzKSB7XG5cblx0Y29uc3QgY2FjaGUgPSBSZWFjdFNlcnZlckFnZW50LmNhY2hlKCk7XG5cblx0cmV0dXJuIFEuYWxsU2V0dGxlZChcblx0XHRjYWNoZS5nZXRQZW5kaW5nUmVxdWVzdHMoKS5tYXAodiA9PiB2LmVudHJ5LmRmZC5wcm9taXNlKVxuXHQpLnRoZW4oKCkgPT4gcmVzLndyaXRlKEpTT04uc3RyaW5naWZ5KGNhY2hlLmRlaHlkcmF0ZSgpKSkpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJFbGVtZW50KHJlcywgZWxlbWVudCwgY29udGV4dCkge1xuXG5cdGlmIChlbGVtZW50LmNvbnRhaW5lck9wZW4gfHwgZWxlbWVudC5jb250YWluZXJDbG9zZSB8fCBlbGVtZW50LmlzVGhlRm9sZCl7XG5cblx0XHQvLyBTaG9ydC1jaXJjdWl0IG91dC4gIERvbid0IHdhbnQgdGltaW5nIGZvciBjb250cm9sIG9iamVjdHMuXG5cdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdH1cblxuXHR2YXIgbmFtZSAgPSBQYWdlVXRpbC5nZXRFbGVtZW50RGlzcGxheU5hbWUoZWxlbWVudClcblx0LCAgIHN0YXJ0ID0gUkxTKCkuc3RhcnRUaW1lXG5cdCwgICB0aW1lciA9IGxvZ2dlci50aW1lcihgcmVuZGVyRWxlbWVudC5pbmRpdmlkdWFsLiR7bmFtZX1gKVxuXHQsICAgaHRtbCAgPSAnJ1xuXHQsICAgYXR0cnMgPSB7fVxuXG5cdHRyeSB7XG5cdFx0aWYgKGVsZW1lbnQgIT09IG51bGwpIHtcblx0XHRcdGh0bWwgPSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZyhcblx0XHRcdFx0UmVhY3QuY2xvbmVFbGVtZW50KGVsZW1lbnQsIHsgY29udGV4dDogY29udGV4dCB9KVxuXHRcdFx0KTtcblx0XHRcdGF0dHJzID0gZ2V0Um9vdEVsZW1lbnRBdHRyaWJ1dGVzKGVsZW1lbnQpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gQSBjb21wb25lbnQgZmFpbGluZyB0byByZW5kZXIgaXMgbm90IGZhdGFsLiAgV2UndmUgYWxyZWFkeVxuXHRcdC8vIHN0YXJ0ZWQgdGhlIHBhZ2Ugd2l0aCBhIDIwMCByZXNwb25zZS4gIFdlJ3ZlIGV2ZW4gb3BlbmVkXG5cdFx0Ly8gdGhlIGBkYXRhLXJlYWN0LXNlcnZlci1yb290LWlkYCBkaXYgZm9yIHRoaXMgY29tcG9uZW50LiAgV2UgbmVlZFxuXHRcdC8vIHRvIGNsb3NlIGl0IG91dCBhbmQgbW92ZSBvbi4gIFRoaXMgaXMgYSBidW1tZXIsIGFuZCB3ZSdsbFxuXHRcdC8vIGxvZyBpdCwgYnV0IGl0J3MgdG9vIGxhdGUgdG8gdG90YWxseSBiYWlsIG91dC5cblx0XHRsb2dnZXIuZXJyb3IoYEVycm9yIHdpdGggZWxlbWVudCAke25hbWV9J3MgbGlmZWN5Y2xlIG1ldGhvZHNgLCBlcnIpO1xuXHR9XG5cblx0Ly8gV2UgdGltZSBob3cgbG9uZyBfdGhpc18gZWxlbWVudCdzIHJlbmRlciB0b29rLCBhbmQgYWxzbyBob3cgbG9uZ1xuXHQvLyBzaW5jZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZXF1ZXN0IGl0IHRvb2sgdXMgdG8gc3BpdCB0aGlzIGVsZW1lbnRcblx0Ly8gb3V0LlxuXHR2YXIgaW5kaXZpZHVhbFRpbWUgPSB0aW1lci5zdG9wKCk7XG5cdGxvZ2dlci50aW1lKGByZW5kZXJFbGVtZW50LmZyb21TdGFydC4ke25hbWV9YCwgbmV3IERhdGUgLSBzdGFydCk7XG5cblx0Ly8gV2UgX2Fsc29fIGtlZXAgdHJhY2sgb2YgdGhlIF90b3RhbF8gdGltZSB3ZSBzcGVudCByZW5kZXJpbmcgZHVyaW5nXG5cdC8vIGVhY2ggcmVxdWVzdCBzbyB3ZSBjYW4ga2VlcCB0cmFjayBvZiB0aGF0IG92ZXJoZWFkLlxuXHRSTFMoKS5yZW5kZXJUaW1lIHx8IChSTFMoKS5yZW5kZXJUaW1lID0gMCk7XG5cdFJMUygpLnJlbmRlclRpbWUgKz0gaW5kaXZpZHVhbFRpbWU7XG5cblx0cmV0dXJuIHsgaHRtbCwgYXR0cnMgfTtcbn1cblxuLy8gV3JpdGUgYXMgbWFueSBlbGVtZW50cyBvdXQgaW4gYSByb3cgYXMgcG9zc2libGUgYW5kIHRoZW4gZmx1c2ggb3V0cHV0LlxuLy8gV2UgcmVuZGVyIGVsZW1lbnRzIGFzIHRoZWlyIGRhdGEgYmVjb21lcyBhdmFpbGFibGUsIHNvIHRoZXkgbWlnaHQgZmlsbCBpblxuLy8gb3V0LW9mLW9yZGVyLlxuZnVuY3Rpb24gd3JpdGVFbGVtZW50cyhyZXMsIGVsZW1lbnRzKSB7XG5cblx0Ly8gUGljayB1cCB3aGVyZSB3ZSBsZWZ0IG9mZi5cblx0dmFyIHN0YXJ0ID0gUkxTKCkubmV4dEVsZW1lbnR8fChSTFMoKS5uZXh0RWxlbWVudD0wKTtcblxuXHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbGVtZW50cy5sZW5ndGg7IFJMUygpLm5leHRFbGVtZW50ID0gKytpKXtcblxuXHRcdC8vIElmIHdlIGhhdmVuJ3QgcmVuZGVyZWQgdGhlIG5leHQgZWxlbWVudCB5ZXQsIHdlJ3JlIGRvbmUuXG5cdFx0aWYgKGVsZW1lbnRzW2ldID09PSBFTEVNRU5UX1BFTkRJTkcpIGJyZWFrO1xuXG5cdFx0Ly8gR290IG9uZSFcblx0XHR3cml0ZUVsZW1lbnQocmVzLCBlbGVtZW50c1tpXSwgaSk7XG5cblx0XHQvLyBGcmVlIGZvciBHQy5cblx0XHRlbGVtZW50c1tpXSA9IEVMRU1FTlRfQUxSRUFEWV9XUklUVEVOO1xuXG5cdFx0aWYgKFBhZ2VVdGlsLlBhZ2VDb25maWcuZ2V0KCdpc0ZyYWdtZW50JykpIGNvbnRpbnVlO1xuXG5cdFx0aWYgKFJMUygpLmhhdmVCb290c3RyYXBwZWQpIHtcblxuXHRcdFx0Ly8gV2UndmUgYWxyZWFkeSBib290c3RyYXBwZWQsIHNvIHdlIGNhbiBpbW1lZGlhdGVseSB0ZWxsIHRoZVxuXHRcdFx0Ly8gY2xpZW50IGNvbnRyb2xsZXIgdG8gd2FrZSB0aGUgbmV3IGVsZW1lbnQgd2UganVzdCBzZW50LlxuXHRcdFx0d2FrZUVsZW1lbnRSYW5nZShyZXMsIGksIGkpO1xuXHRcdH0gZWxzZSBpZiAoaSA9PT0gZWxlbWVudHMubGVuZ3RoIC0gMSkge1xuXG5cdFx0XHQvLyBQYWdlIGRpZG4ndCBlbWl0IGA8VGhlRm9sZC8+YC4gIE5vdyB3ZSdyZSBkb25lLlxuXHRcdFx0Ly8gVGhpcyB3YWtlcyBldmVyeXRoaW5nIHVwIHRocm91Z2ggYGlgLlxuXHRcdFx0Ym9vdHN0cmFwQ2xpZW50KHJlcywgaSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gSXQgbWF5IGJlIGEgd2hpbGUgYmVmb3JlIHdlIHJlbmRlciB0aGUgbmV4dCBlbGVtZW50LCBzbyBpZiB3ZSBqdXN0XG5cdC8vIHdyb3RlIGFueXRoaW5nIGxldCdzIHNlbmQgaXQgZG93biByaWdodCBhd2F5LlxuXHRpZiAoaSAhPT0gc3RhcnQpIGZsdXNoUmVzKHJlcyk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRWxlbWVudChyZXMsIGVsZW1lbnQsIGkpe1xuXHRpZiAoIWVsZW1lbnQpIHtcblx0XHQvLyBBIGZhbHN5IGVsZW1lbnQgd2FzIGEgcmVuZGVyIGVycm9yLiAgV2UndmUgZ290dGFcblx0XHQvLyBlbWl0IGEgcm9vdCBmb3IgaXQsIHNvIHdlJ2xsIGNvb2sgdXAgYW4gZW1wdHlcblx0XHQvLyBlbGVtZW50IG9iamVjdC5cblx0XHRlbGVtZW50ID0ge1xuXHRcdFx0YXR0cnMgOiB7fSxcblx0XHRcdGh0bWwgIDogJycsXG5cdFx0fVxuXHR9XG5cdGlmIChlbGVtZW50LmNvbnRhaW5lck9wZW4pIHtcblx0XHRyZXMud3JpdGUoYDxkaXYgJHtQQUdFX0NPTlRBSU5FUl9OT0RFX0lEfT0ke2l9JHtcblx0XHRcdF8ubWFwKGVsZW1lbnQuY29udGFpbmVyT3BlbiwgKHYsIGspID0+IGAgJHtrfT1cIiR7YXR0cmZ5KHYpfVwiYClcblx0XHR9PmApO1xuXHR9IGVsc2UgaWYgKGVsZW1lbnQuY29udGFpbmVyQ2xvc2UpIHtcblx0XHRyZXMud3JpdGUoJzwvZGl2PicpO1xuXHR9IGVsc2UgaWYgKGVsZW1lbnQuaXNUaGVGb2xkKSB7XG5cblx0XHQvLyBPa2F5LCB3ZSd2ZSBzZW50IGFsbCBvZiBvdXIgYWJvdmUtdGhlLWZvbGQgSFRNTCxcblx0XHQvLyBub3cgd2UgY2FuIGxldCB0aGUgY2xpZW50IHN0YXJ0IHdha2luZyBub2RlcyB1cC5cblx0XHRib290c3RyYXBDbGllbnQocmVzLCBpKVxuXHR9IGVsc2Uge1xuXHRcdHJlcy53cml0ZShgPGRpdiBkYXRhLXJlYWN0LXNlcnZlci1yb290LWlkPSR7XG5cdFx0XHRpXG5cdFx0fSBkYXRhLXJlYWN0LXNlcnZlci10aW1pbmctb2Zmc2V0PVwiJHtcblx0XHRcdC8vIE1hcmsgd2hlbiB3ZSBzZW50IGl0LlxuXHRcdFx0bmV3IERhdGUgLSBSTFMoKS50aW1pbmdEYXRhVDBcblx0XHR9XCIke1xuXHRcdFx0Xy5tYXAoZWxlbWVudC5hdHRycywgKHYsIGspID0+IGAgJHtrfT1cIiR7YXR0cmZ5KHYpfVwiYClcblx0XHR9PiR7ZWxlbWVudC5odG1sfTwvZGl2PmApO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGxvZ0Fib3ZlVGhlRm9sZFRpbWUocmVzKSB7XG5cdC8vIHdyaXRlIGEgc3luY2hyb25vdXMgc2NyaXB0IHRvIHJlY29yZCB0aGUgdGltZSBvbiB0aGUgYnJvd3NlciB3aGVuIGFib3ZlIHRoZSBmb2xkIGNvbnRlbnQgc2hvd3MgdXBcblx0Ly8gdGhpcyBpcyBhIHByb3h5IGZvciBcImZpcnN0IHBhaW50XCIgd2hlbiB0aGUgRE9NIGlzIHBhcnNlZCBhbmQgcGFpbnRlZFxuXHRyZW5kZXJTY3JpcHRzU3luYyhbe3RleHQ6J19fZGlzcGxheUFib3ZlVGhlRm9sZD1uZXcgRGF0ZTsnICtcblx0XHQnd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5tYXJrICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5tYXJrKFwiZGlzcGxheUFib3ZlVGhlRm9sZC5mcm9tU3RhcnRcIik7J31dLCByZXMpO1xufVxuXG5mdW5jdGlvbiBib290c3RyYXBDbGllbnQocmVzLCBsYXN0RWxlbWVudFNlbnQpIHtcblxuXHRsb2dBYm92ZVRoZUZvbGRUaW1lKHJlcyk7XG5cblx0aWYgKFJMUygpLnBhZ2UuZ2V0U3BsaXRKc0xvYWQoKSkge1xuXHRcdC8vIElmIHdlJ3ZlIGNvcmtlZCBvdXIgTEFCanMgY2hhaW4gdGhlbiB3ZSBuZWVkIHRvIHN0YXJ0IGV4ZWN1dGluZyBKUy5cblx0XHRyZW5kZXJTY3JpcHRzU3luYyhbe3RleHQ6J190TEFCLnVuY29yaygpJ31dLCByZXMpO1xuXHR9IGVsc2UgaWYgKFJMUygpLnBhZ2UuZ2V0SnNCZWxvd1RoZUZvbGQoKSkge1xuXHRcdC8vIE90aGVyd2lzZSBpZiB3ZSd2ZSBkZWZlcnJlZCBfYWxsXyBKUyBiZWxvdyB0aGUgZm9sZCB0aGVuIHdlIG5lZWQgdG9cblx0XHQvLyBraWNrIG9mZiBvdXIgZmV0Y2gvbG9hZCBvZiB0aGUgcGFnZSBKUyBub3cuXG5cdFx0cmVuZGVyU2NyaXB0cyhSTFMoKS5wYWdlLCByZXMpO1xuXHR9XG5cblx0dmFyIGluaXRpYWxDb250ZXh0ID0ge1xuXHRcdCdSZWFjdFNlcnZlckFnZW50LmNhY2hlJzogUmVhY3RTZXJ2ZXJBZ2VudC5jYWNoZSgpLmRlaHlkcmF0ZSgpLFxuXHRcdCdkZXZpY2VUeXBlJzogUmVxdWVzdENvbnRleHQuZ2V0Q3VycmVudFJlcXVlc3RDb250ZXh0KCkuZ2V0RGV2aWNlVHlwZSgpLFxuXHR9O1xuXG5cdHJlcy5leHBvc2UoaW5pdGlhbENvbnRleHQsICdJbml0aWFsQ29udGV4dCcpO1xuXHRyZXMuZXhwb3NlKGdldE5vbkludGVybmFsQ29uZmlncygpLCBcIkNvbmZpZ1wiKTtcblxuXHQvLyBVc2luZyBuYWtlZCBgcmZCb290c3RyYXAoKWAgaW5zdGVhZCBvZiBgd2luZG93LnJmQm9vdHN0cmFwKClgXG5cdC8vIGJlY2F1c2UgdGhlIGJyb3dzZXIncyBlcnJvciBtZXNzYWdlIGlmIGl0IGlzbid0IGRlZmluZWQgaXMgbW9yZVxuXHQvLyBoZWxwZnVsIHRoaXMgd2F5LiAgV2l0aCBgd2luZG93LnJmQm9vdHN0cmFwKClgIHRoZSBlcnJvciBpcyBqdXN0XG5cdC8vIFwidW5kZWZpbmVkIGlzIG5vdCBhIGZ1bmN0aW9uXCIuXG5cdHJlbmRlclNjcmlwdHNBc3luYyhbe1xuXHRcdHRleHQ6IGAke3Jlcy5sb2NhbHMuc3RhdGV9O3JmQm9vdHN0cmFwKCk7YCxcblx0fV0sIHJlcyk7XG5cblx0Ly8gVGhpcyBhY3R1YWxseSBuZWVkcyB0byBoYXBwZW4gX3N5bmNocm9ub3VzbHlfIHdpdGggdGhpcyBjdXJyZW50XG5cdC8vIGZ1bmN0aW9uIHRvIGF2b2lkIGxldHRpbmcgcmVzcG9uc2VzIHNsaXAgaW4gYmV0d2Vlbi5cblx0c2V0dXBMYXRlQXJyaXZhbHMocmVzKTtcblxuXHR3YWtlRWxlbWVudFJhbmdlKHJlcywgMCwgbGFzdEVsZW1lbnRTZW50KTtcblxuXHRSTFMoKS5oYXZlQm9vdHN0cmFwcGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FrZUVsZW1lbnRSYW5nZShyZXMsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG5cdGVuZEluZGV4ID0gZW5kSW5kZXggfHwgc3RhcnRJbmRleDtcblx0cmVuZGVyU2NyaXB0c0FzeW5jKFt7XG5cdFx0dGV4dDogYF9fcmVhY3RTZXJ2ZXJDbGllbnRDb250cm9sbGVyLm5vZGVBcnJpdmFsKCR7c3RhcnRJbmRleH0sJHtlbmRJbmRleH0pYCxcblx0fV0sIHJlcyk7XG59XG5cbmZ1bmN0aW9uIHNldHVwTGF0ZUFycml2YWxzKHJlcykge1xuXHR2YXIgc3RhcnQgPSBSTFMoKS5zdGFydFRpbWU7XG5cdHZhciBub3RMb2FkZWQgPSBSZWFjdFNlcnZlckFnZW50LmNhY2hlKCkuZ2V0UGVuZGluZ1JlcXVlc3RzKCk7XG5cblx0Ly8gVGhpcyBpcyBmb3IgcmVwb3J0aW5nIHB1cnBvc2VzLiAgV2UncmUgZ29pbmcgdG8gbG9nIGhvdyBtYW55IGxhdGVcblx0Ly8gcmVxdWVzdHMgdGhlcmUgd2VyZSwgYnV0IHdlIHdvbid0IGFjdHVhbGx5IGVtaXQgdGhlIGxvZyBsaW5lIHVudGlsXG5cdC8vIGFsbCBvZiB0aGUgcmVxdWVzdHMgaGF2ZSByZXNvbHZlZC5cblx0UmVhY3RTZXJ2ZXJBZ2VudC5jYWNoZSgpLm1hcmtMYXRlUmVxdWVzdHMoKTtcblxuXHRub3RMb2FkZWQuZm9yRWFjaCggcGVuZGluZ1JlcXVlc3QgPT4ge1xuXHRcdHBlbmRpbmdSZXF1ZXN0LmVudHJ5LndoZW5EYXRhUmVhZHlJbnRlcm5hbCgpLnRoZW4oICgpID0+IHtcblx0XHRcdGxvZ2dlci50aW1lKFwibGF0ZUFycml2YWxcIiwgbmV3IERhdGUgLSBzdGFydCk7XG5cdFx0XHRyZW5kZXJTY3JpcHRzQXN5bmMoW3tcblx0XHRcdFx0dGV4dDogYF9fcmVhY3RTZXJ2ZXJDbGllbnRDb250cm9sbGVyLmRhdGFBcnJpdmFsKCR7XG5cdFx0XHRcdFx0SlNPTi5zdHJpbmdpZnkocGVuZGluZ1JlcXVlc3QudXJsKVxuXHRcdFx0XHR9LCAke1xuXHRcdFx0XHRcdFN0cmluZ0VzY2FwZVV0aWwuZXNjYXBlRm9yU2NyaXB0VGFnKEpTT04uc3RyaW5naWZ5KHBlbmRpbmdSZXF1ZXN0LmVudHJ5LmRlaHlkcmF0ZSgpKSlcblx0XHRcdFx0fSk7YCxcblx0XHRcdH1dLCByZXMpO1xuXG5cdFx0fSlcblx0fSk7XG5cblx0Ly8gVE9ETzogbWF4aW11bS13YWl0LXRpbWUtZXhjZWVkZWQtc28tY2FuY2VsLXBlbmRpbmctcmVxdWVzdHMgY29kZVxuXHR2YXIgcHJvbWlzZXMgPSBub3RMb2FkZWQubWFwKCByZXN1bHQgPT4gcmVzdWx0LmVudHJ5LmRmZC5wcm9taXNlICk7XG5cdFJMUygpLmxhdGVBcnJpdmFscyA9IFEuYWxsU2V0dGxlZChwcm9taXNlcylcbn1cblxuZnVuY3Rpb24gd3JhcFVwTGF0ZUFycml2YWxzKCl7XG5cdHJldHVybiBSTFMoKS5sYXRlQXJyaXZhbHM7XG59XG5cbmZ1bmN0aW9uIGNsb3NlQm9keShyZXEsIHJlcykge1xuXHQvLyBGbHVzaCB0aW1pbmcvbG9nIGRhdGEgdG8gdGhlIHJlc3BvbnNlIGRvY3VtZW50XG5cdGlmIChEZWJ1Z1V0aWwuZ2V0T3V0cHV0TG9ncygpKSB7XG5cdFx0Zmx1c2hMb2dzVG9SZXNwb25zZShyZXMpO1xuXHR9XG5cdHJlcy53cml0ZShcIjwvZGl2PjwvYm9keT48L2h0bWw+XCIpO1xuXHRyZXR1cm4gUSgpO1xufVxuXG5mdW5jdGlvbiBlbmRSZXNwb25zZShyZXEsIHJlcykge1xuXHRyZXMuZW5kKCk7XG5cdHJldHVybiBRKCk7XG59XG5cbmZ1bmN0aW9uIGxvZ1JlcXVlc3RTdGF0cyhyZXEsIHJlcywgY29udGV4dCwgc3RhcnQpe1xuXHR2YXIgYWxsUmVxdWVzdHMgPSBSZWFjdFNlcnZlckFnZW50LmNhY2hlKCkuZ2V0QWxsUmVxdWVzdHMoKVxuXHQsICAgbm90TG9hZGVkICAgPSBSZWFjdFNlcnZlckFnZW50LmNhY2hlKCkuZ2V0TGF0ZVJlcXVlc3RzKClcblx0LCAgIHNvY2sgICAgICAgID0gcmVxLnNvY2tldFxuXHQsICAgc3Rhc2ggICAgICAgPSBjb250ZXh0LmdldFNlcnZlclN0YXNoKClcblxuXHQvLyBUaGUgc29ja2V0IGNhbiBiZSByZS11c2VkIGZvciBtdWx0aXBsZSByZXF1ZXN0cyB3aXRoIGtlZXAtYWxpdmUuXG5cdC8vIEZvcnR1bmF0ZWx5LCB1bnRpbCBIVFRQLzIgcm9sbHMgYXJvdW5kLCB0aGUgcmVxdWVzdHMgb3ZlciBhIGdpdmVuXG5cdC8vIHNvY2tldCB3aWxsIGhhcHBlbiBzZXJpYWxseS4gIFNvIHdlIGNhbiBqdXN0IGtlZXAgdHJhY2sgb2YgdGhlXG5cdC8vIHByZXZpb3VzIHZhbHVlcyBmb3IgZWFjaCBzb2NrZXQgYW5kIGxvZyB0aGUgZGVsdGEgZm9yIGEgZ2l2ZW5cblx0Ly8gcmVxdWVzdC5cblx0c3Rhc2guYnl0ZXNSID0gc29jay5ieXRlc1JlYWQgICAgLSAoc29jay5fcHJlUnx8KHNvY2suX3ByZVI9MCkpO1xuXHRzdGFzaC5ieXRlc1cgPSBzb2NrLmJ5dGVzV3JpdHRlbiAtIChzb2NrLl9wcmVXfHwoc29jay5fcHJlVz0wKSk7XG5cblx0c29jay5fcHJlUiArPSBzdGFzaC5ieXRlc1I7XG5cdHNvY2suX3ByZVcgKz0gc3Rhc2guYnl0ZXNXO1xuXG5cdGxvZ2dlci5nYXVnZShcImNvdW50RGF0YVJlcXVlc3RzXCIsIGFsbFJlcXVlc3RzLmxlbmd0aCk7XG5cdGxvZ2dlci5nYXVnZShcImNvdW50TGF0ZUFycml2YWxzXCIsIG5vdExvYWRlZC5sZW5ndGgsIHtoaTogMX0pO1xuXHRsb2dnZXIuZ2F1Z2UoXCJieXRlc1JlYWRcIiwgc3Rhc2guYnl0ZXNSLCB7aGk6IDE8PDEyfSk7XG5cdGxvZ2dlci5nYXVnZShcImJ5dGVzV3JpdHRlblwiLCBzdGFzaC5ieXRlc1csIHtoaTogMTw8MTh9KTtcblxuXHR2YXIgdGltZSA9IG5ldyBEYXRlIC0gc3RhcnQ7XG5cblx0bG9nZ2VyLnRpbWUoYHJlc3BvbnNlQ29kZS4ke3Jlcy5zdGF0dXNDb2RlfWAsIHRpbWUpO1xuXHRsb2dnZXIudGltZShcInRvdGFsUmVxdWVzdFRpbWVcIiwgdGltZSk7XG5cblx0Ly8gT25seSBwb3B1bGF0ZWQgZm9yIGZ1bGwgcGFnZXMgYW5kIGZyYWdtZW50cy5cblx0aWYgKFJMUygpLnJlbmRlclRpbWUpe1xuXHRcdGxvZ2dlci50aW1lKFwidG90YWxSZW5kZXJUaW1lXCIsIFJMUygpLnJlbmRlclRpbWUpO1xuXHR9XG5cblx0aWYgKG5vdExvYWRlZC5sZW5ndGgpIHtcblx0XHRsb2dnZXIudGltZShcInRvdGFsUmVxdWVzdFRpbWVXaXRoTGF0ZUFycml2YWxzXCIsIHRpbWUpO1xuXHR9XG5cblx0cmV0dXJuIFEoKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9uSW50ZXJuYWxDb25maWdzKCkge1xuXHR2YXIgbm9uSW50ZXJuYWwgPSB7fTtcblx0dmFyIGZ1bGxDb25maWcgPSBjb25maWcoKTtcblx0T2JqZWN0LmtleXMoZnVsbENvbmZpZykuZm9yRWFjaCggY29uZmlnS2V5ID0+IHtcblx0XHRpZiAoY29uZmlnS2V5ICE9PSAnaW50ZXJuYWwnKSB7XG5cdFx0XHRub25JbnRlcm5hbFtjb25maWdLZXldID0gZnVsbENvbmZpZ1tjb25maWdLZXldO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBub25JbnRlcm5hbDtcbn1cblxuZnVuY3Rpb24gZ2V0RGV2aWNlVHlwZShyZXEpIHtcblx0dmFyIG1kID0gbmV3IE1vYmlsZURldGVjdChyZXEuZ2V0KCd1c2VyLWFnZW50JykpO1xuXG5cdC8vIFwibW9iaWxlXCIgaXMgdGhlIHVuaW9uIG9mIFwicGhvbmVcIiBhbmQgXCJ0YWJsZXRcIiBfZXhjZXB0XyBmb3Jcblx0Ly8gXCJ1bmtub3duXCIgbW9iaWxlIGRldmljZXMsIHdoaWNoIGFyZSBfbmVpdGhlcl8gcGhvbmUgX25vcl8gdGFibGV0LlxuXHQvL1xuXHQvLyBodHRwOi8vaGdvZWJsLmdpdGh1Yi5pby9tb2JpbGUtZGV0ZWN0LmpzL2RvYy9Nb2JpbGVEZXRlY3QuaHRtbCNtb2JpbGVcblx0Ly9cblx0Ly8gOnJhZ2U6XG5cdC8vXG5cdC8vIFdlJ2xsIGNhbGwgdGhlbSBcInBob25lXCIgdG8gYXZvaWQgaW50cm9kdWNpbmcgYSB3ZWlyZCB0aGlyZCBkZXZpY2Vcblx0Ly8gdHlwZSB0aGF0IGRlcGVuZHMgb24gdGhpcyBpbXBsZW1lbnRhdGlvbiBxdWlyayBvZiBtb2JpbGUtZGV0ZWN0LlxuXHQvL1xuXHRpZiAobWQudGFibGV0KCkpIHJldHVybiBcInRhYmxldFwiO1xuXHRpZiAobWQucGhvbmUgKCkpIHJldHVybiBcInBob25lXCI7XG5cdGlmIChtZC5tb2JpbGUoKSkgcmV0dXJuIFwicGhvbmVcIjtcblx0cmV0dXJuIFwiZGVza3RvcFwiO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5fdGVzdEZ1bmN0aW9ucyA9IHtcblx0cmVuZGVyTWV0YVRhZ3MsXG5cdHJlbmRlckxpbmtUYWdzLFxuXHRyZW5kZXJCYXNlVGFnLFxufTtcbiJdfQ==
