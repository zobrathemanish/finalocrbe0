module.exports = "/*! LAB.js (LABjs :: Loading And Blocking JavaScript)\n"+
"    v2.0.3 (c) Kyle Simpson\n"+
"    MIT License\n"+
"*/\n"+
"\n"+
"(function(global){\n"+
"	var _$LAB = global.$LAB,\n"+
"\n"+
"		// constants for the valid keys of the options object\n"+
"		_UseLocalXHR = \"UseLocalXHR\",\n"+
"		_UseCORSXHR = \"UseCORSXHR\",\n"+
"		_AlwaysPreserveOrder = \"AlwaysPreserveOrder\",\n"+
"		_AllowDuplicates = \"AllowDuplicates\",\n"+
"		_CacheBust = \"CacheBust\",\n"+
"		/*!START_DEBUG*/_Debug = \"Debug\",/*!END_DEBUG*/\n"+
"		_BasePath = \"BasePath\",\n"+
"\n"+
"		// stateless variables used across all $LAB instances\n"+
"		root_page = /^[^?#]*\\//.exec(location.href)[0],\n"+
"		root_domain = /^\\w+\\:\\/\\/\\/?[^\\/]+/.exec(root_page)[0],\n"+
"		append_to = document.head || document.getElementsByTagName(\"head\"),\n"+
"\n"+
"		// inferences... ick, but still necessary\n"+
"		opera_or_gecko = (global.opera && Object.prototype.toString.call(global.opera) == \"[object Opera]\") || (\"MozAppearance\" in document.documentElement.style),\n"+
"\n"+
"/*!START_DEBUG*/\n"+
"		// console.log() and console.error() wrappers\n"+
"		log_msg = function(){},\n"+
"		log_error = log_msg,\n"+
"/*!END_DEBUG*/\n"+
"\n"+
"		// feature sniffs (yay!)\n"+
"		test_script_elem = document.createElement(\"script\"),\n"+
"		explicit_preloading = typeof test_script_elem.preload == \"boolean\", // http://wiki.whatwg.org/wiki/Script_Execution_Control#Proposal_1_.28Nicholas_Zakas.29\n"+
"		real_preloading = explicit_preloading || (test_script_elem.readyState && test_script_elem.readyState == \"uninitialized\"), // will a script preload with `src` set before DOM append?\n"+
"		script_ordered_async = !real_preloading && test_script_elem.async === true, // http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\n"+
"\n"+
"		// XHR preloading (same-domain) and cache-preloading (remote-domain) are the fallbacks (for some browsers)\n"+
"		xhr_or_cache_preloading = !real_preloading && !script_ordered_async && !opera_or_gecko\n"+
"	;\n"+
"\n"+
"/*!START_DEBUG*/\n"+
"	// define console wrapper functions if applicable\n"+
"	if (global.console && global.console.log) {\n"+
"		if (!global.console.error) global.console.error = global.console.log;\n"+
"		log_msg = function(msg) { global.console.log(msg); };\n"+
"		log_error = function(msg,err) { global.console.error(msg,err); };\n"+
"	}\n"+
"/*!END_DEBUG*/\n"+
"\n"+
"	// test for function\n"+
"	function is_func(func) { return Object.prototype.toString.call(func) == \"[object Function]\"; }\n"+
"\n"+
"	// test for array\n"+
"	function is_array(arr) { return Object.prototype.toString.call(arr) == \"[object Array]\"; }\n"+
"\n"+
"	// make script URL absolute/canonical\n"+
"	function canonical_uri(src,base_path) {\n"+
"		var absolute_regex = /^\\w+\\:\\/\\//;\n"+
"\n"+
"		// is `src` is protocol-relative (begins with // or ///), prepend protocol\n"+
"		if (/^\\/\\/\\/?/.test(src)) {\n"+
"			src = location.protocol + src;\n"+
"		}\n"+
"		// is `src` page-relative? (not an absolute URL, and not a domain-relative path, beginning with /)\n"+
"		else if (!absolute_regex.test(src) && src.charAt(0) != \"/\") {\n"+
"			// prepend `base_path`, if any\n"+
"			src = (base_path || \"\") + src;\n"+
"		}\n"+
"		// make sure to return `src` as absolute\n"+
"		return absolute_regex.test(src) ? src : ((src.charAt(0) == \"/\" ? root_domain : root_page) + src);\n"+
"	}\n"+
"\n"+
"	// merge `source` into `target`\n"+
"	function merge_objs(source,target) {\n"+
"		for (var k in source) { if (source.hasOwnProperty(k)) {\n"+
"			target[k] = source[k]; // TODO: does this need to be recursive for our purposes?\n"+
"		}}\n"+
"		return target;\n"+
"	}\n"+
"\n"+
"	// does the chain group have any ready-to-execute scripts?\n"+
"	function check_chain_group_scripts_ready(chain_group) {\n"+
"		var any_scripts_ready = false;\n"+
"		for (var i=0; i<chain_group.scripts.length; i++) {\n"+
"			if (chain_group.scripts[i].ready && chain_group.scripts[i].exec_trigger) {\n"+
"				any_scripts_ready = true;\n"+
"				chain_group.scripts[i].exec_trigger();\n"+
"				chain_group.scripts[i].exec_trigger = null;\n"+
"			}\n"+
"		}\n"+
"		return any_scripts_ready;\n"+
"	}\n"+
"\n"+
"	// creates a script load listener\n"+
"	function create_script_load_listener(elem,registry_item,flag,onload) {\n"+
"		elem.onload = elem.onreadystatechange = function() {\n"+
"			if ((elem.readyState && elem.readyState != \"complete\" && elem.readyState != \"loaded\") || registry_item[flag]) return;\n"+
"			elem.onload = elem.onreadystatechange = null;\n"+
"			onload();\n"+
"		};\n"+
"	}\n"+
"\n"+
"	// script executed handler\n"+
"	function script_executed(registry_item) {\n"+
"		registry_item.ready = registry_item.finished = true;\n"+
"		for (var i=0; i<registry_item.finished_listeners.length; i++) {\n"+
"			registry_item.finished_listeners[i]();\n"+
"		}\n"+
"		registry_item.ready_listeners = [];\n"+
"		registry_item.finished_listeners = [];\n"+
"	}\n"+
"\n"+
"	// make the request for a scriptha\n"+
"	function request_script(chain_opts,script_obj,registry_item,onload,preload_this_script) {\n"+
"		// setTimeout() \"yielding\" prevents some weird race/crash conditions in older browsers\n"+
"		setTimeout(function(){\n"+
"			var script, src = script_obj.real_src, xhr;\n"+
"\n"+
"			// don't proceed until `append_to` is ready to append to\n"+
"			if (\"item\" in append_to) { // check if `append_to` ref is still a live node list\n"+
"				if (!append_to[0]) { // `append_to` node not yet ready\n"+
"					// try again in a little bit -- note: will re-call the anonymous function in the outer setTimeout, not the parent `request_script()`\n"+
"					setTimeout(arguments.callee,25);\n"+
"					return;\n"+
"				}\n"+
"				// reassign from live node list ref to pure node ref -- avoids nasty IE bug where changes to DOM invalidate live node lists\n"+
"				append_to = append_to[0];\n"+
"			}\n"+
"			script = document.createElement(\"script\");\n"+
"			if (script_obj.type) script.type = script_obj.type;\n"+
"			if (script_obj.charset) script.charset = script_obj.charset;\n"+
"			if (script_obj.crossOrigin) script.crossOrigin = script_obj.crossOrigin;\n"+
"\n"+
"			// should preloading be used for this script?\n"+
"			if (preload_this_script) {\n"+
"				// real script preloading?\n"+
"				if (real_preloading) {\n"+
"					if (chain_opts[_Debug]) log_msg(\"start script preload: \"+src);\n"+
"					registry_item.elem = script;\n"+
"					if (explicit_preloading) { // explicit preloading (aka, Zakas' proposal)\n"+
"						script.preload = true;\n"+
"						script.onpreload = onload;\n"+
"					}\n"+
"					else {\n"+
"						script.onreadystatechange = function(){\n"+
"							if (script.readyState == \"loaded\") onload();\n"+
"						};\n"+
"					}\n"+
"					script.src = src;\n"+
"					// NOTE: no append to DOM yet, appending will happen when ready to execute\n"+
"				}\n"+
"\n"+
"				// This is the ultimate fallback in React Server.  The\n"+
"				// \"cache-preloading\" option in stock LABjs doesn't work in\n"+
"				// modern Chrome, so... this is our last best hope.  If you're\n"+
"				// configured for splitJsLoadFromExecution then you'd better\n"+
"				// have xhr access to your scripts!  They need to either be on\n"+
"				// the same domain or have CORS headers.\n"+
"				else if (chain_opts[_UseCORSXHR] || (src.indexOf(root_domain) == 0 && chain_opts[_UseLocalXHR])) {\n"+
"					xhr = new XMLHttpRequest(); // note: IE never uses XHR (it supports true preloading), so no more need for ActiveXObject fallback for IE <= 7\n"+
"					if (chain_opts[_Debug]) log_msg(\"start script preload (xhr): \"+src);\n"+
"					xhr.onreadystatechange = function() {\n"+
"						if (xhr.readyState == 4) {\n"+
"							xhr.onreadystatechange = function(){}; // fix a memory leak in IE\n"+
"							registry_item.text = xhr.responseText + \"\\n//@ sourceURL=\" + src; // http://blog.getfirebug.com/2009/08/11/give-your-eval-a-name-with-sourceurl/\n"+
"							onload();\n"+
"						}\n"+
"					};\n"+
"					xhr.open(\"GET\",src);\n"+
"					xhr.send();\n"+
"				}\n"+
"				// as a last resort, use cache-preloading\n"+
"				else {\n"+
"					if (chain_opts[_Debug]) log_msg(\"start script preload (cache): \"+src);\n"+
"					script.type = \"text/cache-script\";\n"+
"					create_script_load_listener(script,registry_item,\"ready\",function() {\n"+
"						append_to.removeChild(script);\n"+
"						onload();\n"+
"					});\n"+
"					script.src = src;\n"+
"					append_to.insertBefore(script,append_to.firstChild);\n"+
"				}\n"+
"			}\n"+
"			// use async=false for ordered async? parallel-load-serial-execute http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\n"+
"			else if (script_ordered_async) {\n"+
"				if (chain_opts[_Debug]) log_msg(\"start script load (ordered async): \"+src);\n"+
"				script.async = false;\n"+
"				create_script_load_listener(script,registry_item,\"finished\",onload);\n"+
"				script.src = src;\n"+
"				append_to.insertBefore(script,append_to.firstChild);\n"+
"			}\n"+
"			// otherwise, just a normal script element\n"+
"			else {\n"+
"				if (chain_opts[_Debug]) log_msg(\"start script load: \"+src);\n"+
"				create_script_load_listener(script,registry_item,\"finished\",onload);\n"+
"				script.src = src;\n"+
"				append_to.insertBefore(script,append_to.firstChild);\n"+
"			}\n"+
"		},0);\n"+
"	}\n"+
"\n"+
"	// create a clean instance of $LAB\n"+
"	function create_sandbox() {\n"+
"		var global_defaults = {},\n"+
"			can_use_preloading = real_preloading || xhr_or_cache_preloading,\n"+
"			queue = [],\n"+
"			registry = {},\n"+
"			instanceAPI\n"+
"		;\n"+
"\n"+
"		// global defaults\n"+
"		global_defaults[_UseLocalXHR] = true;\n"+
"		global_defaults[_UseCORSXHR] = false;\n"+
"		global_defaults[_AlwaysPreserveOrder] = false;\n"+
"		global_defaults[_AllowDuplicates] = false;\n"+
"		global_defaults[_CacheBust] = false;\n"+
"		/*!START_DEBUG*/global_defaults[_Debug] = true;/*!END_DEBUG*/\n"+
"		global_defaults[_BasePath] = \"\";\n"+
"\n"+
"		// execute a script that has been preloaded already\n"+
"		function execute_preloaded_script(chain_opts,script_obj,registry_item) {\n"+
"			var script;\n"+
"\n"+
"			function preload_execute_finished() {\n"+
"				if (script != null) { // make sure this only ever fires once\n"+
"					script = null;\n"+
"					script_executed(registry_item);\n"+
"				}\n"+
"			}\n"+
"\n"+
"			if (registry[script_obj.src].finished) return;\n"+
"			if (!chain_opts[_AllowDuplicates]) registry[script_obj.src].finished = true;\n"+
"\n"+
"			script = registry_item.elem || document.createElement(\"script\");\n"+
"			if (script_obj.type) script.type = script_obj.type;\n"+
"			if (script_obj.charset) script.charset = script_obj.charset;\n"+
"			if (script_obj.crossOrigin) script.crossOrigin = script_obj.crossOrigin;\n"+
"			create_script_load_listener(script,registry_item,\"finished\",preload_execute_finished);\n"+
"\n"+
"			// script elem was real-preloaded\n"+
"			if (registry_item.elem) {\n"+
"				registry_item.elem = null;\n"+
"			}\n"+
"			// script was XHR preloaded\n"+
"			else if (registry_item.text) {\n"+
"				script.onload = script.onreadystatechange = null;	// script injection doesn't fire these events\n"+
"				script.text = registry_item.text;\n"+
"			}\n"+
"			// script was cache-preloaded\n"+
"			else {\n"+
"				script.src = script_obj.real_src;\n"+
"			}\n"+
"			append_to.insertBefore(script,append_to.firstChild);\n"+
"\n"+
"			// manually fire execution callback for injected scripts, since events don't fire\n"+
"			if (registry_item.text) {\n"+
"				preload_execute_finished();\n"+
"			}\n"+
"		}\n"+
"\n"+
"		// process the script request setup\n"+
"		function do_script(chain_opts,script_obj,chain_group,preload_this_script) {\n"+
"			var registry_item,\n"+
"				registry_items,\n"+
"				ready_cb = function(){ script_obj.ready_cb(script_obj,function(){ execute_preloaded_script(chain_opts,script_obj,registry_item); }); },\n"+
"				finished_cb = function(){ script_obj.finished_cb(script_obj,chain_group); }\n"+
"			;\n"+
"\n"+
"			script_obj.src = canonical_uri(script_obj.src,chain_opts[_BasePath]);\n"+
"			script_obj.real_src = script_obj.src +\n"+
"				// append cache-bust param to URL?\n"+
"				(chain_opts[_CacheBust] ? ((/\\?.*$/.test(script_obj.src) ? \"&_\" : \"?_\") + ~~(Math.random()*1E9) + \"=\") : \"\")\n"+
"			;\n"+
"\n"+
"			if (!registry[script_obj.src]) registry[script_obj.src] = {items:[],finished:false};\n"+
"			registry_items = registry[script_obj.src].items;\n"+
"\n"+
"			// allowing duplicates, or is this the first recorded load of this script?\n"+
"			if (chain_opts[_AllowDuplicates] || registry_items.length == 0) {\n"+
"				registry_item = registry_items[registry_items.length] = {\n"+
"					ready:false,\n"+
"					finished:false,\n"+
"					ready_listeners:[ready_cb],\n"+
"					finished_listeners:[finished_cb]\n"+
"				};\n"+
"\n"+
"				request_script(chain_opts,script_obj,registry_item,\n"+
"					// which callback type to pass?\n"+
"					(\n"+
"					 	(preload_this_script) ? // depends on script-preloading\n"+
"						function(){\n"+
"							registry_item.ready = true;\n"+
"							for (var i=0; i<registry_item.ready_listeners.length; i++) {\n"+
"								registry_item.ready_listeners[i]();\n"+
"							}\n"+
"							registry_item.ready_listeners = [];\n"+
"						} :\n"+
"						function(){ script_executed(registry_item); }\n"+
"					),\n"+
"					// signal if script-preloading should be used or not\n"+
"					preload_this_script\n"+
"				);\n"+
"			}\n"+
"			else {\n"+
"				registry_item = registry_items[0];\n"+
"				if (registry_item.finished) {\n"+
"					finished_cb();\n"+
"				}\n"+
"				else {\n"+
"					registry_item.finished_listeners.push(finished_cb);\n"+
"				}\n"+
"			}\n"+
"		}\n"+
"\n"+
"		// creates a closure for each separate chain spawned from this $LAB instance, to keep state cleanly separated between chains\n"+
"		function create_chain() {\n"+
"			var chainedAPI,\n"+
"				chain_opts = merge_objs(global_defaults,{}),\n"+
"				chain = [],\n"+
"				exec_cursor = 0,\n"+
"				scripts_currently_loading = false,\n"+
"				chain_is_corked = false,\n"+
"				group\n"+
"			;\n"+
"\n"+
"			// called when a script has finished preloading\n"+
"			function chain_script_ready(script_obj,exec_trigger) {\n"+
"				if (chain_opts[_Debug]) log_msg(\"script preload finished: \"+script_obj.real_src);\n"+
"				script_obj.ready = true;\n"+
"				script_obj.exec_trigger = function() {\n"+
"					if (chain_opts[_Debug]) log_msg(\"script execute start: \"+script_obj.real_src);\n"+
"					exec_trigger();\n"+
"				}\n"+
"				advance_exec_cursor(); // will only check for 'ready' scripts to be executed\n"+
"			}\n"+
"\n"+
"			// called when a script has finished executing\n"+
"			function chain_script_executed(script_obj,chain_group) {\n"+
"				if (chain_opts[_Debug]) log_msg(\"script execution finished: \"+script_obj.real_src);\n"+
"				script_obj.ready = script_obj.finished = true;\n"+
"				script_obj.exec_trigger = null;\n"+
"				// check if chain group is all finished\n"+
"				for (var i=0; i<chain_group.scripts.length; i++) {\n"+
"					if (!chain_group.scripts[i].finished) return;\n"+
"				}\n"+
"				// chain_group is all finished if we get this far\n"+
"				chain_group.finished = true;\n"+
"				advance_exec_cursor();\n"+
"			}\n"+
"\n"+
"			// main driver for executing each part of the chain\n"+
"			function advance_exec_cursor() {\n"+
"				if (chain_is_corked) return;\n"+
"				while (exec_cursor < chain.length) {\n"+
"					if (is_func(chain[exec_cursor])) {\n"+
"						if (chain_opts[_Debug]) log_msg(\"$LAB.wait() executing: \"+chain[exec_cursor]);\n"+
"						try { chain[exec_cursor++](); } catch (err) {\n"+
"							if (chain_opts[_Debug]) log_error(\"$LAB.wait() error caught: \",err);\n"+
"						}\n"+
"						continue;\n"+
"					}\n"+
"					else if (!chain[exec_cursor].finished) {\n"+
"						if (check_chain_group_scripts_ready(chain[exec_cursor])) continue;\n"+
"						break;\n"+
"					}\n"+
"					exec_cursor++;\n"+
"				}\n"+
"				// we've reached the end of the chain (so far)\n"+
"				if (exec_cursor == chain.length) {\n"+
"					scripts_currently_loading = false;\n"+
"					group = false;\n"+
"				}\n"+
"			}\n"+
"\n"+
"			// setup next chain script group\n"+
"			function init_script_chain_group() {\n"+
"				if (!group || !group.scripts) {\n"+
"					chain.push(group = {scripts:[],finished:true});\n"+
"				}\n"+
"			}\n"+
"\n"+
"			// API for $LAB chains\n"+
"			chainedAPI = {\n"+
"				// start loading one or more scripts\n"+
"				script:function(){\n"+
"					for (var i=0; i<arguments.length; i++) {\n"+
"						(function(script_obj,script_list){\n"+
"							var splice_args;\n"+
"\n"+
"							if (!is_array(script_obj)) {\n"+
"								script_list = [script_obj];\n"+
"							}\n"+
"							for (var j=0; j<script_list.length; j++) {\n"+
"								init_script_chain_group();\n"+
"								script_obj = script_list[j];\n"+
"\n"+
"								if (is_func(script_obj)) script_obj = script_obj();\n"+
"								if (!script_obj) continue;\n"+
"								if (is_array(script_obj)) {\n"+
"									// set up an array of arguments to pass to splice()\n"+
"									splice_args = [].slice.call(script_obj); // first include the actual array elements we want to splice in\n"+
"									splice_args.unshift(j,1); // next, put the `index` and `howMany` parameters onto the beginning of the splice-arguments array\n"+
"									[].splice.apply(script_list,splice_args); // use the splice-arguments array as arguments for splice()\n"+
"									j--; // adjust `j` to account for the loop's subsequent `j++`, so that the next loop iteration uses the same `j` index value\n"+
"									continue;\n"+
"								}\n"+
"								if (typeof script_obj == \"string\") script_obj = {src:script_obj};\n"+
"								script_obj = merge_objs(script_obj,{\n"+
"									ready:false,\n"+
"									ready_cb:chain_script_ready,\n"+
"									finished:false,\n"+
"									finished_cb:chain_script_executed\n"+
"								});\n"+
"								group.finished = false;\n"+
"								group.scripts.push(script_obj);\n"+
"								do_script(chain_opts,script_obj,group,(\n"+
"									(can_use_preloading && scripts_currently_loading) || chain_is_corked\n"+
"								));\n"+
"								scripts_currently_loading = true;\n"+
"\n"+
"								if (chain_opts[_AlwaysPreserveOrder]) chainedAPI.wait();\n"+
"							}\n"+
"						})(arguments[i],arguments[i]);\n"+
"					}\n"+
"					return chainedAPI;\n"+
"				},\n"+
"				// force LABjs to pause in execution at this point in the chain, until the execution thus far finishes, before proceeding\n"+
"				wait:function(){\n"+
"					if (arguments.length > 0) {\n"+
"						for (var i=0; i<arguments.length; i++) {\n"+
"							chain.push(arguments[i]);\n"+
"						}\n"+
"						group = chain[chain.length-1];\n"+
"					}\n"+
"					else group = false;\n"+
"\n"+
"					advance_exec_cursor();\n"+
"\n"+
"					return chainedAPI;\n"+
"				},\n"+
"				cork:function(){\n"+
"					if (chain_opts[_Debug]) log_msg(\"$LAB.cork()\");\n"+
"					chain_is_corked = true;\n"+
"					return chainedAPI;\n"+
"				},\n"+
"				uncork:function(){\n"+
"					if (chain_opts[_Debug]) log_msg(\"$LAB.uncork()\");\n"+
"					if (chain_is_corked) {\n"+
"						chain_is_corked = false;\n"+
"						advance_exec_cursor();\n"+
"					}\n"+
"					return chainedAPI;\n"+
"				}\n"+
"			};\n"+
"\n"+
"			// the first chain link API (includes `setOptions` only this first time)\n"+
"			return {\n"+
"				script:chainedAPI.script,\n"+
"				wait:chainedAPI.wait,\n"+
"				cork:chainedAPI.cork,\n"+
"				uncork:chainedAPI.uncork,\n"+
"				setOptions:function(opts){\n"+
"					merge_objs(opts,chain_opts);\n"+
"					return chainedAPI;\n"+
"				}\n"+
"			};\n"+
"		}\n"+
"\n"+
"		// API for each initial $LAB instance (before chaining starts)\n"+
"		instanceAPI = {\n"+
"			// main API functions\n"+
"			setGlobalDefaults:function(opts){\n"+
"				merge_objs(opts,global_defaults);\n"+
"				return instanceAPI;\n"+
"			},\n"+
"			setOptions:function(){\n"+
"				return create_chain().setOptions.apply(null,arguments);\n"+
"			},\n"+
"			script:function(){\n"+
"				return create_chain().script.apply(null,arguments);\n"+
"			},\n"+
"			wait:function(){\n"+
"				return create_chain().wait.apply(null,arguments);\n"+
"			},\n"+
"			cork:function(){\n"+
"				return create_chain().cork.apply(null,arguments);\n"+
"			},\n"+
"\n"+
"			// built-in queuing for $LAB `script()` and `wait()` calls\n"+
"			// useful for building up a chain programmatically across various script locations, and simulating\n"+
"			// execution of the chain\n"+
"			queueScript:function(){\n"+
"				queue[queue.length] = {type:\"script\", args:[].slice.call(arguments)};\n"+
"				return instanceAPI;\n"+
"			},\n"+
"			queueWait:function(){\n"+
"				queue[queue.length] = {type:\"wait\", args:[].slice.call(arguments)};\n"+
"				return instanceAPI;\n"+
"			},\n"+
"			runQueue:function(){\n"+
"				var $L = instanceAPI, len=queue.length, i=len, val;\n"+
"				for (;--i>=0;) {\n"+
"					val = queue.shift();\n"+
"					$L = $L[val.type].apply(null,val.args);\n"+
"				}\n"+
"				return $L;\n"+
"			},\n"+
"\n"+
"			// rollback `[global].$LAB` to what it was before this file was loaded, the return this current instance of $LAB\n"+
"			noConflict:function(){\n"+
"				global.$LAB = _$LAB;\n"+
"				return instanceAPI;\n"+
"			},\n"+
"\n"+
"			// create another clean instance of $LAB\n"+
"			sandbox:function(){\n"+
"				return create_sandbox();\n"+
"			}\n"+
"		};\n"+
"\n"+
"		return instanceAPI;\n"+
"	}\n"+
"\n"+
"	// create the main instance of $LAB\n"+
"	global.$LAB = create_sandbox();\n"+
"\n"+
"\n"+
"	/* The following \"hack\" was suggested by Andrea Giammarchi and adapted from: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html\n"+
"	   NOTE: this hack only operates in FF and then only in versions where document.readyState is not present (FF < 3.6?).\n"+
"\n"+
"	   The hack essentially \"patches\" the **page** that LABjs is loaded onto so that it has a proper conforming document.readyState, so that if a script which does\n"+
"	   proper and safe dom-ready detection is loaded onto a page, after dom-ready has passed, it will still be able to detect this state, by inspecting the now hacked\n"+
"	   document.readyState property. The loaded script in question can then immediately trigger any queued code executions that were waiting for the DOM to be ready.\n"+
"	   For instance, jQuery 1.4+ has been patched to take advantage of document.readyState, which is enabled by this hack. But 1.3.2 and before are **not** safe or\n"+
"	   fixed by this hack, and should therefore **not** be lazy-loaded by script loader tools such as LABjs.\n"+
"	*/\n"+
"	(function(addEvent,domLoaded,handler){\n"+
"		if (document.readyState == null && document[addEvent]){\n"+
"			document.readyState = \"loading\";\n"+
"			document[addEvent](domLoaded,handler = function(){\n"+
"				document.removeEventListener(domLoaded,handler,false);\n"+
"				document.readyState = \"complete\";\n"+
"			},false);\n"+
"		}\n"+
"	})(\"addEventListener\",\"DOMContentLoaded\");\n"+
"\n"+
"})(this);\n"+
"\n"+"";
